<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>C:/SVN_work/spreadsheet-writeexcel/lib/spreadsheet/formula.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Fri Mar 06 00:10:36 +0900 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='SVN_work-spreadsheet-writeexcel-lib-spreadsheet-formula_rb.html'>C:/SVN_work/spreadsheet-writeexcel/lib/spreadsheet/formula.rb</a>
        </td>
      <td class='lines_total'><tt>985</tt>
        </td>
      <td class='lines_code'><tt>678</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>73.3%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='73'/>
                  <td class='uncovered' width='27'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>72.7%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='73'/>
                  <td class='uncovered' width='27'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked1"><a name="line1"></a>  1 require 'strscan'
</span><span class="marked0"><a name="line2"></a>  2 require 'excelformulaparser'
</span><span class="inferred1"><a name="line3"></a>  3 
</span><span class="marked0"><a name="line4"></a>  4 class Formula &lt; ExcelFormulaParser
</span><span class="inferred1"><a name="line5"></a>  5 
</span><span class="marked0"><a name="line6"></a>  6    attr_accessor :byte_order, :workbook, :ext_sheets, :ext_refs, :ext_ref_count
</span><span class="inferred1"><a name="line7"></a>  7 
</span><span class="marked0"><a name="line8"></a>  8    def initialize(byte_order)
</span><span class="marked1"><a name="line9"></a>  9       @byte_order     = byte_order,
</span><span class="inferred0"><a name="line10"></a> 10       @workbook       = &quot;&quot;
</span><span class="marked1"><a name="line11"></a> 11       @ext_sheets     = {}
</span><span class="marked0"><a name="line12"></a> 12       @ext_refs       = {}
</span><span class="marked1"><a name="line13"></a> 13       @ext_ref_count  = 0
</span><span class="marked0"><a name="line14"></a> 14       initialize_hashes
</span><span class="inferred1"><a name="line15"></a> 15    end
</span><span class="inferred0"><a name="line16"></a> 16 
</span><span class="inferred1"><a name="line17"></a> 17    ###############################################################################
</span><span class="inferred0"><a name="line18"></a> 18    #
</span><span class="inferred1"><a name="line19"></a> 19    # parse_formula()
</span><span class="inferred0"><a name="line20"></a> 20    #
</span><span class="inferred1"><a name="line21"></a> 21    # Takes a textual description of a formula and returns a RPN encoded byte
</span><span class="inferred0"><a name="line22"></a> 22    # string.
</span><span class="inferred1"><a name="line23"></a> 23    #
</span><span class="marked0"><a name="line24"></a> 24    def parse_formula(formula, byte_stream = false)
</span><span class="inferred1"><a name="line25"></a> 25       # Build the parse tree for the formula
</span><span class="marked0"><a name="line26"></a> 26       tokens = reverse(parse(formula))
</span><span class="inferred1"><a name="line27"></a> 27    
</span><span class="inferred0"><a name="line28"></a> 28       # Add a volatile token if the formula contains a volatile function.
</span><span class="inferred1"><a name="line29"></a> 29       # This must be the first token in the list
</span><span class="inferred0"><a name="line30"></a> 30       #
</span><span class="marked1"><a name="line31"></a> 31       tokens.unshift('_vol') if check_volatile(tokens) != 0
</span><span class="inferred0"><a name="line32"></a> 32    
</span><span class="inferred1"><a name="line33"></a> 33       # The return value depends on which Worksheet.pm method is the caller
</span><span class="marked0"><a name="line34"></a> 34       unless byte_stream
</span><span class="inferred1"><a name="line35"></a> 35          # Parse formula to see if it throws any errors and then
</span><span class="inferred0"><a name="line36"></a> 36          # return raw tokens to Worksheet::store_formula()
</span><span class="inferred1"><a name="line37"></a> 37          #
</span><span class="marked0"><a name="line38"></a> 38          tokens
</span><span class="inferred1"><a name="line39"></a> 39       else
</span><span class="inferred0"><a name="line40"></a> 40          # Return byte stream to Worksheet::write_formula()
</span><span class="marked1"><a name="line41"></a> 41          parse_tokens(tokens)
</span><span class="inferred0"><a name="line42"></a> 42       end
</span><span class="inferred1"><a name="line43"></a> 43    end
</span><span class="inferred0"><a name="line44"></a> 44 
</span><span class="inferred1"><a name="line45"></a> 45    ###############################################################################
</span><span class="inferred0"><a name="line46"></a> 46    #
</span><span class="inferred1"><a name="line47"></a> 47    # parse_tokens()
</span><span class="inferred0"><a name="line48"></a> 48    #
</span><span class="inferred1"><a name="line49"></a> 49    # Convert each token or token pair to its Excel 'ptg' equivalent.
</span><span class="inferred0"><a name="line50"></a> 50    #
</span><span class="marked1"><a name="line51"></a> 51    def parse_tokens(tokens)
</span><span class="marked0"><a name="line52"></a> 52        parse_str   = ''
</span><span class="marked1"><a name="line53"></a> 53        last_type   = ''
</span><span class="marked0"><a name="line54"></a> 54        modifier    = ''
</span><span class="marked1"><a name="line55"></a> 55        num_args    = 0
</span><span class="marked0"><a name="line56"></a> 56        _class      = 0
</span><span class="marked1"><a name="line57"></a> 57        _classary   = 1
</span><span class="marked0"><a name="line58"></a> 58        args        = tokens.dup
</span><span class="inferred1"><a name="line59"></a> 59        # A note about the class modifiers used below. In general the class,
</span><span class="inferred0"><a name="line60"></a> 60        # &quot;reference&quot; or &quot;value&quot;, of a function is applied to all of its operands.
</span><span class="inferred1"><a name="line61"></a> 61        # However, in certain circumstances the operands can have mixed classes,
</span><span class="inferred0"><a name="line62"></a> 62        # e.g. =VLOOKUP with external references. These will eventually be dealt
</span><span class="inferred1"><a name="line63"></a> 63        # with by the parser. However, as a workaround the class type of a token
</span><span class="inferred0"><a name="line64"></a> 64        # can be changed via the repeat_formula interface. Thus, a _ref2d token can
</span><span class="inferred1"><a name="line65"></a> 65        # be changed by the user to _ref2dA or _ref2dR to change its token class.
</span><span class="inferred0"><a name="line66"></a> 66        #
</span><span class="marked1"><a name="line67"></a> 67        while (!args.empty?)
</span><span class="marked0"><a name="line68"></a> 68            token = args.shift
</span><span class="inferred1"><a name="line69"></a> 69    
</span><span class="marked0"><a name="line70"></a> 70            if (token == '_arg')
</span><span class="marked1"><a name="line71"></a> 71                num_args = args.shift
</span><span class="marked0"><a name="line72"></a> 72            elsif (token == '_class')
</span><span class="uncovered1"><a name="line73"></a> 73                token = args.shift
</span><span class="uncovered0"><a name="line74"></a> 74                _class = functions[token][2]
</span><span class="uncovered1"><a name="line75"></a> 75                # If _class is undef then it means that the function isn't valid.
</span><span class="uncovered0"><a name="line76"></a> 76                exit &quot;Unknown function #{token}() in formula\n&quot; if _class.nil?
</span><span class="uncovered1"><a name="line77"></a> 77                _classary.push(_class)
</span><span class="marked0"><a name="line78"></a> 78            elsif (token == '_vol')
</span><span class="uncovered1"><a name="line79"></a> 79                parse_str = parse_str + convert_volatile()
</span><span class="marked0"><a name="line80"></a> 80            elsif (token == 'ptgBool')
</span><span class="uncovered1"><a name="line81"></a> 81                token = args.shift
</span><span class="uncovered0"><a name="line82"></a> 82                parse_str = parse_str + convert_bool(token)
</span><span class="marked1"><a name="line83"></a> 83            elsif (token == '_num')
</span><span class="marked0"><a name="line84"></a> 84                token = args.shift
</span><span class="marked1"><a name="line85"></a> 85                parse_str = parse_str + convert_number(token)
</span><span class="marked0"><a name="line86"></a> 86            elsif (token == '_str')
</span><span class="uncovered1"><a name="line87"></a> 87                token = args.shift
</span><span class="uncovered0"><a name="line88"></a> 88                parse_str = parse_str + convert_string(token)
</span><span class="marked1"><a name="line89"></a> 89            elsif (token =~ /^_ref2d/)
</span><span class="marked0"><a name="line90"></a> 90                modifier  = token.sub(/_ref2d/, '')
</span><span class="marked1"><a name="line91"></a> 91                _class      = _classary[-1]
</span><span class="marked0"><a name="line92"></a> 92                _class      = 0 if modifier == 'R'
</span><span class="marked1"><a name="line93"></a> 93                _class      = 1 if modifier == 'V'
</span><span class="marked0"><a name="line94"></a> 94                token      = args.shift
</span><span class="marked1"><a name="line95"></a> 95                parse_str = parse_str + convert_ref2d(token, _class)
</span><span class="marked0"><a name="line96"></a> 96            elsif (token =~ /^_ref3d/)
</span><span class="uncovered1"><a name="line97"></a> 97                modifier  = token.sub(/_ref3d/,'')
</span><span class="uncovered0"><a name="line98"></a> 98                _class      = _classary[-1]
</span><span class="uncovered1"><a name="line99"></a> 99                _class      = 0 if modifier == 'R'
</span><span class="uncovered0"><a name="line100"></a>100                _class      = 1 if modifier == 'V'
</span><span class="uncovered1"><a name="line101"></a>101                token      = args.shift
</span><span class="uncovered0"><a name="line102"></a>102                parse_str = parse_str + convert_ref3d(token, _class)
</span><span class="marked1"><a name="line103"></a>103            elsif (token =~ /^_range2d/)
</span><span class="uncovered0"><a name="line104"></a>104                modifier  = token.sub(/_range2d/,'')
</span><span class="uncovered1"><a name="line105"></a>105                _class      = _classary[-1]
</span><span class="uncovered0"><a name="line106"></a>106                _class      = 0 if modifier == 'R'
</span><span class="uncovered1"><a name="line107"></a>107                _class      = 1 if modifier == 'V'
</span><span class="uncovered0"><a name="line108"></a>108                token      = args.shift
</span><span class="uncovered1"><a name="line109"></a>109                parse_str = parse_str + convert_range2d(token, _class)
</span><span class="marked0"><a name="line110"></a>110            elsif (token =~ /^_range3d/)
</span><span class="uncovered1"><a name="line111"></a>111                modifier  = token.sub(/_range3d/,'')
</span><span class="uncovered0"><a name="line112"></a>112                _class      = _classary[-1]
</span><span class="uncovered1"><a name="line113"></a>113                _class      = 0 if modifier == 'R'
</span><span class="uncovered0"><a name="line114"></a>114                _class      = 1 if modifier == 'V'
</span><span class="uncovered1"><a name="line115"></a>115                token      = args.shift
</span><span class="uncovered0"><a name="line116"></a>116                parse_str = parse_str + convert_range3d(token, _class)
</span><span class="marked1"><a name="line117"></a>117            elsif (token == '_func')
</span><span class="uncovered0"><a name="line118"></a>118                token = args.shift
</span><span class="uncovered1"><a name="line119"></a>119                parse_str = parse_str + convert_function(token, num_args)
</span><span class="uncovered0"><a name="line120"></a>120                _classary.pop
</span><span class="uncovered1"><a name="line121"></a>121                num_args = 0 # Reset after use
</span><span class="marked0"><a name="line122"></a>122            elsif @ptg[token]
</span><span class="marked1"><a name="line123"></a>123                parse_str = parse_str + [@ptg[token]].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line124"></a>124            else
</span><span class="uncovered1"><a name="line125"></a>125                # Unrecognised token
</span><span class="uncovered0"><a name="line126"></a>126                return nil
</span><span class="uncovered1"><a name="line127"></a>127            end
</span><span class="uncovered0"><a name="line128"></a>128        end
</span><span class="inferred1"><a name="line129"></a>129    
</span><span class="inferred0"><a name="line130"></a>130    
</span><span class="marked1"><a name="line131"></a>131        return parse_str
</span><span class="inferred0"><a name="line132"></a>132    end
</span><span class="inferred1"><a name="line133"></a>133 
</span><span class="marked0"><a name="line134"></a>134    def scan(formula)
</span><span class="marked1"><a name="line135"></a>135       s = StringScanner.new(formula)
</span><span class="marked0"><a name="line136"></a>136       q = []
</span><span class="marked1"><a name="line137"></a>137       until s.eos?
</span><span class="inferred0"><a name="line138"></a>138          # order is important.
</span><span class="marked1"><a name="line139"></a>139          if    s.scan(/(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?/)
</span><span class="marked0"><a name="line140"></a>140             q.push [:NUMBER, s.matched]
</span><span class="marked1"><a name="line141"></a>141          elsif s.scan(/&quot;([^&quot;]|&quot;&quot;)*&quot;/)
</span><span class="marked0"><a name="line142"></a>142             q.push [:STRING, s.matched]
</span><span class="marked1"><a name="line143"></a>143          elsif s.scan(/\$?[A-I]?[A-Z]\$?\d+/)
</span><span class="marked0"><a name="line144"></a>144             q.push [:REF2D,  s.matched]
</span><span class="marked1"><a name="line145"></a>145          elsif s.scan(/[^!(,]+!\$?[A-I]?[A-Z]\$?\d+/)
</span><span class="inferred0"><a name="line146"></a>146             q.push [:REF3D , s.matched]
</span><span class="marked1"><a name="line147"></a>147          elsif s.scan(/'[^']+'!\$?[A-I]?[A-Z]\$?\d+/)
</span><span class="uncovered0"><a name="line148"></a>148             q.push [:REF3D , s.matched]
</span><span class="marked1"><a name="line149"></a>149          elsif s.scan(/\$?[A-I]?[A-Z]\$?(\d+)?:\$?[A-I]?[A-Z]\$?(\d+)?/)
</span><span class="uncovered0"><a name="line150"></a>150             q.push [:RANGE2D , s.matched]
</span><span class="marked1"><a name="line151"></a>151          elsif s.scan(/[^!(,]+!\$?[A-I]?[A-Z]\$?(\d+)?:\$?[A-I]?[A-Z]\$?(\d+)?/)
</span><span class="inferred0"><a name="line152"></a>152             q.push [:RANGE3D , s.matched]
</span><span class="marked1"><a name="line153"></a>153          elsif s.scan(/&lt;=/)
</span><span class="uncovered0"><a name="line154"></a>154             q.push [:LE , s.matched]
</span><span class="marked1"><a name="line155"></a>155          elsif s.scan(/&gt;=/)
</span><span class="marked0"><a name="line156"></a>156             q.push [:GE , s.matched]
</span><span class="marked1"><a name="line157"></a>157          elsif s.scan(/&lt;&gt;/)
</span><span class="uncovered0"><a name="line158"></a>158             q.push [:NE , s.matched]
</span><span class="marked1"><a name="line159"></a>159          elsif s.scan(/&lt;/)
</span><span class="uncovered0"><a name="line160"></a>160             q.push [:LT , s.matched]
</span><span class="marked1"><a name="line161"></a>161          elsif s.scan(/&gt;/)
</span><span class="uncovered0"><a name="line162"></a>162             q.push [:GT , s.matched]
</span><span class="marked1"><a name="line163"></a>163          elsif s.scan(/TRUE/)
</span><span class="uncovered0"><a name="line164"></a>164             q.push [:TRUE, s.matched]
</span><span class="marked1"><a name="line165"></a>165          elsif s.scan(/FALSE/)
</span><span class="uncovered0"><a name="line166"></a>166             q.push [:FALSE, s.matched]
</span><span class="marked1"><a name="line167"></a>167          elsif s.scan(/[A-Z0-9_.]+/)
</span><span class="marked0"><a name="line168"></a>168             q.push [:FUNC,   s.matched]
</span><span class="marked1"><a name="line169"></a>169          elsif s.scan(/\s+/)
</span><span class="uncovered0"><a name="line170"></a>170             ;
</span><span class="marked1"><a name="line171"></a>171          elsif s.scan(/./)
</span><span class="marked0"><a name="line172"></a>172             q.push [s.matched, s.matched]
</span><span class="inferred1"><a name="line173"></a>173          end
</span><span class="inferred0"><a name="line174"></a>174       end
</span><span class="marked1"><a name="line175"></a>175       q.push [:EOL, nil]
</span><span class="inferred0"><a name="line176"></a>176    end
</span><span class="inferred1"><a name="line177"></a>177 
</span><span class="marked0"><a name="line178"></a>178    def parse(formula)
</span><span class="marked1"><a name="line179"></a>179       @q = scan(formula)
</span><span class="marked0"><a name="line180"></a>180       @q.push [false, nil]
</span><span class="marked1"><a name="line181"></a>181       do_parse
</span><span class="inferred0"><a name="line182"></a>182    end
</span><span class="inferred1"><a name="line183"></a>183 
</span><span class="marked0"><a name="line184"></a>184    def next_token
</span><span class="marked1"><a name="line185"></a>185       @q.shift
</span><span class="marked0"><a name="line186"></a>186    end
</span><span class="inferred1"><a name="line187"></a>187 
</span><span class="marked0"><a name="line188"></a>188    def reverse(expression)
</span><span class="marked1"><a name="line189"></a>189       q = []
</span><span class="marked0"><a name="line190"></a>190       expression.each do |e|
</span><span class="marked1"><a name="line191"></a>191          if e.kind_of?(Array)
</span><span class="marked0"><a name="line192"></a>192             qq = reverse(e)
</span><span class="marked1"><a name="line193"></a>193             qq.each { |ee| q.push ee }
</span><span class="inferred0"><a name="line194"></a>194          else
</span><span class="marked1"><a name="line195"></a>195             q.push e
</span><span class="inferred0"><a name="line196"></a>196          end
</span><span class="inferred1"><a name="line197"></a>197       end
</span><span class="marked0"><a name="line198"></a>198       q
</span><span class="inferred1"><a name="line199"></a>199    end
</span><span class="inferred0"><a name="line200"></a>200 
</span><span class="inferred1"><a name="line201"></a>201 
</span><span class="inferred0"><a name="line202"></a>202    ###############################################################################
</span><span class="inferred1"><a name="line203"></a>203 
</span><span class="marked0"><a name="line204"></a>204    private
</span><span class="inferred1"><a name="line205"></a>205    
</span><span class="inferred0"><a name="line206"></a>206    ###############################################################################
</span><span class="inferred1"><a name="line207"></a>207 
</span><span class="inferred0"><a name="line208"></a>208 
</span><span class="inferred1"><a name="line209"></a>209    ###############################################################################
</span><span class="inferred0"><a name="line210"></a>210    #
</span><span class="inferred1"><a name="line211"></a>211    #  _check_volatile()
</span><span class="inferred0"><a name="line212"></a>212    #
</span><span class="inferred1"><a name="line213"></a>213    # Check if the formula contains a volatile function, i.e. a function that must
</span><span class="inferred0"><a name="line214"></a>214    # be recalculated each time a cell is updated. These formulas require a ptgAttr
</span><span class="inferred1"><a name="line215"></a>215    # with the volatile flag set as the first token in the parsed expression.
</span><span class="inferred0"><a name="line216"></a>216    #
</span><span class="inferred1"><a name="line217"></a>217    # Examples of volatile functions: RAND(), NOW(), TODAY()
</span><span class="inferred0"><a name="line218"></a>218    #
</span><span class="marked1"><a name="line219"></a>219    def check_volatile(tokens)
</span><span class="marked0"><a name="line220"></a>220       volatile = 0
</span><span class="inferred1"><a name="line221"></a>221    
</span><span class="marked0"><a name="line222"></a>222       (0..tokens.size-1).each do |i|
</span><span class="inferred1"><a name="line223"></a>223          # If the next token is a function check if it is volatile.
</span><span class="marked0"><a name="line224"></a>224          if tokens[i] == '_func' and functions[tokens[i+1]][3] != 0
</span><span class="uncovered1"><a name="line225"></a>225             volatile = 1
</span><span class="uncovered0"><a name="line226"></a>226             break
</span><span class="uncovered1"><a name="line227"></a>227          end
</span><span class="uncovered0"><a name="line228"></a>228       end
</span><span class="inferred1"><a name="line229"></a>229    
</span><span class="marked0"><a name="line230"></a>230       return volatile
</span><span class="inferred1"><a name="line231"></a>231    end
</span><span class="inferred0"><a name="line232"></a>232 
</span><span class="inferred1"><a name="line233"></a>233    ###############################################################################
</span><span class="inferred0"><a name="line234"></a>234    #
</span><span class="inferred1"><a name="line235"></a>235    # _convert_bool()
</span><span class="inferred0"><a name="line236"></a>236    #
</span><span class="inferred1"><a name="line237"></a>237    # Convert a boolean token to ptgBool
</span><span class="inferred0"><a name="line238"></a>238    #
</span><span class="marked1"><a name="line239"></a>239    def convert_bool(bool)
</span><span class="uncovered0"><a name="line240"></a>240        return [@ptg['ptgBool'], bool].pack(&quot;CC&quot;)
</span><span class="uncovered1"><a name="line241"></a>241    end
</span><span class="inferred0"><a name="line242"></a>242 
</span><span class="inferred1"><a name="line243"></a>243 
</span><span class="inferred0"><a name="line244"></a>244    ###############################################################################
</span><span class="inferred1"><a name="line245"></a>245    #
</span><span class="inferred0"><a name="line246"></a>246    # _convert_number()
</span><span class="inferred1"><a name="line247"></a>247    #
</span><span class="inferred0"><a name="line248"></a>248    # Convert a number token to ptgInt or ptgNum
</span><span class="inferred1"><a name="line249"></a>249    #
</span><span class="marked0"><a name="line250"></a>250    def convert_number(num)
</span><span class="inferred1"><a name="line251"></a>251        # Integer in the range 0..2**16-1
</span><span class="marked0"><a name="line252"></a>252        if ((num =~ /^\d+$/) &amp;&amp; (num.to_i &lt;= 65535))
</span><span class="marked1"><a name="line253"></a>253            return [@ptg['ptgInt'], num.to_i].pack(&quot;Cv&quot;)
</span><span class="uncovered0"><a name="line254"></a>254        else  # A float
</span><span class="uncovered1"><a name="line255"></a>255            num = [num].pack(&quot;d&quot;)
</span><span class="uncovered0"><a name="line256"></a>256            num.reverse! if @byte_order != 0
</span><span class="uncovered1"><a name="line257"></a>257            return [@ptg['ptgNum']].pack(&quot;C&quot;) + num
</span><span class="uncovered0"><a name="line258"></a>258        end
</span><span class="marked1"><a name="line259"></a>259    end
</span><span class="inferred0"><a name="line260"></a>260 
</span><span class="inferred1"><a name="line261"></a>261    ###############################################################################
</span><span class="inferred0"><a name="line262"></a>262    #
</span><span class="inferred1"><a name="line263"></a>263    # _convert_string()
</span><span class="inferred0"><a name="line264"></a>264    #
</span><span class="inferred1"><a name="line265"></a>265    # Convert a string to a ptg Str.
</span><span class="inferred0"><a name="line266"></a>266    #
</span><span class="marked1"><a name="line267"></a>267    def convert_string(str)
</span><span class="uncovered0"><a name="line268"></a>268        encoding = 0
</span><span class="uncovered1"><a name="line269"></a>269    
</span><span class="uncovered0"><a name="line270"></a>270        str.sub!(/^&quot;/,'')   # Remove leading  &quot;
</span><span class="uncovered1"><a name="line271"></a>271        str.sub!(/&quot;$/,'')   # Remove trailing &quot;
</span><span class="uncovered0"><a name="line272"></a>272        str.gsub!(/&quot;&quot;/,'&quot;') # Substitute Excel's escaped double quote &quot;&quot; for &quot;
</span><span class="uncovered1"><a name="line273"></a>273    
</span><span class="uncovered0"><a name="line274"></a>274        length = str.length
</span><span class="uncovered1"><a name="line275"></a>275    
</span><span class="uncovered0"><a name="line276"></a>276        exit &quot;String in formula has more than 255 chars\n&quot; if length &gt; 255
</span><span class="uncovered1"><a name="line277"></a>277    
</span><span class="uncovered0"><a name="line278"></a>278        return [@ptg['ptgStr'], length, encoding].pack(&quot;CCC&quot;) + str
</span><span class="uncovered1"><a name="line279"></a>279    end
</span><span class="inferred0"><a name="line280"></a>280 
</span><span class="inferred1"><a name="line281"></a>281    ###############################################################################
</span><span class="inferred0"><a name="line282"></a>282    #
</span><span class="inferred1"><a name="line283"></a>283    # _convert_ref2d()
</span><span class="inferred0"><a name="line284"></a>284    #
</span><span class="inferred1"><a name="line285"></a>285    # Convert an Excel reference such as A1, $B2, C$3 or $D$4 to a ptgRefV.
</span><span class="inferred0"><a name="line286"></a>286    #
</span><span class="marked1"><a name="line287"></a>287    def convert_ref2d(cell, _class)
</span><span class="inferred0"><a name="line288"></a>288        # Convert the cell reference
</span><span class="marked1"><a name="line289"></a>289        row, col = cell_to_packed_rowcol(cell)
</span><span class="inferred0"><a name="line290"></a>290    
</span><span class="inferred1"><a name="line291"></a>291        # The ptg value depends on the class of the ptg.
</span><span class="marked0"><a name="line292"></a>292        if    (_class == 0)
</span><span class="marked1"><a name="line293"></a>293            ptgref = [@ptg['ptgRef']].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line294"></a>294        elsif (_class == 1)
</span><span class="uncovered1"><a name="line295"></a>295            ptgref = [@ptg['ptgRefV']].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line296"></a>296        elsif (_class == 2)
</span><span class="uncovered1"><a name="line297"></a>297            ptgref = [@ptg['ptgRefA']].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line298"></a>298        else
</span><span class="uncovered1"><a name="line299"></a>299            exit &quot;Unknown function class in formula\n&quot;
</span><span class="uncovered0"><a name="line300"></a>300        end
</span><span class="inferred1"><a name="line301"></a>301    
</span><span class="marked0"><a name="line302"></a>302        return ptgref + row + col
</span><span class="inferred1"><a name="line303"></a>303    end
</span><span class="inferred0"><a name="line304"></a>304 
</span><span class="inferred1"><a name="line305"></a>305    ###############################################################################
</span><span class="inferred0"><a name="line306"></a>306    #
</span><span class="inferred1"><a name="line307"></a>307    # _convert_ref3d
</span><span class="inferred0"><a name="line308"></a>308    #
</span><span class="inferred1"><a name="line309"></a>309    # Convert an Excel 3d reference such as &quot;Sheet1!A1&quot; or &quot;Sheet1:Sheet2!A1&quot; to a
</span><span class="inferred0"><a name="line310"></a>310    # ptgRef3dV.
</span><span class="inferred1"><a name="line311"></a>311    #
</span><span class="marked0"><a name="line312"></a>312    def convert_ref3d(token, _class)
</span><span class="uncovered1"><a name="line313"></a>313        # Split the ref at the ! symbol
</span><span class="uncovered0"><a name="line314"></a>314        ext_ref, cell = token.split('!')
</span><span class="uncovered1"><a name="line315"></a>315    
</span><span class="uncovered0"><a name="line316"></a>316        # Convert the external reference part
</span><span class="uncovered1"><a name="line317"></a>317        ext_ref = pack_ext_ref(ext_ref)
</span><span class="uncovered0"><a name="line318"></a>318    
</span><span class="uncovered1"><a name="line319"></a>319        # Convert the cell reference part
</span><span class="uncovered0"><a name="line320"></a>320        row, col = cell_to_packed_rowcol(cell)
</span><span class="uncovered1"><a name="line321"></a>321    
</span><span class="uncovered0"><a name="line322"></a>322        # The ptg value depends on the class of the ptg.
</span><span class="uncovered1"><a name="line323"></a>323        if    (_class == 0)
</span><span class="uncovered0"><a name="line324"></a>324            ptgref = [@ptg['ptgRef3d']].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line325"></a>325        elsif (_class == 1) 
</span><span class="uncovered0"><a name="line326"></a>326            ptgref = [@ptg['ptgRef3dV']].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line327"></a>327        elsif (_class == 2) 
</span><span class="uncovered0"><a name="line328"></a>328            ptgref = [@ptg['ptgRef3dA']].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line329"></a>329        else
</span><span class="uncovered0"><a name="line330"></a>330            exit &quot;Unknown function class in formula\n&quot;
</span><span class="uncovered1"><a name="line331"></a>331        end
</span><span class="uncovered0"><a name="line332"></a>332    
</span><span class="uncovered1"><a name="line333"></a>333        return ptgref + ext_ref + row + col
</span><span class="uncovered0"><a name="line334"></a>334    end
</span><span class="inferred1"><a name="line335"></a>335 
</span><span class="inferred0"><a name="line336"></a>336    ###############################################################################
</span><span class="inferred1"><a name="line337"></a>337    #
</span><span class="inferred0"><a name="line338"></a>338    # _convert_range2d()
</span><span class="inferred1"><a name="line339"></a>339    #
</span><span class="inferred0"><a name="line340"></a>340    # Convert an Excel range such as A1:D4 or A:D to a ptgRefV.
</span><span class="inferred1"><a name="line341"></a>341    #
</span><span class="marked0"><a name="line342"></a>342    def convert_range2d(range, _class)
</span><span class="uncovered1"><a name="line343"></a>343        # Split the range into 2 cell refs
</span><span class="uncovered0"><a name="line344"></a>344        cell1, cell2 = range.split(':')
</span><span class="uncovered1"><a name="line345"></a>345 
</span><span class="uncovered0"><a name="line346"></a>346        # A range such as A:D is equivalent to A1:D65536, so add rows as required
</span><span class="uncovered1"><a name="line347"></a>347        cell1 = cell1 + '1'     unless cell1 =~ /\d/
</span><span class="uncovered0"><a name="line348"></a>348        cell2 = cell2 + '65536' unless cell2 =~ /\d/
</span><span class="uncovered1"><a name="line349"></a>349    
</span><span class="uncovered0"><a name="line350"></a>350        # Convert the cell references
</span><span class="uncovered1"><a name="line351"></a>351        row1, col1 = cell_to_packed_rowcol(cell1)
</span><span class="uncovered0"><a name="line352"></a>352        row2, col2 = cell_to_packed_rowcol(cell2)
</span><span class="uncovered1"><a name="line353"></a>353    
</span><span class="uncovered0"><a name="line354"></a>354        # The ptg value depends on the class of the ptg.
</span><span class="uncovered1"><a name="line355"></a>355        if    (_class == 0)
</span><span class="uncovered0"><a name="line356"></a>356            ptgarea = [@ptg['ptgArea']].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line357"></a>357        elsif (_class == 1)
</span><span class="uncovered0"><a name="line358"></a>358            ptgarea = [@ptg['ptgAreaV']].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line359"></a>359        elsif (_class == 2)
</span><span class="uncovered0"><a name="line360"></a>360            ptgarea = [@ptg['ptgAreaA']].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line361"></a>361        else
</span><span class="uncovered0"><a name="line362"></a>362            exit &quot;Unknown function class in formula\n&quot;
</span><span class="uncovered1"><a name="line363"></a>363        end
</span><span class="uncovered0"><a name="line364"></a>364    
</span><span class="uncovered1"><a name="line365"></a>365        return ptgarea + row1 + row2 + col1 + col2
</span><span class="uncovered0"><a name="line366"></a>366    end
</span><span class="inferred1"><a name="line367"></a>367 
</span><span class="inferred0"><a name="line368"></a>368    ###############################################################################
</span><span class="inferred1"><a name="line369"></a>369    #
</span><span class="inferred0"><a name="line370"></a>370    # _convert_range3d
</span><span class="inferred1"><a name="line371"></a>371    #
</span><span class="inferred0"><a name="line372"></a>372    # Convert an Excel 3d range such as &quot;Sheet1!A1:D4&quot; or &quot;Sheet1:Sheet2!A1:D4&quot; to
</span><span class="inferred1"><a name="line373"></a>373    # a ptgArea3dV.
</span><span class="inferred0"><a name="line374"></a>374    #
</span><span class="marked1"><a name="line375"></a>375    def convert_range3d(token, _class)
</span><span class="uncovered0"><a name="line376"></a>376        # Split the ref at the ! symbol
</span><span class="uncovered1"><a name="line377"></a>377        ext_ref, range = token.split('!')
</span><span class="uncovered0"><a name="line378"></a>378    
</span><span class="uncovered1"><a name="line379"></a>379        # Convert the external reference part
</span><span class="uncovered0"><a name="line380"></a>380        ext_ref = pack_ext_ref(ext_ref)
</span><span class="uncovered1"><a name="line381"></a>381    
</span><span class="uncovered0"><a name="line382"></a>382        # Split the range into 2 cell refs
</span><span class="uncovered1"><a name="line383"></a>383        cell1, cell2 = range.split(':')
</span><span class="uncovered0"><a name="line384"></a>384    
</span><span class="uncovered1"><a name="line385"></a>385        # A range such as A:D is equivalent to A1:D65536, so add rows as required
</span><span class="uncovered0"><a name="line386"></a>386        cell1 = cell1 + '1'     unless cell1 =~ /\d/
</span><span class="uncovered1"><a name="line387"></a>387        cell2 = cell2 + '65536' unless cell2 =~ /\d/
</span><span class="uncovered0"><a name="line388"></a>388    
</span><span class="uncovered1"><a name="line389"></a>389        # Convert the cell references
</span><span class="uncovered0"><a name="line390"></a>390        row1, col1 = cell_to_packed_rowcol(cell1)
</span><span class="uncovered1"><a name="line391"></a>391        row2, col2 = cell_to_packed_rowcol(cell2)
</span><span class="uncovered0"><a name="line392"></a>392    
</span><span class="uncovered1"><a name="line393"></a>393        # The ptg value depends on the class of the ptg.
</span><span class="uncovered0"><a name="line394"></a>394        if    (_class == 0)
</span><span class="uncovered1"><a name="line395"></a>395            ptgarea = [@ptg['ptgArea3d']].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line396"></a>396        elsif (_class == 1)
</span><span class="uncovered1"><a name="line397"></a>397            ptgarea = [@ptg['ptgArea3dV']].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line398"></a>398        elsif (_class == 2)
</span><span class="uncovered1"><a name="line399"></a>399            ptgarea = [@ptg['ptgArea3dA']].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line400"></a>400        else
</span><span class="uncovered1"><a name="line401"></a>401            exit &quot;Unknown function class in formula\n&quot;
</span><span class="uncovered0"><a name="line402"></a>402        end
</span><span class="uncovered1"><a name="line403"></a>403    
</span><span class="uncovered0"><a name="line404"></a>404        return ptgarea + ext_ref + row1 + row2 + col1+ col2
</span><span class="uncovered1"><a name="line405"></a>405    end
</span><span class="inferred0"><a name="line406"></a>406 
</span><span class="inferred1"><a name="line407"></a>407    ###############################################################################
</span><span class="inferred0"><a name="line408"></a>408    #
</span><span class="inferred1"><a name="line409"></a>409    # _pack_ext_ref()
</span><span class="inferred0"><a name="line410"></a>410    #
</span><span class="inferred1"><a name="line411"></a>411    # Convert the sheet name part of an external reference, for example &quot;Sheet1&quot; or
</span><span class="inferred0"><a name="line412"></a>412    # &quot;Sheet1:Sheet2&quot;, to a packed structure.
</span><span class="inferred1"><a name="line413"></a>413    #
</span><span class="marked0"><a name="line414"></a>414    def pack_ext_ref(ext_ref)
</span><span class="uncovered1"><a name="line415"></a>415        ext_ref.sub!(/^'/,'')   # Remove leading  ' if any.
</span><span class="uncovered0"><a name="line416"></a>416        ext_ref.sub!(/'$/,'')   # Remove trailing ' if any.
</span><span class="uncovered1"><a name="line417"></a>417    
</span><span class="uncovered0"><a name="line418"></a>418        # Check if there is a sheet range eg., Sheet1:Sheet2.
</span><span class="uncovered1"><a name="line419"></a>419        if (ext_ref =~ /:/)
</span><span class="uncovered0"><a name="line420"></a>420            sheet1, sheet2 = ext_ref.split(':')
</span><span class="uncovered1"><a name="line421"></a>421    
</span><span class="uncovered0"><a name="line422"></a>422            sheet1 = get_sheet_index(sheet1)
</span><span class="uncovered1"><a name="line423"></a>423            sheet2 = get_sheet_index(sheet2)
</span><span class="uncovered0"><a name="line424"></a>424    
</span><span class="uncovered1"><a name="line425"></a>425            # Reverse max and min sheet numbers if necessary
</span><span class="uncovered0"><a name="line426"></a>426            if (sheet1 &gt; sheet2)
</span><span class="uncovered1"><a name="line427"></a>427                sheet1, sheet2 = [sheet2, sheet1]
</span><span class="uncovered0"><a name="line428"></a>428            end
</span><span class="uncovered1"><a name="line429"></a>429        else 
</span><span class="uncovered0"><a name="line430"></a>430            # Single sheet name only.
</span><span class="uncovered1"><a name="line431"></a>431            sheet1, sheet2 = [ext_ref, ext_ref]
</span><span class="uncovered0"><a name="line432"></a>432    
</span><span class="uncovered1"><a name="line433"></a>433            sheet1 = get_sheet_index(sheet1)
</span><span class="uncovered0"><a name="line434"></a>434            sheet2 = sheet1
</span><span class="uncovered1"><a name="line435"></a>435        end
</span><span class="uncovered0"><a name="line436"></a>436    
</span><span class="uncovered1"><a name="line437"></a>437        key = &quot;#{sheet1}:#{sheet2}&quot;
</span><span class="uncovered0"><a name="line438"></a>438    
</span><span class="uncovered1"><a name="line439"></a>439        unless @ext_refs[key]
</span><span class="uncovered0"><a name="line440"></a>440            index = @ext_refs[key]
</span><span class="uncovered1"><a name="line441"></a>441        else
</span><span class="uncovered0"><a name="line442"></a>442            index = @ext_ref_count
</span><span class="uncovered1"><a name="line443"></a>443            @ext_refs[key] = index
</span><span class="uncovered0"><a name="line444"></a>444            @ext_ref_count += 1
</span><span class="uncovered1"><a name="line445"></a>445        end
</span><span class="uncovered0"><a name="line446"></a>446    
</span><span class="uncovered1"><a name="line447"></a>447        return [index].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line448"></a>448    end
</span><span class="inferred1"><a name="line449"></a>449 
</span><span class="inferred0"><a name="line450"></a>450    ###############################################################################
</span><span class="inferred1"><a name="line451"></a>451    #
</span><span class="inferred0"><a name="line452"></a>452    # _get_sheet_index()
</span><span class="inferred1"><a name="line453"></a>453    #
</span><span class="inferred0"><a name="line454"></a>454    # Look up the index that corresponds to an external sheet name. The hash of
</span><span class="inferred1"><a name="line455"></a>455    # sheet names is updated by the add_worksheet() method of the Workbook class.
</span><span class="inferred0"><a name="line456"></a>456    #
</span><span class="marked1"><a name="line457"></a>457    def get_sheet_index(sheet_name)
</span><span class="uncovered0"><a name="line458"></a>458        if @ext_sheets[sheet_name].nil?
</span><span class="uncovered1"><a name="line459"></a>459            exit &quot;Unknown sheet name #{sheet_name} in formula\n&quot;
</span><span class="uncovered0"><a name="line460"></a>460        else 
</span><span class="uncovered1"><a name="line461"></a>461            return @ext_sheets[sheet_name]
</span><span class="uncovered0"><a name="line462"></a>462        end
</span><span class="uncovered1"><a name="line463"></a>463    end
</span><span class="inferred0"><a name="line464"></a>464 
</span><span class="inferred1"><a name="line465"></a>465    ###############################################################################
</span><span class="inferred0"><a name="line466"></a>466    #
</span><span class="inferred1"><a name="line467"></a>467    # set_ext_sheets()
</span><span class="inferred0"><a name="line468"></a>468    #
</span><span class="inferred1"><a name="line469"></a>469    # This semi-public method is used to update the hash of sheet names. It is
</span><span class="inferred0"><a name="line470"></a>470    # updated by the add_worksheet() method of the Workbook class.
</span><span class="inferred1"><a name="line471"></a>471    #
</span><span class="marked0"><a name="line472"></a>472    def set_ext_sheets(worksheet, index)
</span><span class="uncovered1"><a name="line473"></a>473        # The _ext_sheets hash is used to translate between worksheet names
</span><span class="uncovered0"><a name="line474"></a>474        # and their index
</span><span class="uncovered1"><a name="line475"></a>475        @ext_sheets[worksheet] = index
</span><span class="uncovered0"><a name="line476"></a>476    
</span><span class="uncovered1"><a name="line477"></a>477    
</span><span class="uncovered0"><a name="line478"></a>478        # 2D sheet refs such as '=Sheet1:Sheet2!A1' can only be added after all
</span><span class="uncovered1"><a name="line479"></a>479        # worksheets have been added.
</span><span class="uncovered0"><a name="line480"></a>480        #return 0 if $index &lt; $self-&gt;{_ext_ref_count}; TODO
</span><span class="uncovered1"><a name="line481"></a>481    
</span><span class="uncovered0"><a name="line482"></a>482    
</span><span class="uncovered1"><a name="line483"></a>483        # The _ext_refs hash is used to correlate the external references used in
</span><span class="uncovered0"><a name="line484"></a>484        # formulas with the index stored in the Workbook EXTERNSHEET record.
</span><span class="uncovered1"><a name="line485"></a>485        #$self-&gt;{_ext_refs}-&gt;{$ref} = $index;
</span><span class="uncovered0"><a name="line486"></a>486        #$self-&gt;{_ext_ref_count}++;
</span><span class="uncovered1"><a name="line487"></a>487    
</span><span class="uncovered0"><a name="line488"></a>488        # No errors
</span><span class="uncovered1"><a name="line489"></a>489        #return 1;
</span><span class="uncovered0"><a name="line490"></a>490    end
</span><span class="inferred1"><a name="line491"></a>491 
</span><span class="inferred0"><a name="line492"></a>492    ###############################################################################
</span><span class="inferred1"><a name="line493"></a>493    #
</span><span class="inferred0"><a name="line494"></a>494    # get_ext_sheets()
</span><span class="inferred1"><a name="line495"></a>495    #
</span><span class="inferred0"><a name="line496"></a>496    # This semi-public method is used to update the hash of sheet names. It is
</span><span class="inferred1"><a name="line497"></a>497    # updated by the add_worksheet() method of the Workbook class.
</span><span class="inferred0"><a name="line498"></a>498    #
</span><span class="inferred1"><a name="line499"></a>499    # TODO
</span><span class="inferred0"><a name="line500"></a>500    #
</span><span class="marked1"><a name="line501"></a>501    def get_ext_sheets
</span><span class="uncovered0"><a name="line502"></a>502        # TODO
</span><span class="uncovered1"><a name="line503"></a>503        refs = @ext_refs;
</span><span class="uncovered0"><a name="line504"></a>504        return refs
</span><span class="uncovered1"><a name="line505"></a>505    
</span><span class="uncovered0"><a name="line506"></a>506        #my @refs = sort {$refs{$a} &lt;=&gt; $refs{$b}} keys %refs;
</span><span class="uncovered1"><a name="line507"></a>507    
</span><span class="uncovered0"><a name="line508"></a>508        #foreach my $ref (@refs) {
</span><span class="uncovered1"><a name="line509"></a>509        #    $ref = [split /:/, $ref];
</span><span class="uncovered0"><a name="line510"></a>510        #}
</span><span class="uncovered1"><a name="line511"></a>511    
</span><span class="uncovered0"><a name="line512"></a>512        #return @refs;
</span><span class="uncovered1"><a name="line513"></a>513    end
</span><span class="inferred0"><a name="line514"></a>514 
</span><span class="inferred1"><a name="line515"></a>515    ###############################################################################
</span><span class="inferred0"><a name="line516"></a>516    #
</span><span class="inferred1"><a name="line517"></a>517    # get_ext_ref_count()
</span><span class="inferred0"><a name="line518"></a>518    #
</span><span class="inferred1"><a name="line519"></a>519    # TODO This semi-public method is used to update the hash of sheet names. It is
</span><span class="inferred0"><a name="line520"></a>520    # updated by the add_worksheet() method of the Workbook class.
</span><span class="inferred1"><a name="line521"></a>521    #
</span><span class="marked0"><a name="line522"></a>522    def get_ext_ref_count
</span><span class="uncovered1"><a name="line523"></a>523        return @ext_ref_count
</span><span class="uncovered0"><a name="line524"></a>524    end
</span><span class="inferred1"><a name="line525"></a>525 
</span><span class="inferred0"><a name="line526"></a>526    ###############################################################################
</span><span class="inferred1"><a name="line527"></a>527    #
</span><span class="inferred0"><a name="line528"></a>528    # _convert_function()
</span><span class="inferred1"><a name="line529"></a>529    #
</span><span class="inferred0"><a name="line530"></a>530    # Convert a function to a ptgFunc or ptgFuncVarV depending on the number of
</span><span class="inferred1"><a name="line531"></a>531    # args that it takes.
</span><span class="inferred0"><a name="line532"></a>532    #
</span><span class="marked1"><a name="line533"></a>533    def convert_function(token, num_args)
</span><span class="uncovered0"><a name="line534"></a>534        exit &quot;Unknown function #{token}() in formula\n&quot; if @functions[token][0].nil?
</span><span class="uncovered1"><a name="line535"></a>535    
</span><span class="uncovered0"><a name="line536"></a>536        args = @functions[token][1]
</span><span class="uncovered1"><a name="line537"></a>537    
</span><span class="uncovered0"><a name="line538"></a>538        # Fixed number of args eg. TIME($i,$j,$k).
</span><span class="uncovered1"><a name="line539"></a>539        if (args &gt;= 0)
</span><span class="uncovered0"><a name="line540"></a>540            # Check that the number of args is valid.
</span><span class="uncovered1"><a name="line541"></a>541            if (args != num_args)
</span><span class="uncovered0"><a name="line542"></a>542                exit &quot;Incorrect number of arguments for #{token}() in formula\n&quot;;
</span><span class="uncovered1"><a name="line543"></a>543            else
</span><span class="uncovered0"><a name="line544"></a>544                return [ptg['ptgFuncV'], @function[token][0]].pack(&quot;Cv&quot;)
</span><span class="uncovered1"><a name="line545"></a>545            end
</span><span class="uncovered0"><a name="line546"></a>546        end
</span><span class="uncovered1"><a name="line547"></a>547    
</span><span class="uncovered0"><a name="line548"></a>548        # Variable number of args eg. SUM(i,j,k, ..).
</span><span class="uncovered1"><a name="line549"></a>549        if (args == -1)
</span><span class="uncovered0"><a name="line550"></a>550            return [ptg['ptgFuncVarV'], num_args, @function[token][0]].pack(&quot;CCv&quot;)
</span><span class="uncovered1"><a name="line551"></a>551        end
</span><span class="uncovered0"><a name="line552"></a>552    end
</span><span class="inferred1"><a name="line553"></a>553 
</span><span class="inferred0"><a name="line554"></a>554    ###############################################################################
</span><span class="inferred1"><a name="line555"></a>555    #
</span><span class="inferred0"><a name="line556"></a>556    # _cell_to_rowcol($cell_ref)
</span><span class="inferred1"><a name="line557"></a>557    #
</span><span class="inferred0"><a name="line558"></a>558    # Convert an Excel cell reference such as A1 or $B2 or C$3 or $D$4 to a zero
</span><span class="inferred1"><a name="line559"></a>559    # indexed row and column number. Also returns two boolean values to indicate
</span><span class="inferred0"><a name="line560"></a>560    # whether the row or column are relative references.
</span><span class="inferred1"><a name="line561"></a>561    # TODO use function in Utility.pm
</span><span class="inferred0"><a name="line562"></a>562    #
</span><span class="marked1"><a name="line563"></a>563    def cell_to_rowcol(cell)
</span><span class="marked0"><a name="line564"></a>564        cell =~ /(\$?)([A-I]?[A-Z])(\$?)(\d+)/
</span><span class="inferred1"><a name="line565"></a>565    
</span><span class="marked0"><a name="line566"></a>566        col_rel = $1 == &quot;&quot; ? 1 : 0
</span><span class="marked1"><a name="line567"></a>567        col     = $2
</span><span class="marked0"><a name="line568"></a>568        row_rel = $3 == &quot;&quot; ? 1 : 0
</span><span class="marked1"><a name="line569"></a>569        row     = $4.to_i
</span><span class="inferred0"><a name="line570"></a>570    
</span><span class="inferred1"><a name="line571"></a>571        # Convert base26 column string to a number.
</span><span class="inferred0"><a name="line572"></a>572        # All your Base are belong to us.
</span><span class="marked1"><a name="line573"></a>573        chars  = col.split(//)
</span><span class="marked0"><a name="line574"></a>574        expn   = 0
</span><span class="marked1"><a name="line575"></a>575        col    = 0
</span><span class="inferred0"><a name="line576"></a>576    
</span><span class="marked1"><a name="line577"></a>577        while (!chars.empty?)
</span><span class="marked0"><a name="line578"></a>578            char = chars.pop   # LS char first
</span><span class="marked1"><a name="line579"></a>579            col  = col + (char[0] - 65 + 1) * (26**expn)
</span><span class="inferred0"><a name="line580"></a>580                #####  ord(char) - ord('A')  in perl  ####
</span><span class="marked1"><a name="line581"></a>581            expn += 1
</span><span class="inferred0"><a name="line582"></a>582        end
</span><span class="marked1"><a name="line583"></a>583 bp = true   
</span><span class="inferred0"><a name="line584"></a>584        # Convert 1-index to zero-index
</span><span class="marked1"><a name="line585"></a>585        row -= 1
</span><span class="marked0"><a name="line586"></a>586        col -= 1
</span><span class="inferred1"><a name="line587"></a>587    
</span><span class="marked0"><a name="line588"></a>588        return [row, col, row_rel, col_rel]
</span><span class="inferred1"><a name="line589"></a>589    end
</span><span class="inferred0"><a name="line590"></a>590 
</span><span class="inferred1"><a name="line591"></a>591    ###############################################################################
</span><span class="inferred0"><a name="line592"></a>592    #
</span><span class="inferred1"><a name="line593"></a>593    # _cell_to_packed_rowcol($row, $col, $row_rel, $col_rel)
</span><span class="inferred0"><a name="line594"></a>594    #
</span><span class="inferred1"><a name="line595"></a>595    # pack() row and column into the required 3 byte format.
</span><span class="inferred0"><a name="line596"></a>596    #
</span><span class="marked1"><a name="line597"></a>597    def cell_to_packed_rowcol(cell)
</span><span class="marked0"><a name="line598"></a>598        row, col, row_rel, col_rel = cell_to_rowcol(cell)
</span><span class="inferred1"><a name="line599"></a>599    
</span><span class="marked0"><a name="line600"></a>600        exit &quot;Column #{cell} greater than IV in formula\n&quot; if col &gt;= 256
</span><span class="marked1"><a name="line601"></a>601        exit &quot;Row #{cell} greater than 65536 in formula\n&quot; if row &gt;= 65536
</span><span class="inferred0"><a name="line602"></a>602    
</span><span class="inferred1"><a name="line603"></a>603        # Set the high bits to indicate if row or col are relative.
</span><span class="marked0"><a name="line604"></a>604        col    |= col_rel &lt;&lt; 14
</span><span class="marked1"><a name="line605"></a>605        col    |= row_rel &lt;&lt; 15
</span><span class="inferred0"><a name="line606"></a>606    
</span><span class="marked1"><a name="line607"></a>607        row     = [row].pack('v')
</span><span class="marked0"><a name="line608"></a>608        col     = [col].pack('v')
</span><span class="inferred1"><a name="line609"></a>609    
</span><span class="marked0"><a name="line610"></a>610        return [row, col]
</span><span class="inferred1"><a name="line611"></a>611    end
</span><span class="inferred0"><a name="line612"></a>612 
</span><span class="inferred1"><a name="line613"></a>613    ###############################################################################
</span><span class="inferred0"><a name="line614"></a>614    #
</span><span class="inferred1"><a name="line615"></a>615    # _initialize_hashes()
</span><span class="inferred0"><a name="line616"></a>616    #
</span><span class="marked1"><a name="line617"></a>617    def initialize_hashes
</span><span class="inferred0"><a name="line618"></a>618    
</span><span class="inferred1"><a name="line619"></a>619        # The Excel ptg indices
</span><span class="marked0"><a name="line620"></a>620        @ptg = {
</span><span class="inferred1"><a name="line621"></a>621            'ptgExp'            =&gt; 0x01,
</span><span class="inferred0"><a name="line622"></a>622            'ptgTbl'            =&gt; 0x02,
</span><span class="inferred1"><a name="line623"></a>623            'ptgAdd'            =&gt; 0x03,
</span><span class="inferred0"><a name="line624"></a>624            'ptgSub'            =&gt; 0x04,
</span><span class="inferred1"><a name="line625"></a>625            'ptgMul'            =&gt; 0x05,
</span><span class="inferred0"><a name="line626"></a>626            'ptgDiv'            =&gt; 0x06,
</span><span class="inferred1"><a name="line627"></a>627            'ptgPower'          =&gt; 0x07,
</span><span class="inferred0"><a name="line628"></a>628            'ptgConcat'         =&gt; 0x08,
</span><span class="inferred1"><a name="line629"></a>629            'ptgLT'             =&gt; 0x09,
</span><span class="inferred0"><a name="line630"></a>630            'ptgLE'             =&gt; 0x0A,
</span><span class="inferred1"><a name="line631"></a>631            'ptgEQ'             =&gt; 0x0B,
</span><span class="inferred0"><a name="line632"></a>632            'ptgGE'             =&gt; 0x0C,
</span><span class="inferred1"><a name="line633"></a>633            'ptgGT'             =&gt; 0x0D,
</span><span class="inferred0"><a name="line634"></a>634            'ptgNE'             =&gt; 0x0E,
</span><span class="inferred1"><a name="line635"></a>635            'ptgIsect'          =&gt; 0x0F,
</span><span class="inferred0"><a name="line636"></a>636            'ptgUnion'          =&gt; 0x10,
</span><span class="inferred1"><a name="line637"></a>637            'ptgRange'          =&gt; 0x11,
</span><span class="inferred0"><a name="line638"></a>638            'ptgUplus'          =&gt; 0x12,
</span><span class="inferred1"><a name="line639"></a>639            'ptgUminus'         =&gt; 0x13,
</span><span class="inferred0"><a name="line640"></a>640            'ptgPercent'        =&gt; 0x14,
</span><span class="inferred1"><a name="line641"></a>641            'ptgParen'          =&gt; 0x15,
</span><span class="inferred0"><a name="line642"></a>642            'ptgMissArg'        =&gt; 0x16,
</span><span class="inferred1"><a name="line643"></a>643            'ptgStr'            =&gt; 0x17,
</span><span class="inferred0"><a name="line644"></a>644            'ptgAttr'           =&gt; 0x19,
</span><span class="inferred1"><a name="line645"></a>645            'ptgSheet'          =&gt; 0x1A,
</span><span class="inferred0"><a name="line646"></a>646            'ptgEndSheet'       =&gt; 0x1B,
</span><span class="inferred1"><a name="line647"></a>647            'ptgErr'            =&gt; 0x1C,
</span><span class="inferred0"><a name="line648"></a>648            'ptgBool'           =&gt; 0x1D,
</span><span class="inferred1"><a name="line649"></a>649            'ptgInt'            =&gt; 0x1E,
</span><span class="inferred0"><a name="line650"></a>650            'ptgNum'            =&gt; 0x1F,
</span><span class="inferred1"><a name="line651"></a>651            'ptgArray'          =&gt; 0x20,
</span><span class="inferred0"><a name="line652"></a>652            'ptgFunc'           =&gt; 0x21,
</span><span class="inferred1"><a name="line653"></a>653            'ptgFuncVar'        =&gt; 0x22,
</span><span class="inferred0"><a name="line654"></a>654            'ptgName'           =&gt; 0x23,
</span><span class="inferred1"><a name="line655"></a>655            'ptgRef'            =&gt; 0x24,
</span><span class="inferred0"><a name="line656"></a>656            'ptgArea'           =&gt; 0x25,
</span><span class="inferred1"><a name="line657"></a>657            'ptgMemArea'        =&gt; 0x26,
</span><span class="inferred0"><a name="line658"></a>658            'ptgMemErr'         =&gt; 0x27,
</span><span class="inferred1"><a name="line659"></a>659            'ptgMemNoMem'       =&gt; 0x28,
</span><span class="inferred0"><a name="line660"></a>660            'ptgMemFunc'        =&gt; 0x29,
</span><span class="inferred1"><a name="line661"></a>661            'ptgRefErr'         =&gt; 0x2A,
</span><span class="inferred0"><a name="line662"></a>662            'ptgAreaErr'        =&gt; 0x2B,
</span><span class="inferred1"><a name="line663"></a>663            'ptgRefN'           =&gt; 0x2C,
</span><span class="inferred0"><a name="line664"></a>664            'ptgAreaN'          =&gt; 0x2D,
</span><span class="inferred1"><a name="line665"></a>665            'ptgMemAreaN'       =&gt; 0x2E,
</span><span class="inferred0"><a name="line666"></a>666            'ptgMemNoMemN'      =&gt; 0x2F,
</span><span class="inferred1"><a name="line667"></a>667            'ptgNameX'          =&gt; 0x39,
</span><span class="inferred0"><a name="line668"></a>668            'ptgRef3d'          =&gt; 0x3A,
</span><span class="inferred1"><a name="line669"></a>669            'ptgArea3d'         =&gt; 0x3B,
</span><span class="inferred0"><a name="line670"></a>670            'ptgRefErr3d'       =&gt; 0x3C,
</span><span class="inferred1"><a name="line671"></a>671            'ptgAreaErr3d'      =&gt; 0x3D,
</span><span class="inferred0"><a name="line672"></a>672            'ptgArrayV'         =&gt; 0x40,
</span><span class="inferred1"><a name="line673"></a>673            'ptgFuncV'          =&gt; 0x41,
</span><span class="inferred0"><a name="line674"></a>674            'ptgFuncVarV'       =&gt; 0x42,
</span><span class="inferred1"><a name="line675"></a>675            'ptgNameV'          =&gt; 0x43,
</span><span class="inferred0"><a name="line676"></a>676            'ptgRefV'           =&gt; 0x44,
</span><span class="inferred1"><a name="line677"></a>677            'ptgAreaV'          =&gt; 0x45,
</span><span class="inferred0"><a name="line678"></a>678            'ptgMemAreaV'       =&gt; 0x46,
</span><span class="inferred1"><a name="line679"></a>679            'ptgMemErrV'        =&gt; 0x47,
</span><span class="inferred0"><a name="line680"></a>680            'ptgMemNoMemV'      =&gt; 0x48,
</span><span class="inferred1"><a name="line681"></a>681            'ptgMemFuncV'       =&gt; 0x49,
</span><span class="inferred0"><a name="line682"></a>682            'ptgRefErrV'        =&gt; 0x4A,
</span><span class="inferred1"><a name="line683"></a>683            'ptgAreaErrV'       =&gt; 0x4B,
</span><span class="inferred0"><a name="line684"></a>684            'ptgRefNV'          =&gt; 0x4C,
</span><span class="inferred1"><a name="line685"></a>685            'ptgAreaNV'         =&gt; 0x4D,
</span><span class="inferred0"><a name="line686"></a>686            'ptgMemAreaNV'      =&gt; 0x4E,
</span><span class="inferred1"><a name="line687"></a>687            'ptgMemNoMemN'      =&gt; 0x4F,
</span><span class="inferred0"><a name="line688"></a>688            'ptgFuncCEV'        =&gt; 0x58,
</span><span class="inferred1"><a name="line689"></a>689            'ptgNameXV'         =&gt; 0x59,
</span><span class="inferred0"><a name="line690"></a>690            'ptgRef3dV'         =&gt; 0x5A,
</span><span class="inferred1"><a name="line691"></a>691            'ptgArea3dV'        =&gt; 0x5B,
</span><span class="inferred0"><a name="line692"></a>692            'ptgRefErr3dV'      =&gt; 0x5C,
</span><span class="inferred1"><a name="line693"></a>693            'ptgAreaErr3d'      =&gt; 0x5D,
</span><span class="inferred0"><a name="line694"></a>694            'ptgArrayA'         =&gt; 0x60,
</span><span class="inferred1"><a name="line695"></a>695            'ptgFuncA'          =&gt; 0x61,
</span><span class="inferred0"><a name="line696"></a>696            'ptgFuncVarA'       =&gt; 0x62,
</span><span class="inferred1"><a name="line697"></a>697            'ptgNameA'          =&gt; 0x63,
</span><span class="inferred0"><a name="line698"></a>698            'ptgRefA'           =&gt; 0x64,
</span><span class="inferred1"><a name="line699"></a>699            'ptgAreaA'          =&gt; 0x65,
</span><span class="inferred0"><a name="line700"></a>700            'ptgMemAreaA'       =&gt; 0x66,
</span><span class="inferred1"><a name="line701"></a>701            'ptgMemErrA'        =&gt; 0x67,
</span><span class="inferred0"><a name="line702"></a>702            'ptgMemNoMemA'      =&gt; 0x68,
</span><span class="inferred1"><a name="line703"></a>703            'ptgMemFuncA'       =&gt; 0x69,
</span><span class="inferred0"><a name="line704"></a>704            'ptgRefErrA'        =&gt; 0x6A,
</span><span class="inferred1"><a name="line705"></a>705            'ptgAreaErrA'       =&gt; 0x6B,
</span><span class="inferred0"><a name="line706"></a>706            'ptgRefNA'          =&gt; 0x6C,
</span><span class="inferred1"><a name="line707"></a>707            'ptgAreaNA'         =&gt; 0x6D,
</span><span class="inferred0"><a name="line708"></a>708            'ptgMemAreaNA'      =&gt; 0x6E,
</span><span class="inferred1"><a name="line709"></a>709            'ptgMemNoMemN'      =&gt; 0x6F,
</span><span class="inferred0"><a name="line710"></a>710            'ptgFuncCEA'        =&gt; 0x78,
</span><span class="inferred1"><a name="line711"></a>711            'ptgNameXA'         =&gt; 0x79,
</span><span class="inferred0"><a name="line712"></a>712            'ptgRef3dA'         =&gt; 0x7A,
</span><span class="inferred1"><a name="line713"></a>713            'ptgArea3dA'        =&gt; 0x7B,
</span><span class="inferred0"><a name="line714"></a>714            'ptgRefErr3dA'      =&gt; 0x7C,
</span><span class="inferred1"><a name="line715"></a>715            'ptgAreaErr3d'      =&gt; 0x7D
</span><span class="inferred0"><a name="line716"></a>716        };
</span><span class="inferred1"><a name="line717"></a>717    
</span><span class="inferred0"><a name="line718"></a>718        # Thanks to Michael Meeks and Gnumeric for the initial arg values.
</span><span class="inferred1"><a name="line719"></a>719        #
</span><span class="inferred0"><a name="line720"></a>720        # The following hash was generated by &quot;function_locale.pl&quot; in the distro.
</span><span class="inferred1"><a name="line721"></a>721        # Refer to function_locale.pl for non-English function names.
</span><span class="inferred0"><a name="line722"></a>722        #
</span><span class="inferred1"><a name="line723"></a>723        # The array elements are as follow:
</span><span class="inferred0"><a name="line724"></a>724        # ptg:   The Excel function ptg code.
</span><span class="inferred1"><a name="line725"></a>725        # args:  The number of arguments that the function takes:
</span><span class="inferred0"><a name="line726"></a>726        #           &gt;=0 is a fixed number of arguments.
</span><span class="inferred1"><a name="line727"></a>727        #           -1  is a variable  number of arguments.
</span><span class="inferred0"><a name="line728"></a>728        # class: The reference, value or array class of the function args.
</span><span class="inferred1"><a name="line729"></a>729        # vol:   The function is volatile.
</span><span class="inferred0"><a name="line730"></a>730        #
</span><span class="marked1"><a name="line731"></a>731        @functions  = {
</span><span class="inferred0"><a name="line732"></a>732            #                                     ptg  args  class  vol
</span><span class="inferred1"><a name="line733"></a>733            'COUNT'                         =&gt; [   0,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line734"></a>734            'IF'                            =&gt; [   1,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line735"></a>735            'ISNA'                          =&gt; [   2,    1,    1,    0 ],
</span><span class="inferred0"><a name="line736"></a>736            'ISERROR'                       =&gt; [   3,    1,    1,    0 ],
</span><span class="inferred1"><a name="line737"></a>737            'SUM'                           =&gt; [   4,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line738"></a>738            'AVERAGE'                       =&gt; [   5,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line739"></a>739            'MIN'                           =&gt; [   6,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line740"></a>740            'MAX'                           =&gt; [   7,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line741"></a>741            'ROW'                           =&gt; [   8,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line742"></a>742            'COLUMN'                        =&gt; [   9,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line743"></a>743            'NA'                            =&gt; [  10,    0,    0,    0 ],
</span><span class="inferred0"><a name="line744"></a>744            'NPV'                           =&gt; [  11,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line745"></a>745            'STDEV'                         =&gt; [  12,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line746"></a>746            'DOLLAR'                        =&gt; [  13,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line747"></a>747            'FIXED'                         =&gt; [  14,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line748"></a>748            'SIN'                           =&gt; [  15,    1,    1,    0 ],
</span><span class="inferred1"><a name="line749"></a>749            'COS'                           =&gt; [  16,    1,    1,    0 ],
</span><span class="inferred0"><a name="line750"></a>750            'TAN'                           =&gt; [  17,    1,    1,    0 ],
</span><span class="inferred1"><a name="line751"></a>751            'ATAN'                          =&gt; [  18,    1,    1,    0 ],
</span><span class="inferred0"><a name="line752"></a>752            'PI'                            =&gt; [  19,    0,    1,    0 ],
</span><span class="inferred1"><a name="line753"></a>753            'SQRT'                          =&gt; [  20,    1,    1,    0 ],
</span><span class="inferred0"><a name="line754"></a>754            'EXP'                           =&gt; [  21,    1,    1,    0 ],
</span><span class="inferred1"><a name="line755"></a>755            'LN'                            =&gt; [  22,    1,    1,    0 ],
</span><span class="inferred0"><a name="line756"></a>756            'LOG10'                         =&gt; [  23,    1,    1,    0 ],
</span><span class="inferred1"><a name="line757"></a>757            'ABS'                           =&gt; [  24,    1,    1,    0 ],
</span><span class="inferred0"><a name="line758"></a>758            'INT'                           =&gt; [  25,    1,    1,    0 ],
</span><span class="inferred1"><a name="line759"></a>759            'SIGN'                          =&gt; [  26,    1,    1,    0 ],
</span><span class="inferred0"><a name="line760"></a>760            'ROUND'                         =&gt; [  27,    2,    1,    0 ],
</span><span class="inferred1"><a name="line761"></a>761            'LOOKUP'                        =&gt; [  28,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line762"></a>762            'INDEX'                         =&gt; [  29,   -1,    0,    1 ],
</span><span class="inferred1"><a name="line763"></a>763            'REPT'                          =&gt; [  30,    2,    1,    0 ],
</span><span class="inferred0"><a name="line764"></a>764            'MID'                           =&gt; [  31,    3,    1,    0 ],
</span><span class="inferred1"><a name="line765"></a>765            'LEN'                           =&gt; [  32,    1,    1,    0 ],
</span><span class="inferred0"><a name="line766"></a>766            'VALUE'                         =&gt; [  33,    1,    1,    0 ],
</span><span class="inferred1"><a name="line767"></a>767            'TRUE'                          =&gt; [  34,    0,    1,    0 ],
</span><span class="inferred0"><a name="line768"></a>768            'FALSE'                         =&gt; [  35,    0,    1,    0 ],
</span><span class="inferred1"><a name="line769"></a>769            'AND'                           =&gt; [  36,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line770"></a>770            'OR'                            =&gt; [  37,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line771"></a>771            'NOT'                           =&gt; [  38,    1,    1,    0 ],
</span><span class="inferred0"><a name="line772"></a>772            'MOD'                           =&gt; [  39,    2,    1,    0 ],
</span><span class="inferred1"><a name="line773"></a>773            'DCOUNT'                        =&gt; [  40,    3,    0,    0 ],
</span><span class="inferred0"><a name="line774"></a>774            'DSUM'                          =&gt; [  41,    3,    0,    0 ],
</span><span class="inferred1"><a name="line775"></a>775            'DAVERAGE'                      =&gt; [  42,    3,    0,    0 ],
</span><span class="inferred0"><a name="line776"></a>776            'DMIN'                          =&gt; [  43,    3,    0,    0 ],
</span><span class="inferred1"><a name="line777"></a>777            'DMAX'                          =&gt; [  44,    3,    0,    0 ],
</span><span class="inferred0"><a name="line778"></a>778            'DSTDEV'                        =&gt; [  45,    3,    0,    0 ],
</span><span class="inferred1"><a name="line779"></a>779            'VAR'                           =&gt; [  46,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line780"></a>780            'DVAR'                          =&gt; [  47,    3,    0,    0 ],
</span><span class="inferred1"><a name="line781"></a>781            'TEXT'                          =&gt; [  48,    2,    1,    0 ],
</span><span class="inferred0"><a name="line782"></a>782            'LINEST'                        =&gt; [  49,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line783"></a>783            'TREND'                         =&gt; [  50,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line784"></a>784            'LOGEST'                        =&gt; [  51,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line785"></a>785            'GROWTH'                        =&gt; [  52,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line786"></a>786            'PV'                            =&gt; [  56,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line787"></a>787            'FV'                            =&gt; [  57,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line788"></a>788            'NPER'                          =&gt; [  58,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line789"></a>789            'PMT'                           =&gt; [  59,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line790"></a>790            'RATE'                          =&gt; [  60,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line791"></a>791            'MIRR'                          =&gt; [  61,    3,    0,    0 ],
</span><span class="inferred0"><a name="line792"></a>792            'IRR'                           =&gt; [  62,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line793"></a>793            'RAND'                          =&gt; [  63,    0,    1,    1 ],
</span><span class="inferred0"><a name="line794"></a>794            'MATCH'                         =&gt; [  64,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line795"></a>795            'DATE'                          =&gt; [  65,    3,    1,    0 ],
</span><span class="inferred0"><a name="line796"></a>796            'TIME'                          =&gt; [  66,    3,    1,    0 ],
</span><span class="inferred1"><a name="line797"></a>797            'DAY'                           =&gt; [  67,    1,    1,    0 ],
</span><span class="inferred0"><a name="line798"></a>798            'MONTH'                         =&gt; [  68,    1,    1,    0 ],
</span><span class="inferred1"><a name="line799"></a>799            'YEAR'                          =&gt; [  69,    1,    1,    0 ],
</span><span class="inferred0"><a name="line800"></a>800            'WEEKDAY'                       =&gt; [  70,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line801"></a>801            'HOUR'                          =&gt; [  71,    1,    1,    0 ],
</span><span class="inferred0"><a name="line802"></a>802            'MINUTE'                        =&gt; [  72,    1,    1,    0 ],
</span><span class="inferred1"><a name="line803"></a>803            'SECOND'                        =&gt; [  73,    1,    1,    0 ],
</span><span class="inferred0"><a name="line804"></a>804            'NOW'                           =&gt; [  74,    0,    1,    1 ],
</span><span class="inferred1"><a name="line805"></a>805            'AREAS'                         =&gt; [  75,    1,    0,    1 ],
</span><span class="inferred0"><a name="line806"></a>806            'ROWS'                          =&gt; [  76,    1,    0,    1 ],
</span><span class="inferred1"><a name="line807"></a>807            'COLUMNS'                       =&gt; [  77,    1,    0,    1 ],
</span><span class="inferred0"><a name="line808"></a>808            'OFFSET'                        =&gt; [  78,   -1,    0,    1 ],
</span><span class="inferred1"><a name="line809"></a>809            'SEARCH'                        =&gt; [  82,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line810"></a>810            'TRANSPOSE'                     =&gt; [  83,    1,    1,    0 ],
</span><span class="inferred1"><a name="line811"></a>811            'TYPE'                          =&gt; [  86,    1,    1,    0 ],
</span><span class="inferred0"><a name="line812"></a>812            'ATAN2'                         =&gt; [  97,    2,    1,    0 ],
</span><span class="inferred1"><a name="line813"></a>813            'ASIN'                          =&gt; [  98,    1,    1,    0 ],
</span><span class="inferred0"><a name="line814"></a>814            'ACOS'                          =&gt; [  99,    1,    1,    0 ],
</span><span class="inferred1"><a name="line815"></a>815            'CHOOSE'                        =&gt; [ 100,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line816"></a>816            'HLOOKUP'                       =&gt; [ 101,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line817"></a>817            'VLOOKUP'                       =&gt; [ 102,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line818"></a>818            'ISREF'                         =&gt; [ 105,    1,    0,    0 ],
</span><span class="inferred1"><a name="line819"></a>819            'LOG'                           =&gt; [ 109,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line820"></a>820            'CHAR'                          =&gt; [ 111,    1,    1,    0 ],
</span><span class="inferred1"><a name="line821"></a>821            'LOWER'                         =&gt; [ 112,    1,    1,    0 ],
</span><span class="inferred0"><a name="line822"></a>822            'UPPER'                         =&gt; [ 113,    1,    1,    0 ],
</span><span class="inferred1"><a name="line823"></a>823            'PROPER'                        =&gt; [ 114,    1,    1,    0 ],
</span><span class="inferred0"><a name="line824"></a>824            'LEFT'                          =&gt; [ 115,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line825"></a>825            'RIGHT'                         =&gt; [ 116,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line826"></a>826            'EXACT'                         =&gt; [ 117,    2,    1,    0 ],
</span><span class="inferred1"><a name="line827"></a>827            'TRIM'                          =&gt; [ 118,    1,    1,    0 ],
</span><span class="inferred0"><a name="line828"></a>828            'REPLACE'                       =&gt; [ 119,    4,    1,    0 ],
</span><span class="inferred1"><a name="line829"></a>829            'SUBSTITUTE'                    =&gt; [ 120,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line830"></a>830            'CODE'                          =&gt; [ 121,    1,    1,    0 ],
</span><span class="inferred1"><a name="line831"></a>831            'FIND'                          =&gt; [ 124,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line832"></a>832            'CELL'                          =&gt; [ 125,   -1,    0,    1 ],
</span><span class="inferred1"><a name="line833"></a>833            'ISERR'                         =&gt; [ 126,    1,    1,    0 ],
</span><span class="inferred0"><a name="line834"></a>834            'ISTEXT'                        =&gt; [ 127,    1,    1,    0 ],
</span><span class="inferred1"><a name="line835"></a>835            'ISNUMBER'                      =&gt; [ 128,    1,    1,    0 ],
</span><span class="inferred0"><a name="line836"></a>836            'ISBLANK'                       =&gt; [ 129,    1,    1,    0 ],
</span><span class="inferred1"><a name="line837"></a>837            'T'                             =&gt; [ 130,    1,    0,    0 ],
</span><span class="inferred0"><a name="line838"></a>838            'N'                             =&gt; [ 131,    1,    0,    0 ],
</span><span class="inferred1"><a name="line839"></a>839            'DATEVALUE'                     =&gt; [ 140,    1,    1,    0 ],
</span><span class="inferred0"><a name="line840"></a>840            'TIMEVALUE'                     =&gt; [ 141,    1,    1,    0 ],
</span><span class="inferred1"><a name="line841"></a>841            'SLN'                           =&gt; [ 142,    3,    1,    0 ],
</span><span class="inferred0"><a name="line842"></a>842            'SYD'                           =&gt; [ 143,    4,    1,    0 ],
</span><span class="inferred1"><a name="line843"></a>843            'DDB'                           =&gt; [ 144,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line844"></a>844            'INDIRECT'                      =&gt; [ 148,   -1,    1,    1 ],
</span><span class="inferred1"><a name="line845"></a>845            'CALL'                          =&gt; [ 150,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line846"></a>846            'CLEAN'                         =&gt; [ 162,    1,    1,    0 ],
</span><span class="inferred1"><a name="line847"></a>847            'MDETERM'                       =&gt; [ 163,    1,    2,    0 ],
</span><span class="inferred0"><a name="line848"></a>848            'MINVERSE'                      =&gt; [ 164,    1,    2,    0 ],
</span><span class="inferred1"><a name="line849"></a>849            'MMULT'                         =&gt; [ 165,    2,    2,    0 ],
</span><span class="inferred0"><a name="line850"></a>850            'IPMT'                          =&gt; [ 167,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line851"></a>851            'PPMT'                          =&gt; [ 168,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line852"></a>852            'COUNTA'                        =&gt; [ 169,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line853"></a>853            'PRODUCT'                       =&gt; [ 183,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line854"></a>854            'FACT'                          =&gt; [ 184,    1,    1,    0 ],
</span><span class="inferred1"><a name="line855"></a>855            'DPRODUCT'                      =&gt; [ 189,    3,    0,    0 ],
</span><span class="inferred0"><a name="line856"></a>856            'ISNONTEXT'                     =&gt; [ 190,    1,    1,    0 ],
</span><span class="inferred1"><a name="line857"></a>857            'STDEVP'                        =&gt; [ 193,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line858"></a>858            'VARP'                          =&gt; [ 194,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line859"></a>859            'DSTDEVP'                       =&gt; [ 195,    3,    0,    0 ],
</span><span class="inferred0"><a name="line860"></a>860            'DVARP'                         =&gt; [ 196,    3,    0,    0 ],
</span><span class="inferred1"><a name="line861"></a>861            'TRUNC'                         =&gt; [ 197,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line862"></a>862            'ISLOGICAL'                     =&gt; [ 198,    1,    1,    0 ],
</span><span class="inferred1"><a name="line863"></a>863            'DCOUNTA'                       =&gt; [ 199,    3,    0,    0 ],
</span><span class="inferred0"><a name="line864"></a>864            'ROUNDUP'                       =&gt; [ 212,    2,    1,    0 ],
</span><span class="inferred1"><a name="line865"></a>865            'ROUNDDOWN'                     =&gt; [ 213,    2,    1,    0 ],
</span><span class="inferred0"><a name="line866"></a>866            'RANK'                          =&gt; [ 216,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line867"></a>867            'ADDRESS'                       =&gt; [ 219,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line868"></a>868            'DAYS360'                       =&gt; [ 220,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line869"></a>869            'TODAY'                         =&gt; [ 221,    0,    1,    1 ],
</span><span class="inferred0"><a name="line870"></a>870            'VDB'                           =&gt; [ 222,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line871"></a>871            'MEDIAN'                        =&gt; [ 227,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line872"></a>872            'SUMPRODUCT'                    =&gt; [ 228,   -1,    2,    0 ],
</span><span class="inferred1"><a name="line873"></a>873            'SINH'                          =&gt; [ 229,    1,    1,    0 ],
</span><span class="inferred0"><a name="line874"></a>874            'COSH'                          =&gt; [ 230,    1,    1,    0 ],
</span><span class="inferred1"><a name="line875"></a>875            'TANH'                          =&gt; [ 231,    1,    1,    0 ],
</span><span class="inferred0"><a name="line876"></a>876            'ASINH'                         =&gt; [ 232,    1,    1,    0 ],
</span><span class="inferred1"><a name="line877"></a>877            'ACOSH'                         =&gt; [ 233,    1,    1,    0 ],
</span><span class="inferred0"><a name="line878"></a>878            'ATANH'                         =&gt; [ 234,    1,    1,    0 ],
</span><span class="inferred1"><a name="line879"></a>879            'DGET'                          =&gt; [ 235,    3,    0,    0 ],
</span><span class="inferred0"><a name="line880"></a>880            'INFO'                          =&gt; [ 244,    1,    1,    1 ],
</span><span class="inferred1"><a name="line881"></a>881            'DB'                            =&gt; [ 247,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line882"></a>882            'FREQUENCY'                     =&gt; [ 252,    2,    0,    0 ],
</span><span class="inferred1"><a name="line883"></a>883            'ERROR.TYPE'                    =&gt; [ 261,    1,    1,    0 ],
</span><span class="inferred0"><a name="line884"></a>884            'REGISTER.ID'                   =&gt; [ 267,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line885"></a>885            'AVEDEV'                        =&gt; [ 269,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line886"></a>886            'BETADIST'                      =&gt; [ 270,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line887"></a>887            'GAMMALN'                       =&gt; [ 271,    1,    1,    0 ],
</span><span class="inferred0"><a name="line888"></a>888            'BETAINV'                       =&gt; [ 272,   -1,    1,    0 ],
</span><span class="inferred1"><a name="line889"></a>889            'BINOMDIST'                     =&gt; [ 273,    4,    1,    0 ],
</span><span class="inferred0"><a name="line890"></a>890            'CHIDIST'                       =&gt; [ 274,    2,    1,    0 ],
</span><span class="inferred1"><a name="line891"></a>891            'CHIINV'                        =&gt; [ 275,    2,    1,    0 ],
</span><span class="inferred0"><a name="line892"></a>892            'COMBIN'                        =&gt; [ 276,    2,    1,    0 ],
</span><span class="inferred1"><a name="line893"></a>893            'CONFIDENCE'                    =&gt; [ 277,    3,    1,    0 ],
</span><span class="inferred0"><a name="line894"></a>894            'CRITBINOM'                     =&gt; [ 278,    3,    1,    0 ],
</span><span class="inferred1"><a name="line895"></a>895            'EVEN'                          =&gt; [ 279,    1,    1,    0 ],
</span><span class="inferred0"><a name="line896"></a>896            'EXPONDIST'                     =&gt; [ 280,    3,    1,    0 ],
</span><span class="inferred1"><a name="line897"></a>897            'FDIST'                         =&gt; [ 281,    3,    1,    0 ],
</span><span class="inferred0"><a name="line898"></a>898            'FINV'                          =&gt; [ 282,    3,    1,    0 ],
</span><span class="inferred1"><a name="line899"></a>899            'FISHER'                        =&gt; [ 283,    1,    1,    0 ],
</span><span class="inferred0"><a name="line900"></a>900            'FISHERINV'                     =&gt; [ 284,    1,    1,    0 ],
</span><span class="inferred1"><a name="line901"></a>901            'FLOOR'                         =&gt; [ 285,    2,    1,    0 ],
</span><span class="inferred0"><a name="line902"></a>902            'GAMMADIST'                     =&gt; [ 286,    4,    1,    0 ],
</span><span class="inferred1"><a name="line903"></a>903            'GAMMAINV'                      =&gt; [ 287,    3,    1,    0 ],
</span><span class="inferred0"><a name="line904"></a>904            'CEILING'                       =&gt; [ 288,    2,    1,    0 ],
</span><span class="inferred1"><a name="line905"></a>905            'HYPGEOMDIST'                   =&gt; [ 289,    4,    1,    0 ],
</span><span class="inferred0"><a name="line906"></a>906            'LOGNORMDIST'                   =&gt; [ 290,    3,    1,    0 ],
</span><span class="inferred1"><a name="line907"></a>907            'LOGINV'                        =&gt; [ 291,    3,    1,    0 ],
</span><span class="inferred0"><a name="line908"></a>908            'NEGBINOMDIST'                  =&gt; [ 292,    3,    1,    0 ],
</span><span class="inferred1"><a name="line909"></a>909            'NORMDIST'                      =&gt; [ 293,    4,    1,    0 ],
</span><span class="inferred0"><a name="line910"></a>910            'NORMSDIST'                     =&gt; [ 294,    1,    1,    0 ],
</span><span class="inferred1"><a name="line911"></a>911            'NORMINV'                       =&gt; [ 295,    3,    1,    0 ],
</span><span class="inferred0"><a name="line912"></a>912            'NORMSINV'                      =&gt; [ 296,    1,    1,    0 ],
</span><span class="inferred1"><a name="line913"></a>913            'STANDARDIZE'                   =&gt; [ 297,    3,    1,    0 ],
</span><span class="inferred0"><a name="line914"></a>914            'ODD'                           =&gt; [ 298,    1,    1,    0 ],
</span><span class="inferred1"><a name="line915"></a>915            'PERMUT'                        =&gt; [ 299,    2,    1,    0 ],
</span><span class="inferred0"><a name="line916"></a>916            'POISSON'                       =&gt; [ 300,    3,    1,    0 ],
</span><span class="inferred1"><a name="line917"></a>917            'TDIST'                         =&gt; [ 301,    3,    1,    0 ],
</span><span class="inferred0"><a name="line918"></a>918            'WEIBULL'                       =&gt; [ 302,    4,    1,    0 ],
</span><span class="inferred1"><a name="line919"></a>919            'SUMXMY2'                       =&gt; [ 303,    2,    2,    0 ],
</span><span class="inferred0"><a name="line920"></a>920            'SUMX2MY2'                      =&gt; [ 304,    2,    2,    0 ],
</span><span class="inferred1"><a name="line921"></a>921            'SUMX2PY2'                      =&gt; [ 305,    2,    2,    0 ],
</span><span class="inferred0"><a name="line922"></a>922            'CHITEST'                       =&gt; [ 306,    2,    2,    0 ],
</span><span class="inferred1"><a name="line923"></a>923            'CORREL'                        =&gt; [ 307,    2,    2,    0 ],
</span><span class="inferred0"><a name="line924"></a>924            'COVAR'                         =&gt; [ 308,    2,    2,    0 ],
</span><span class="inferred1"><a name="line925"></a>925            'FORECAST'                      =&gt; [ 309,    3,    2,    0 ],
</span><span class="inferred0"><a name="line926"></a>926            'FTEST'                         =&gt; [ 310,    2,    2,    0 ],
</span><span class="inferred1"><a name="line927"></a>927            'INTERCEPT'                     =&gt; [ 311,    2,    2,    0 ],
</span><span class="inferred0"><a name="line928"></a>928            'PEARSON'                       =&gt; [ 312,    2,    2,    0 ],
</span><span class="inferred1"><a name="line929"></a>929            'RSQ'                           =&gt; [ 313,    2,    2,    0 ],
</span><span class="inferred0"><a name="line930"></a>930            'STEYX'                         =&gt; [ 314,    2,    2,    0 ],
</span><span class="inferred1"><a name="line931"></a>931            'SLOPE'                         =&gt; [ 315,    2,    2,    0 ],
</span><span class="inferred0"><a name="line932"></a>932            'TTEST'                         =&gt; [ 316,    4,    2,    0 ],
</span><span class="inferred1"><a name="line933"></a>933            'PROB'                          =&gt; [ 317,   -1,    2,    0 ],
</span><span class="inferred0"><a name="line934"></a>934            'DEVSQ'                         =&gt; [ 318,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line935"></a>935            'GEOMEAN'                       =&gt; [ 319,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line936"></a>936            'HARMEAN'                       =&gt; [ 320,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line937"></a>937            'SUMSQ'                         =&gt; [ 321,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line938"></a>938            'KURT'                          =&gt; [ 322,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line939"></a>939            'SKEW'                          =&gt; [ 323,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line940"></a>940            'ZTEST'                         =&gt; [ 324,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line941"></a>941            'LARGE'                         =&gt; [ 325,    2,    0,    0 ],
</span><span class="inferred0"><a name="line942"></a>942            'SMALL'                         =&gt; [ 326,    2,    0,    0 ],
</span><span class="inferred1"><a name="line943"></a>943            'QUARTILE'                      =&gt; [ 327,    2,    0,    0 ],
</span><span class="inferred0"><a name="line944"></a>944            'PERCENTILE'                    =&gt; [ 328,    2,    0,    0 ],
</span><span class="inferred1"><a name="line945"></a>945            'PERCENTRANK'                   =&gt; [ 329,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line946"></a>946            'MODE'                          =&gt; [ 330,   -1,    2,    0 ],
</span><span class="inferred1"><a name="line947"></a>947            'TRIMMEAN'                      =&gt; [ 331,    2,    0,    0 ],
</span><span class="inferred0"><a name="line948"></a>948            'TINV'                          =&gt; [ 332,    2,    1,    0 ],
</span><span class="inferred1"><a name="line949"></a>949            'CONCATENATE'                   =&gt; [ 336,   -1,    1,    0 ],
</span><span class="inferred0"><a name="line950"></a>950            'POWER'                         =&gt; [ 337,    2,    1,    0 ],
</span><span class="inferred1"><a name="line951"></a>951            'RADIANS'                       =&gt; [ 342,    1,    1,    0 ],
</span><span class="inferred0"><a name="line952"></a>952            'DEGREES'                       =&gt; [ 343,    1,    1,    0 ],
</span><span class="inferred1"><a name="line953"></a>953            'SUBTOTAL'                      =&gt; [ 344,   -1,    0,    0 ],
</span><span class="inferred0"><a name="line954"></a>954            'SUMIF'                         =&gt; [ 345,   -1,    0,    0 ],
</span><span class="inferred1"><a name="line955"></a>955            'COUNTIF'                       =&gt; [ 346,    2,    0,    0 ],
</span><span class="inferred0"><a name="line956"></a>956            'COUNTBLANK'                    =&gt; [ 347,    1,    0,    0 ],
</span><span class="inferred1"><a name="line957"></a>957            'ROMAN'                         =&gt; [ 354,   -1,    1,    0 ]
</span><span class="inferred0"><a name="line958"></a>958       }
</span><span class="inferred1"><a name="line959"></a>959    
</span><span class="inferred0"><a name="line960"></a>960    end
</span><span class="inferred1"><a name="line961"></a>961 
</span><span class="inferred0"><a name="line962"></a>962 
</span><span class="inferred1"><a name="line963"></a>963 end
</span><span class="inferred0"><a name="line964"></a>964 
</span><span class="marked1"><a name="line965"></a>965 if $0 ==__FILE__
</span><span class="uncovered0"><a name="line966"></a>966 
</span><span class="uncovered1"><a name="line967"></a>967 
</span><span class="uncovered0"><a name="line968"></a>968 parser = Formula.new
</span><span class="uncovered1"><a name="line969"></a>969 puts
</span><span class="uncovered0"><a name="line970"></a>970 puts 'type &quot;Q&quot; to quit.'
</span><span class="uncovered1"><a name="line971"></a>971 puts
</span><span class="uncovered0"><a name="line972"></a>972 while true
</span><span class="uncovered1"><a name="line973"></a>973   puts
</span><span class="uncovered0"><a name="line974"></a>974   print '? '
</span><span class="uncovered1"><a name="line975"></a>975   str = gets.chop!
</span><span class="uncovered0"><a name="line976"></a>976   break if /q/i =~ str
</span><span class="uncovered1"><a name="line977"></a>977   begin
</span><span class="uncovered0"><a name="line978"></a>978     e = parser.parse(str)
</span><span class="uncovered1"><a name="line979"></a>979     p   parser.reverse(e)
</span><span class="uncovered0"><a name="line980"></a>980   rescue ParseError
</span><span class="uncovered1"><a name="line981"></a>981     puts $!
</span><span class="uncovered0"><a name="line982"></a>982   end
</span><span class="uncovered1"><a name="line983"></a>983 end
</span><span class="uncovered0"><a name="line984"></a>984 
</span><span class="uncovered1"><a name="line985"></a>985 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
