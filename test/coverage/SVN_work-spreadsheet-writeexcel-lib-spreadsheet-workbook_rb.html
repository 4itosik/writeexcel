<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>C:/SVN_work/spreadsheet-writeexcel/lib/spreadsheet/workbook.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Fri Mar 06 00:10:44 +0900 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='SVN_work-spreadsheet-writeexcel-lib-spreadsheet-workbook_rb.html'>C:/SVN_work/spreadsheet-writeexcel/lib/spreadsheet/workbook.rb</a>
        </td>
      <td class='lines_total'><tt>2709</tt>
        </td>
      <td class='lines_code'><tt>1380</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>34.1%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='34'/>
                  <td class='uncovered' width='66'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>20.3%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='20'/>
                  <td class='uncovered' width='80'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked0"><a name="line1"></a>   1 require 'digest/md5'
</span><span class="marked1"><a name="line2"></a>   2 require 'biffwriter'
</span><span class="marked0"><a name="line3"></a>   3 require 'formula'
</span><span class="inferred1"><a name="line4"></a>   4 
</span><span class="marked0"><a name="line5"></a>   5 class Workbook &lt; BIFFWriter
</span><span class="marked1"><a name="line6"></a>   6    BOF = 11
</span><span class="marked0"><a name="line7"></a>   7    EOF = 4
</span><span class="marked1"><a name="line8"></a>   8    SheetName = &quot;Sheet&quot;
</span><span class="inferred0"><a name="line9"></a>   9 
</span><span class="marked1"><a name="line10"></a>  10    attr_accessor :date_system
</span><span class="marked0"><a name="line11"></a>  11    attr_reader :formats, :xf_index, :worksheets
</span><span class="inferred1"><a name="line12"></a>  12 
</span><span class="inferred0"><a name="line13"></a>  13    ###############################################################################
</span><span class="inferred1"><a name="line14"></a>  14    #
</span><span class="inferred0"><a name="line15"></a>  15    # new()
</span><span class="inferred1"><a name="line16"></a>  16    #
</span><span class="inferred0"><a name="line17"></a>  17    # Constructor. Creates a new Workbook object from a BIFFwriter object.
</span><span class="inferred1"><a name="line18"></a>  18    #
</span><span class="marked0"><a name="line19"></a>  19    def initialize(filename)
</span><span class="marked1"><a name="line20"></a>  20       super
</span><span class="marked0"><a name="line21"></a>  21       @filename              = filename
</span><span class="marked1"><a name="line22"></a>  22       @parser                = Formula.new(@byte_order)
</span><span class="marked0"><a name="line23"></a>  23       @tempdir               = nil
</span><span class="marked1"><a name="line24"></a>  24       @v1904                 = 0 
</span><span class="marked0"><a name="line25"></a>  25       @activesheet           = 0 
</span><span class="marked1"><a name="line26"></a>  26       @firstsheet            = 0 
</span><span class="marked0"><a name="line27"></a>  27       @selected              = 0 
</span><span class="marked1"><a name="line28"></a>  28       @xf_index              = 0 
</span><span class="marked0"><a name="line29"></a>  29       @fileclosed            = 0 
</span><span class="marked1"><a name="line30"></a>  30       @biffsize              = 0 
</span><span class="marked0"><a name="line31"></a>  31       @sheetname             = &quot;Sheet&quot; 
</span><span class="marked1"><a name="line32"></a>  32       @url_format            = '' 
</span><span class="marked0"><a name="line33"></a>  33       @codepage              = 0x04E4 
</span><span class="marked1"><a name="line34"></a>  34       @worksheets            = [] 
</span><span class="marked0"><a name="line35"></a>  35       @sheetnames            = [] 
</span><span class="marked1"><a name="line36"></a>  36       @formats               = [] 
</span><span class="marked0"><a name="line37"></a>  37       @palette               = [] 
</span><span class="inferred1"><a name="line38"></a>  38 
</span><span class="marked0"><a name="line39"></a>  39       @using_tmpfile         = 1 
</span><span class="marked1"><a name="line40"></a>  40       @filehandle            = &quot;&quot; 
</span><span class="marked0"><a name="line41"></a>  41       @temp_file             = &quot;&quot; 
</span><span class="marked1"><a name="line42"></a>  42       @internal_fh           = 0 
</span><span class="marked0"><a name="line43"></a>  43       @fh_out                = &quot;&quot; 
</span><span class="inferred1"><a name="line44"></a>  44 
</span><span class="marked0"><a name="line45"></a>  45       @str_total             = 0 
</span><span class="marked1"><a name="line46"></a>  46       @str_unique            = 0 
</span><span class="marked0"><a name="line47"></a>  47       @str_table             = {} 
</span><span class="marked1"><a name="line48"></a>  48       @str_array             = [] 
</span><span class="marked0"><a name="line49"></a>  49       @str_block_sizes       = [] 
</span><span class="marked1"><a name="line50"></a>  50       @extsst_offsets        = [] 
</span><span class="marked0"><a name="line51"></a>  51       @extsst_buckets        = 0 
</span><span class="marked1"><a name="line52"></a>  52       @extsst_bucket_size    = 0 
</span><span class="inferred0"><a name="line53"></a>  53 
</span><span class="marked1"><a name="line54"></a>  54       @ext_ref_count         = 0 
</span><span class="marked0"><a name="line55"></a>  55       @ext_refs              = {} 
</span><span class="inferred1"><a name="line56"></a>  56 
</span><span class="marked0"><a name="line57"></a>  57       @mso_clusters          = [] 
</span><span class="marked1"><a name="line58"></a>  58       @mso_size              = 0 
</span><span class="inferred0"><a name="line59"></a>  59 
</span><span class="marked1"><a name="line60"></a>  60       @hideobj               = 0 
</span><span class="marked0"><a name="line61"></a>  61       @compatibility         = 0 
</span><span class="inferred1"><a name="line62"></a>  62 
</span><span class="marked0"><a name="line63"></a>  63       @add_doc_properties    = 0 
</span><span class="marked1"><a name="line64"></a>  64       @localtime             = Time.now
</span><span class="inferred0"><a name="line65"></a>  65 
</span><span class="inferred1"><a name="line66"></a>  66       # Add the in-built style formats and the default cell format.
</span><span class="marked0"><a name="line67"></a>  67       add_format(:type =&gt; 1)                        #  0 Normal
</span><span class="marked1"><a name="line68"></a>  68       add_format(:type =&gt; 1)                        #  1 RowLevel 1
</span><span class="marked0"><a name="line69"></a>  69       add_format(:type =&gt; 1)                        #  2 RowLevel 2
</span><span class="marked1"><a name="line70"></a>  70       add_format(:type =&gt; 1)                        #  3 RowLevel 3
</span><span class="marked0"><a name="line71"></a>  71       add_format(:type =&gt; 1)                        #  4 RowLevel 4
</span><span class="marked1"><a name="line72"></a>  72       add_format(:type =&gt; 1)                        #  5 RowLevel 5
</span><span class="marked0"><a name="line73"></a>  73       add_format(:type =&gt; 1)                        #  6 RowLevel 6
</span><span class="marked1"><a name="line74"></a>  74       add_format(:type =&gt; 1)                        #  7 RowLevel 7
</span><span class="marked0"><a name="line75"></a>  75       add_format(:type =&gt; 1)                        #  8 ColLevel 1
</span><span class="marked1"><a name="line76"></a>  76       add_format(:type =&gt; 1)                        #  9 ColLevel 2
</span><span class="marked0"><a name="line77"></a>  77       add_format(:type =&gt; 1)                        # 10 ColLevel 3
</span><span class="marked1"><a name="line78"></a>  78       add_format(:type =&gt; 1)                        # 11 ColLevel 4
</span><span class="marked0"><a name="line79"></a>  79       add_format(:type =&gt; 1)                        # 12 ColLevel 5
</span><span class="marked1"><a name="line80"></a>  80       add_format(:type =&gt; 1)                        # 13 ColLevel 6
</span><span class="marked0"><a name="line81"></a>  81       add_format(:type =&gt; 1)                        # 14 ColLevel 7
</span><span class="marked1"><a name="line82"></a>  82       add_format()                                  # 15 Cell XF
</span><span class="marked0"><a name="line83"></a>  83       add_format(:type =&gt; 1, :num_format =&gt; 0x2B)   # 16 Comma
</span><span class="marked1"><a name="line84"></a>  84       add_format(:type =&gt; 1, :num_format =&gt; 0x29)   # 17 Comma[0]
</span><span class="marked0"><a name="line85"></a>  85       add_format(:type =&gt; 1, :num_format =&gt; 0x2C)   # 18 Currency
</span><span class="marked1"><a name="line86"></a>  86       add_format(:type =&gt; 1, :num_format =&gt; 0x2A)   # 19 Currency[0]
</span><span class="marked0"><a name="line87"></a>  87       add_format(:type =&gt; 1, :num_format =&gt; 0x09)   # 20 Percent
</span><span class="inferred1"><a name="line88"></a>  88 
</span><span class="inferred0"><a name="line89"></a>  89       # Add the default format for hyperlinks
</span><span class="marked1"><a name="line90"></a>  90       @url_format = add_format(:color =&gt; 'blue', :underline =&gt; 1) 
</span><span class="inferred0"><a name="line91"></a>  91 
</span><span class="inferred1"><a name="line92"></a>  92       # Convert the filename to a filehandle to pass to the OLE writer when the
</span><span class="inferred0"><a name="line93"></a>  93       # file is closed. If the filename is a reference it is assumed that it is
</span><span class="inferred1"><a name="line94"></a>  94       # a valid filehandle.
</span><span class="inferred0"><a name="line95"></a>  95       #
</span><span class="marked1"><a name="line96"></a>  96       if filename.kind_of?(String) &amp;&amp; filename != ''
</span><span class="marked0"><a name="line97"></a>  97          @fh_out      = open(filename, &quot;wb&quot;)
</span><span class="marked1"><a name="line98"></a>  98          @internal_fh = 1
</span><span class="uncovered0"><a name="line99"></a>  99       else
</span><span class="uncovered1"><a name="line100"></a> 100          print &quot;Workbook#new - filename required.&quot;
</span><span class="uncovered0"><a name="line101"></a> 101          exit
</span><span class="uncovered1"><a name="line102"></a> 102       end
</span><span class="inferred0"><a name="line103"></a> 103 
</span><span class="inferred1"><a name="line104"></a> 104       # Set colour palette.
</span><span class="marked0"><a name="line105"></a> 105       set_palette_xl97
</span><span class="inferred1"><a name="line106"></a> 106 
</span><span class="marked0"><a name="line107"></a> 107       _initialize
</span><span class="marked1"><a name="line108"></a> 108       get_checksum_method
</span><span class="inferred0"><a name="line109"></a> 109    end
</span><span class="inferred1"><a name="line110"></a> 110 
</span><span class="inferred0"><a name="line111"></a> 111 
</span><span class="inferred1"><a name="line112"></a> 112    ###############################################################################
</span><span class="inferred0"><a name="line113"></a> 113    #
</span><span class="inferred1"><a name="line114"></a> 114    # _initialize()
</span><span class="inferred0"><a name="line115"></a> 115    #
</span><span class="inferred1"><a name="line116"></a> 116    # Open a tmp file to store the majority of the Worksheet data. If this fails,
</span><span class="inferred0"><a name="line117"></a> 117    # for example due to write permissions, store the data in memory. This can be
</span><span class="inferred1"><a name="line118"></a> 118    # slow for large files.
</span><span class="inferred0"><a name="line119"></a> 119    #
</span><span class="inferred1"><a name="line120"></a> 120    # TODO: Move this and other methods shared with Worksheet up into BIFFWriter.
</span><span class="inferred0"><a name="line121"></a> 121    #
</span><span class="marked1"><a name="line122"></a> 122    def _initialize
</span><span class="marked0"><a name="line123"></a> 123       basename = 'spreadsheetwriteexcelworkbook'
</span><span class="inferred1"><a name="line124"></a> 124 
</span><span class="marked0"><a name="line125"></a> 125       begin
</span><span class="marked1"><a name="line126"></a> 126          if !@tempdir.nil?
</span><span class="uncovered0"><a name="line127"></a> 127             if @tempdir == ''
</span><span class="uncovered1"><a name="line128"></a> 128                fh = Tempfile.new(basename)
</span><span class="uncovered0"><a name="line129"></a> 129             else
</span><span class="uncovered1"><a name="line130"></a> 130                fh = Tempfile.new(basename, @tempdir)
</span><span class="uncovered0"><a name="line131"></a> 131             end
</span><span class="uncovered1"><a name="line132"></a> 132          end
</span><span class="uncovered0"><a name="line133"></a> 133       # failed. store temporary data in memory.
</span><span class="uncovered1"><a name="line134"></a> 134       rescue
</span><span class="uncovered0"><a name="line135"></a> 135          @using_tmpfile = 0
</span><span class="inferred1"><a name="line136"></a> 136       # if the temp file creation was successful
</span><span class="inferred0"><a name="line137"></a> 137       else
</span><span class="marked1"><a name="line138"></a> 138          @filehandle = fh
</span><span class="inferred0"><a name="line139"></a> 139       end
</span><span class="inferred1"><a name="line140"></a> 140    end
</span><span class="inferred0"><a name="line141"></a> 141 
</span><span class="inferred1"><a name="line142"></a> 142    ###############################################################################
</span><span class="inferred0"><a name="line143"></a> 143    #
</span><span class="inferred1"><a name="line144"></a> 144    # _get_checksum_method.
</span><span class="inferred0"><a name="line145"></a> 145    #
</span><span class="inferred1"><a name="line146"></a> 146    # Check for modules available to calculate image checksum. Excel uses MD4 but
</span><span class="inferred0"><a name="line147"></a> 147    # MD5 will also work.
</span><span class="inferred1"><a name="line148"></a> 148    #
</span><span class="inferred0"><a name="line149"></a> 149    # ------- cxn03651 add -------
</span><span class="inferred1"><a name="line150"></a> 150    # md5 can use in ruby. so, @checksum_method is always 3.
</span><span class="inferred0"><a name="line151"></a> 151    
</span><span class="marked1"><a name="line152"></a> 152    def get_checksum_method
</span><span class="marked0"><a name="line153"></a> 153       @checksum_method = 3
</span><span class="marked1"><a name="line154"></a> 154    end
</span><span class="inferred0"><a name="line155"></a> 155 
</span><span class="inferred1"><a name="line156"></a> 156    ###############################################################################
</span><span class="inferred0"><a name="line157"></a> 157    #
</span><span class="inferred1"><a name="line158"></a> 158    # _append(), overloaded.
</span><span class="inferred0"><a name="line159"></a> 159    #
</span><span class="inferred1"><a name="line160"></a> 160    # Store Worksheet data in memory using the base class _append() or to a
</span><span class="inferred0"><a name="line161"></a> 161    # temporary file, the default.
</span><span class="inferred1"><a name="line162"></a> 162    #
</span><span class="marked0"><a name="line163"></a> 163    def append(*args)
</span><span class="uncovered1"><a name="line164"></a> 164       data = ''
</span><span class="uncovered0"><a name="line165"></a> 165       if @using_tmpfile != 0
</span><span class="uncovered1"><a name="line166"></a> 166          data = args.join('')
</span><span class="uncovered0"><a name="line167"></a> 167 
</span><span class="uncovered1"><a name="line168"></a> 168          # Add CONTINUE records if necessary
</span><span class="uncovered0"><a name="line169"></a> 169          data = add_continue(data) if data.length &gt; @limit
</span><span class="uncovered1"><a name="line170"></a> 170 
</span><span class="uncovered0"><a name="line171"></a> 171 #         # Protect print() from -l on the command line.
</span><span class="uncovered1"><a name="line172"></a> 172 #         local $\ = undef;
</span><span class="uncovered0"><a name="line173"></a> 173 #
</span><span class="uncovered1"><a name="line174"></a> 174          @filehandle.write data
</span><span class="uncovered0"><a name="line175"></a> 175          @datasize += data.length
</span><span class="uncovered1"><a name="line176"></a> 176       else
</span><span class="uncovered0"><a name="line177"></a> 177          data = super(*args)
</span><span class="uncovered1"><a name="line178"></a> 178       end
</span><span class="uncovered0"><a name="line179"></a> 179 
</span><span class="uncovered1"><a name="line180"></a> 180       return data
</span><span class="uncovered0"><a name="line181"></a> 181    end
</span><span class="inferred1"><a name="line182"></a> 182 
</span><span class="inferred0"><a name="line183"></a> 183    ###############################################################################
</span><span class="inferred1"><a name="line184"></a> 184    #
</span><span class="inferred0"><a name="line185"></a> 185    # get_data().
</span><span class="inferred1"><a name="line186"></a> 186    #
</span><span class="inferred0"><a name="line187"></a> 187    # Retrieves data from memory in one chunk, or from disk in $buffer
</span><span class="inferred1"><a name="line188"></a> 188    # sized chunks.
</span><span class="inferred0"><a name="line189"></a> 189    #
</span><span class="marked1"><a name="line190"></a> 190    def get_data
</span><span class="uncovered0"><a name="line191"></a> 191       bufsize = 4096
</span><span class="uncovered1"><a name="line192"></a> 192 
</span><span class="uncovered0"><a name="line193"></a> 193       # Return data stored in memory
</span><span class="uncovered1"><a name="line194"></a> 194       unless @data.nil?
</span><span class="uncovered0"><a name="line195"></a> 195          tmp   = @data
</span><span class="uncovered1"><a name="line196"></a> 196          @data = nil
</span><span class="uncovered0"><a name="line197"></a> 197          @filehandle.seek(0, IO::SEEK_SET) if using_tmpfile != 0
</span><span class="uncovered1"><a name="line198"></a> 198          return tmp
</span><span class="uncovered0"><a name="line199"></a> 199       end
</span><span class="uncovered1"><a name="line200"></a> 200 
</span><span class="uncovered0"><a name="line201"></a> 201       # Return data stored on disk
</span><span class="uncovered1"><a name="line202"></a> 202       if @using_tmpfile != 0
</span><span class="uncovered0"><a name="line203"></a> 203          tmp = @filehandle.read(bufsize)
</span><span class="uncovered1"><a name="line204"></a> 204          return tmp unless tmp.nil?
</span><span class="uncovered0"><a name="line205"></a> 205       end
</span><span class="uncovered1"><a name="line206"></a> 206 
</span><span class="uncovered0"><a name="line207"></a> 207        # No data to return
</span><span class="uncovered1"><a name="line208"></a> 208        return nil
</span><span class="uncovered0"><a name="line209"></a> 209    end
</span><span class="inferred1"><a name="line210"></a> 210 
</span><span class="inferred0"><a name="line211"></a> 211    ###############################################################################
</span><span class="inferred1"><a name="line212"></a> 212    #
</span><span class="inferred0"><a name="line213"></a> 213    # close()
</span><span class="inferred1"><a name="line214"></a> 214    #
</span><span class="inferred0"><a name="line215"></a> 215    # Calls finalization methods and explicitly close the OLEwriter file
</span><span class="inferred1"><a name="line216"></a> 216    # handle.
</span><span class="inferred0"><a name="line217"></a> 217    #
</span><span class="marked1"><a name="line218"></a> 218    def close
</span><span class="uncovered0"><a name="line219"></a> 219        return if @fileclosed != 0   # Prevent close() from being called twice.
</span><span class="uncovered1"><a name="line220"></a> 220    
</span><span class="uncovered0"><a name="line221"></a> 221        @fileclosed = 1
</span><span class="uncovered1"><a name="line222"></a> 222        return store_workbook
</span><span class="uncovered0"><a name="line223"></a> 223    end
</span><span class="inferred1"><a name="line224"></a> 224 
</span><span class="inferred0"><a name="line225"></a> 225    ###############################################################################
</span><span class="inferred1"><a name="line226"></a> 226    #
</span><span class="inferred0"><a name="line227"></a> 227    # sheets(slice,...)
</span><span class="inferred1"><a name="line228"></a> 228    #
</span><span class="inferred0"><a name="line229"></a> 229    # An accessor for the _worksheets[] array
</span><span class="inferred1"><a name="line230"></a> 230    #
</span><span class="inferred0"><a name="line231"></a> 231    # Returns: an optionally sliced list of the worksheet objects in a workbook.
</span><span class="inferred1"><a name="line232"></a> 232    #
</span><span class="marked0"><a name="line233"></a> 233    def sheets(*args)
</span><span class="marked1"><a name="line234"></a> 234        unless args.empty?
</span><span class="inferred0"><a name="line235"></a> 235 #           # Return a slice of the array
</span><span class="inferred1"><a name="line236"></a> 236 #           return @{$self-&gt;{_worksheets}}[@_];
</span><span class="inferred0"><a name="line237"></a> 237        else
</span><span class="inferred1"><a name="line238"></a> 238            # Return the entire list
</span><span class="marked0"><a name="line239"></a> 239            return @worksheets
</span><span class="inferred1"><a name="line240"></a> 240        end
</span><span class="marked0"><a name="line241"></a> 241    end
</span><span class="inferred1"><a name="line242"></a> 242 
</span><span class="inferred0"><a name="line243"></a> 243    ###############################################################################
</span><span class="inferred1"><a name="line244"></a> 244    #
</span><span class="inferred0"><a name="line245"></a> 245    # add_worksheet($name, $encoding)
</span><span class="inferred1"><a name="line246"></a> 246    #
</span><span class="inferred0"><a name="line247"></a> 247    # Add a new worksheet to the Excel workbook.
</span><span class="inferred1"><a name="line248"></a> 248    #
</span><span class="inferred0"><a name="line249"></a> 249    # Returns: reference to a worksheet object
</span><span class="inferred1"><a name="line250"></a> 250    #
</span><span class="marked0"><a name="line251"></a> 251    def add_worksheet(name = '', encoding = 0)
</span><span class="marked1"><a name="line252"></a> 252       name, encoding = check_sheetname(name, encoding)
</span><span class="inferred0"><a name="line253"></a> 253 
</span><span class="marked1"><a name="line254"></a> 254       index = @worksheets.size
</span><span class="inferred0"><a name="line255"></a> 255 
</span><span class="marked1"><a name="line256"></a> 256        worksheet = Worksheet.new(
</span><span class="inferred0"><a name="line257"></a> 257             name,
</span><span class="inferred1"><a name="line258"></a> 258             index,
</span><span class="inferred0"><a name="line259"></a> 259             encoding,
</span><span class="inferred1"><a name="line260"></a> 260             @activesheet,
</span><span class="inferred0"><a name="line261"></a> 261             @firstsheet,
</span><span class="inferred1"><a name="line262"></a> 262             @url_format,
</span><span class="inferred0"><a name="line263"></a> 263             @parser,
</span><span class="inferred1"><a name="line264"></a> 264             @tempdir,
</span><span class="inferred0"><a name="line265"></a> 265             @str_total,
</span><span class="inferred1"><a name="line266"></a> 266             @str_unique,
</span><span class="inferred0"><a name="line267"></a> 267             @str_table,
</span><span class="inferred1"><a name="line268"></a> 268             @v1904,
</span><span class="inferred0"><a name="line269"></a> 269             @compatibility
</span><span class="inferred1"><a name="line270"></a> 270          )
</span><span class="marked0"><a name="line271"></a> 271        @worksheets[index] = worksheet     # Store ref for iterator
</span><span class="marked1"><a name="line272"></a> 272        @sheetnames[index] = name          # Store EXTERNSHEET names
</span><span class="inferred0"><a name="line273"></a> 273 #       @parser-&gt;set_ext_sheets($name, $index) # Store names in Formula.pm
</span><span class="marked1"><a name="line274"></a> 274        return worksheet
</span><span class="inferred0"><a name="line275"></a> 275    end
</span><span class="inferred1"><a name="line276"></a> 276 
</span><span class="inferred0"><a name="line277"></a> 277    ###############################################################################
</span><span class="inferred1"><a name="line278"></a> 278    #
</span><span class="inferred0"><a name="line279"></a> 279    # add_chart_ext($filename, $name)
</span><span class="inferred1"><a name="line280"></a> 280    #
</span><span class="inferred0"><a name="line281"></a> 281    # Add an externally created chart.
</span><span class="inferred1"><a name="line282"></a> 282    #
</span><span class="inferred0"><a name="line283"></a> 283    #
</span><span class="marked1"><a name="line284"></a> 284    def add_chart_ext(filename, name, encoding = nil)
</span><span class="uncovered0"><a name="line285"></a> 285       index    = @worksheets.size
</span><span class="uncovered1"><a name="line286"></a> 286 
</span><span class="uncovered0"><a name="line287"></a> 287       name, encoding = check_sheetname(name, encoding)
</span><span class="uncovered1"><a name="line288"></a> 288 
</span><span class="uncovered0"><a name="line289"></a> 289       init_data = [
</span><span class="uncovered1"><a name="line290"></a> 290                       filename,
</span><span class="uncovered0"><a name="line291"></a> 291                       name,
</span><span class="uncovered1"><a name="line292"></a> 292                       index,
</span><span class="uncovered0"><a name="line293"></a> 293                       encoding,
</span><span class="uncovered1"><a name="line294"></a> 294                       @activesheet,
</span><span class="uncovered0"><a name="line295"></a> 295                       @firstsheet
</span><span class="uncovered1"><a name="line296"></a> 296                   ]
</span><span class="uncovered0"><a name="line297"></a> 297 
</span><span class="uncovered1"><a name="line298"></a> 298        worksheet = Chart.new(*init_data)
</span><span class="uncovered0"><a name="line299"></a> 299        @worksheets[index] = worksheet      # Store ref for iterator
</span><span class="uncovered1"><a name="line300"></a> 300        @sheetnames[index] = name           # Store EXTERNSHEET names
</span><span class="uncovered0"><a name="line301"></a> 301        @parser.set_ext_sheets(name, index) # Store names in Formula.pm
</span><span class="uncovered1"><a name="line302"></a> 302        return worksheet
</span><span class="uncovered0"><a name="line303"></a> 303    end
</span><span class="inferred1"><a name="line304"></a> 304 
</span><span class="inferred0"><a name="line305"></a> 305    ###############################################################################
</span><span class="inferred1"><a name="line306"></a> 306    #
</span><span class="inferred0"><a name="line307"></a> 307    # _check_sheetname($name, $encoding)
</span><span class="inferred1"><a name="line308"></a> 308    #
</span><span class="inferred0"><a name="line309"></a> 309    # Check for valid worksheet names. We check the length, if it contains any
</span><span class="inferred1"><a name="line310"></a> 310    # invalid characters and if the name is unique in the workbook.
</span><span class="inferred0"><a name="line311"></a> 311    #
</span><span class="marked1"><a name="line312"></a> 312    def check_sheetname(name, encoding = 0)
</span><span class="marked0"><a name="line313"></a> 313       name = '' if name.nil?
</span><span class="marked1"><a name="line314"></a> 314       limit           = encoding != 0 ? 62 : 31
</span><span class="marked0"><a name="line315"></a> 315       invalid_char    = %r![\[\]:*?/\\]!
</span><span class="inferred1"><a name="line316"></a> 316 
</span><span class="inferred0"><a name="line317"></a> 317       # Supply default &quot;Sheet&quot; name if none has been defined.
</span><span class="marked1"><a name="line318"></a> 318       index     = @worksheets.size
</span><span class="marked0"><a name="line319"></a> 319       sheetname = @sheetname
</span><span class="inferred1"><a name="line320"></a> 320 
</span><span class="marked0"><a name="line321"></a> 321       if name == &quot;&quot;
</span><span class="marked1"><a name="line322"></a> 322          name     = sheetname + (index+1).to_s
</span><span class="marked0"><a name="line323"></a> 323          encoding = 0
</span><span class="inferred1"><a name="line324"></a> 324       end
</span><span class="inferred0"><a name="line325"></a> 325 
</span><span class="inferred1"><a name="line326"></a> 326       # Check that sheetname is &lt;= 31 (1 or 2 byte chars). Excel limit.
</span><span class="marked0"><a name="line327"></a> 327       raise &quot;Sheetname #{name} must be &lt;= 31 chars&quot; if name.length &gt; limit
</span><span class="inferred1"><a name="line328"></a> 328 
</span><span class="inferred0"><a name="line329"></a> 329       # Check that Unicode sheetname has an even number of bytes
</span><span class="marked1"><a name="line330"></a> 330       if encoding == 1 and name.length % 2
</span><span class="inferred0"><a name="line331"></a> 331          raise 'Odd number of bytes in Unicode worksheet name:' + name
</span><span class="inferred1"><a name="line332"></a> 332       end
</span><span class="inferred0"><a name="line333"></a> 333 
</span><span class="inferred1"><a name="line334"></a> 334       # Check that sheetname doesn't contain any invalid characters
</span><span class="marked0"><a name="line335"></a> 335       if encoding != 1 and name =~ invalid_char
</span><span class="inferred1"><a name="line336"></a> 336          # Check ASCII names
</span><span class="marked0"><a name="line337"></a> 337          raise 'Invalid character []:*?/\\ in worksheet name: ' + name
</span><span class="uncovered1"><a name="line338"></a> 338       else
</span><span class="uncovered0"><a name="line339"></a> 339 #         # Extract any 8bit clean chars from the UTF16 name and validate them.
</span><span class="uncovered1"><a name="line340"></a> 340 #         for my $wchar ($name =~ /../sg) {
</span><span class="uncovered0"><a name="line341"></a> 341 #            my ($hi, $lo) = unpack &quot;aa&quot;, $wchar;
</span><span class="uncovered1"><a name="line342"></a> 342 #            if ($hi eq &quot;\0&quot; and $lo =~ $invalid_char)
</span><span class="uncovered0"><a name="line343"></a> 343 #               raise 'Invalid character []:*?/\\ in worksheet name: ' + name
</span><span class="uncovered1"><a name="line344"></a> 344 #            end
</span><span class="uncovered0"><a name="line345"></a> 345 #        }
</span><span class="uncovered1"><a name="line346"></a> 346       end
</span><span class="inferred0"><a name="line347"></a> 347    
</span><span class="inferred1"><a name="line348"></a> 348       # Check that the worksheet name doesn't already exist since this is a fatal
</span><span class="inferred0"><a name="line349"></a> 349       # error in Excel 97. The check must also exclude case insensitive matches
</span><span class="inferred1"><a name="line350"></a> 350       # since the names 'Sheet1' and 'sheet1' are equivalent. The tests also have
</span><span class="inferred0"><a name="line351"></a> 351       # to take the encoding into account.
</span><span class="inferred1"><a name="line352"></a> 352       #
</span><span class="marked0"><a name="line353"></a> 353       @worksheets.each do |worksheet|
</span><span class="marked1"><a name="line354"></a> 354          name_a  = name
</span><span class="marked0"><a name="line355"></a> 355          encd_a  = encoding
</span><span class="marked1"><a name="line356"></a> 356          name_b  = worksheet.name
</span><span class="marked0"><a name="line357"></a> 357          encd_b  = worksheet.encoding
</span><span class="marked1"><a name="line358"></a> 358          error   = 0;
</span><span class="inferred0"><a name="line359"></a> 359 
</span><span class="marked1"><a name="line360"></a> 360          if    encd_a == 0 and encd_b == 0
</span><span class="marked0"><a name="line361"></a> 361             error  = 1 if name_a.downcase == name_b.downcase
</span><span class="uncovered1"><a name="line362"></a> 362          elsif encd_a == 0 and encd_b == 1
</span><span class="uncovered0"><a name="line363"></a> 363             name_a = [name_a].unpack(&quot;C*&quot;).pack(&quot;n*&quot;)
</span><span class="uncovered1"><a name="line364"></a> 364             error  = 1 if name_a.downcase == name_b.downcase
</span><span class="uncovered0"><a name="line365"></a> 365          elsif encd_a == 1 and encd_b == 0
</span><span class="uncovered1"><a name="line366"></a> 366             name_b = [name_b].unpack(&quot;C*&quot;).pack(&quot;n*&quot;)
</span><span class="uncovered0"><a name="line367"></a> 367             error  = 1 if name_a.downcase == name_b.downcase
</span><span class="uncovered1"><a name="line368"></a> 368          elsif encd_a == 1 and encd_b == 1
</span><span class="uncovered0"><a name="line369"></a> 369 #            # We can do a true case insensitive test with Perl 5.8 and utf8.
</span><span class="uncovered1"><a name="line370"></a> 370 #            if ($] &gt;= 5.008) {
</span><span class="uncovered0"><a name="line371"></a> 371 #               $name_a = Encode::decode(&quot;UTF-16BE&quot;, $name_a);
</span><span class="uncovered1"><a name="line372"></a> 372 #               $name_b = Encode::decode(&quot;UTF-16BE&quot;, $name_b);
</span><span class="uncovered0"><a name="line373"></a> 373 #               $error  = 1 if lc($name_a) eq lc($name_b);
</span><span class="uncovered1"><a name="line374"></a> 374 #            }
</span><span class="uncovered0"><a name="line375"></a> 375 #            else {
</span><span class="uncovered1"><a name="line376"></a> 376 #               # We can't easily do a case insensitive test of the UTF16 names.
</span><span class="uncovered0"><a name="line377"></a> 377 #               # As a special case we check if all of the high bytes are nulls and
</span><span class="uncovered1"><a name="line378"></a> 378 #               # then do an ASCII style case insensitive test.
</span><span class="uncovered0"><a name="line379"></a> 379 #   
</span><span class="uncovered1"><a name="line380"></a> 380 #               # Strip out the high bytes (funkily).
</span><span class="uncovered0"><a name="line381"></a> 381 #               my $hi_a = grep {ord} $name_a =~ /(.)./sg;
</span><span class="uncovered1"><a name="line382"></a> 382 #               my $hi_b = grep {ord} $name_b =~ /(.)./sg;
</span><span class="uncovered0"><a name="line383"></a> 383 #   
</span><span class="uncovered1"><a name="line384"></a> 384 #               if ($hi_a or $hi_b) {
</span><span class="uncovered0"><a name="line385"></a> 385 #                  $error  = 1 if    $name_a  eq    $name_b;
</span><span class="uncovered1"><a name="line386"></a> 386 #               }
</span><span class="uncovered0"><a name="line387"></a> 387 #               else {
</span><span class="uncovered1"><a name="line388"></a> 388 #                  $error  = 1 if lc($name_a) eq lc($name_b);
</span><span class="uncovered0"><a name="line389"></a> 389 #               }
</span><span class="uncovered1"><a name="line390"></a> 390 #            }
</span><span class="uncovered0"><a name="line391"></a> 391 #         }
</span><span class="uncovered1"><a name="line392"></a> 392 #         # If any of the cases failed we throw the error here.
</span><span class="uncovered0"><a name="line393"></a> 393          end
</span><span class="marked1"><a name="line394"></a> 394          if error != 0
</span><span class="inferred0"><a name="line395"></a> 395             raise &quot;Worksheet name '#{name}', with case ignored, &quot; +
</span><span class="marked1"><a name="line396"></a> 396                   &quot;is already in use&quot;;
</span><span class="inferred0"><a name="line397"></a> 397          end
</span><span class="inferred1"><a name="line398"></a> 398       end
</span><span class="marked0"><a name="line399"></a> 399       return [name,  encoding]
</span><span class="inferred1"><a name="line400"></a> 400    end
</span><span class="inferred0"><a name="line401"></a> 401 
</span><span class="inferred1"><a name="line402"></a> 402    ###############################################################################
</span><span class="inferred0"><a name="line403"></a> 403    #
</span><span class="inferred1"><a name="line404"></a> 404    # add_format(%properties)
</span><span class="inferred0"><a name="line405"></a> 405    #
</span><span class="inferred1"><a name="line406"></a> 406    # Add a new format to the Excel workbook. This adds an XF record and
</span><span class="inferred0"><a name="line407"></a> 407    # a FONT record. Also, pass any properties to the Format::new().
</span><span class="inferred1"><a name="line408"></a> 408    #
</span><span class="marked0"><a name="line409"></a> 409    def add_format(*args)
</span><span class="marked1"><a name="line410"></a> 410        format = Format.new(@xf_index, args)
</span><span class="marked0"><a name="line411"></a> 411        @xf_index += 1
</span><span class="marked1"><a name="line412"></a> 412        @formats.push format # Store format reference
</span><span class="marked0"><a name="line413"></a> 413        return format
</span><span class="inferred1"><a name="line414"></a> 414    end
</span><span class="inferred0"><a name="line415"></a> 415 
</span><span class="inferred1"><a name="line416"></a> 416    ###############################################################################
</span><span class="inferred0"><a name="line417"></a> 417    #
</span><span class="inferred1"><a name="line418"></a> 418    # compatibility_mode()
</span><span class="inferred0"><a name="line419"></a> 419    #
</span><span class="inferred1"><a name="line420"></a> 420    # Set the compatibility mode.
</span><span class="inferred0"><a name="line421"></a> 421    #
</span><span class="inferred1"><a name="line422"></a> 422    # Excel doesn't require every possible Biff record to be present in a file.
</span><span class="inferred0"><a name="line423"></a> 423    # In particular if the indexing records INDEX, ROW and DBCELL aren't present
</span><span class="inferred1"><a name="line424"></a> 424    # it just ignores the fact and reads the cells anyway. This is also true of
</span><span class="inferred0"><a name="line425"></a> 425    # the EXTSST record. Gnumeric and OOo also take this approach. This allows
</span><span class="inferred1"><a name="line426"></a> 426    # WriteExcel to ignore these records in order to minimise the amount of data
</span><span class="inferred0"><a name="line427"></a> 427    # stored in memory. However, other third party applications that read Excel
</span><span class="inferred1"><a name="line428"></a> 428    # files often expect these records to be present. In &quot;compatibility mode&quot;
</span><span class="inferred0"><a name="line429"></a> 429    # WriteExcel writes these records and tries to be as close to an Excel
</span><span class="inferred1"><a name="line430"></a> 430    # generated file as possible.
</span><span class="inferred0"><a name="line431"></a> 431    #
</span><span class="inferred1"><a name="line432"></a> 432    # This requires additional data to be stored in memory until the file is
</span><span class="inferred0"><a name="line433"></a> 433    # about to be written. This incurs a memory and speed penalty and may not be
</span><span class="inferred1"><a name="line434"></a> 434    # suitable for very large files.
</span><span class="inferred0"><a name="line435"></a> 435    #
</span><span class="marked1"><a name="line436"></a> 436    def compatibility_mode(mode = 1)
</span><span class="marked0"><a name="line437"></a> 437       unless sheets.empty?
</span><span class="uncovered1"><a name="line438"></a> 438          raise &quot;compatibility_mode() must be called before add_worksheet()&quot;
</span><span class="uncovered0"><a name="line439"></a> 439       end
</span><span class="marked1"><a name="line440"></a> 440       @compatibility = mode
</span><span class="inferred0"><a name="line441"></a> 441    end
</span><span class="inferred1"><a name="line442"></a> 442 
</span><span class="inferred0"><a name="line443"></a> 443    ###############################################################################
</span><span class="inferred1"><a name="line444"></a> 444    #
</span><span class="inferred0"><a name="line445"></a> 445    # set_1904()
</span><span class="inferred1"><a name="line446"></a> 446    #
</span><span class="inferred0"><a name="line447"></a> 447    # Set the date system: 0 = 1900 (the default), 1 = 1904
</span><span class="inferred1"><a name="line448"></a> 448    #
</span><span class="marked0"><a name="line449"></a> 449    def set_1904(mode = 1)
</span><span class="uncovered1"><a name="line450"></a> 450       unless sheets.empty?
</span><span class="uncovered0"><a name="line451"></a> 451          raise &quot;set_1904() must be called before add_worksheet()&quot;
</span><span class="uncovered1"><a name="line452"></a> 452       end
</span><span class="uncovered0"><a name="line453"></a> 453       @v1904 = mode
</span><span class="uncovered1"><a name="line454"></a> 454    end
</span><span class="inferred0"><a name="line455"></a> 455 
</span><span class="inferred1"><a name="line456"></a> 456    ###############################################################################
</span><span class="inferred0"><a name="line457"></a> 457    #
</span><span class="inferred1"><a name="line458"></a> 458    # set_custom_color()
</span><span class="inferred0"><a name="line459"></a> 459    #
</span><span class="inferred1"><a name="line460"></a> 460    # Change the RGB components of the elements in the colour palette.
</span><span class="inferred0"><a name="line461"></a> 461    #
</span><span class="marked1"><a name="line462"></a> 462    def set_custom_color(index = nil, red = nil, green = nil, blue = nil)
</span><span class="uncovered0"><a name="line463"></a> 463       # Match a HTML #xxyyzz style parameter
</span><span class="uncovered1"><a name="line464"></a> 464       if !red.nil? &amp;&amp; red =~ /^#(\w\w)(\w\w)(\w\w)/
</span><span class="uncovered0"><a name="line465"></a> 465          red   = $1.hex
</span><span class="uncovered1"><a name="line466"></a> 466          green = $2.hex
</span><span class="uncovered0"><a name="line467"></a> 467          blue  = $3.hex
</span><span class="uncovered1"><a name="line468"></a> 468       end
</span><span class="uncovered0"><a name="line469"></a> 469 
</span><span class="uncovered1"><a name="line470"></a> 470       # Check that the colour index is the right range
</span><span class="uncovered0"><a name="line471"></a> 471       if index &lt; 8 || index &gt; 64
</span><span class="uncovered1"><a name="line472"></a> 472          raise &quot;Color index #{index} outside range: 8 &lt;= index &lt;= 64&quot;;
</span><span class="uncovered0"><a name="line473"></a> 473       end
</span><span class="uncovered1"><a name="line474"></a> 474 
</span><span class="uncovered0"><a name="line475"></a> 475       # Check that the colour components are in the right range
</span><span class="uncovered1"><a name="line476"></a> 476       if (red   &lt; 0 || red   &gt; 255) ||
</span><span class="uncovered0"><a name="line477"></a> 477          (green &lt; 0 || green &gt; 255) ||
</span><span class="uncovered1"><a name="line478"></a> 478          (blue  &lt; 0 || blue  &gt; 255)
</span><span class="uncovered0"><a name="line479"></a> 479            raise &quot;Color component outside range: 0 &lt;= color &lt;= 255&quot;;
</span><span class="uncovered1"><a name="line480"></a> 480       end
</span><span class="uncovered0"><a name="line481"></a> 481       
</span><span class="uncovered1"><a name="line482"></a> 482       index -=8       # Adjust colour index (wingless dragonfly)
</span><span class="uncovered0"><a name="line483"></a> 483 
</span><span class="uncovered1"><a name="line484"></a> 484       # Set the RGB value
</span><span class="uncovered0"><a name="line485"></a> 485       @palette[index] = [red, green, blue, 0]
</span><span class="uncovered1"><a name="line486"></a> 486 
</span><span class="uncovered0"><a name="line487"></a> 487       return index +8
</span><span class="uncovered1"><a name="line488"></a> 488    end
</span><span class="inferred0"><a name="line489"></a> 489 
</span><span class="inferred1"><a name="line490"></a> 490    ###############################################################################
</span><span class="inferred0"><a name="line491"></a> 491    #
</span><span class="inferred1"><a name="line492"></a> 492    # set_palette_xl97()
</span><span class="inferred0"><a name="line493"></a> 493    #
</span><span class="inferred1"><a name="line494"></a> 494    # Sets the colour palette to the Excel 97+ default.
</span><span class="inferred0"><a name="line495"></a> 495    #
</span><span class="marked1"><a name="line496"></a> 496    def set_palette_xl97
</span><span class="marked0"><a name="line497"></a> 497       @palette = [
</span><span class="inferred1"><a name="line498"></a> 498          [0x00, 0x00, 0x00, 0x00],   # 8
</span><span class="inferred0"><a name="line499"></a> 499          [0xff, 0xff, 0xff, 0x00],   # 9
</span><span class="inferred1"><a name="line500"></a> 500          [0xff, 0x00, 0x00, 0x00],   # 10
</span><span class="inferred0"><a name="line501"></a> 501          [0x00, 0xff, 0x00, 0x00],   # 11
</span><span class="inferred1"><a name="line502"></a> 502          [0x00, 0x00, 0xff, 0x00],   # 12
</span><span class="inferred0"><a name="line503"></a> 503          [0xff, 0xff, 0x00, 0x00],   # 13
</span><span class="inferred1"><a name="line504"></a> 504          [0xff, 0x00, 0xff, 0x00],   # 14
</span><span class="inferred0"><a name="line505"></a> 505          [0x00, 0xff, 0xff, 0x00],   # 15
</span><span class="inferred1"><a name="line506"></a> 506          [0x80, 0x00, 0x00, 0x00],   # 16
</span><span class="inferred0"><a name="line507"></a> 507          [0x00, 0x80, 0x00, 0x00],   # 17
</span><span class="inferred1"><a name="line508"></a> 508          [0x00, 0x00, 0x80, 0x00],   # 18
</span><span class="inferred0"><a name="line509"></a> 509          [0x80, 0x80, 0x00, 0x00],   # 19
</span><span class="inferred1"><a name="line510"></a> 510          [0x80, 0x00, 0x80, 0x00],   # 20
</span><span class="inferred0"><a name="line511"></a> 511          [0x00, 0x80, 0x80, 0x00],   # 21
</span><span class="inferred1"><a name="line512"></a> 512          [0xc0, 0xc0, 0xc0, 0x00],   # 22
</span><span class="inferred0"><a name="line513"></a> 513          [0x80, 0x80, 0x80, 0x00],   # 23
</span><span class="inferred1"><a name="line514"></a> 514          [0x99, 0x99, 0xff, 0x00],   # 24
</span><span class="inferred0"><a name="line515"></a> 515          [0x99, 0x33, 0x66, 0x00],   # 25
</span><span class="inferred1"><a name="line516"></a> 516          [0xff, 0xff, 0xcc, 0x00],   # 26
</span><span class="inferred0"><a name="line517"></a> 517          [0xcc, 0xff, 0xff, 0x00],   # 27
</span><span class="inferred1"><a name="line518"></a> 518          [0x66, 0x00, 0x66, 0x00],   # 28
</span><span class="inferred0"><a name="line519"></a> 519          [0xff, 0x80, 0x80, 0x00],   # 29
</span><span class="inferred1"><a name="line520"></a> 520          [0x00, 0x66, 0xcc, 0x00],   # 30
</span><span class="inferred0"><a name="line521"></a> 521          [0xcc, 0xcc, 0xff, 0x00],   # 31
</span><span class="inferred1"><a name="line522"></a> 522          [0x00, 0x00, 0x80, 0x00],   # 32
</span><span class="inferred0"><a name="line523"></a> 523          [0xff, 0x00, 0xff, 0x00],   # 33
</span><span class="inferred1"><a name="line524"></a> 524          [0xff, 0xff, 0x00, 0x00],   # 34
</span><span class="inferred0"><a name="line525"></a> 525          [0x00, 0xff, 0xff, 0x00],   # 35
</span><span class="inferred1"><a name="line526"></a> 526          [0x80, 0x00, 0x80, 0x00],   # 36
</span><span class="inferred0"><a name="line527"></a> 527          [0x80, 0x00, 0x00, 0x00],   # 37
</span><span class="inferred1"><a name="line528"></a> 528          [0x00, 0x80, 0x80, 0x00],   # 38
</span><span class="inferred0"><a name="line529"></a> 529          [0x00, 0x00, 0xff, 0x00],   # 39
</span><span class="inferred1"><a name="line530"></a> 530          [0x00, 0xcc, 0xff, 0x00],   # 40
</span><span class="inferred0"><a name="line531"></a> 531          [0xcc, 0xff, 0xff, 0x00],   # 41
</span><span class="inferred1"><a name="line532"></a> 532          [0xcc, 0xff, 0xcc, 0x00],   # 42
</span><span class="inferred0"><a name="line533"></a> 533          [0xff, 0xff, 0x99, 0x00],   # 43
</span><span class="inferred1"><a name="line534"></a> 534          [0x99, 0xcc, 0xff, 0x00],   # 44
</span><span class="inferred0"><a name="line535"></a> 535          [0xff, 0x99, 0xcc, 0x00],   # 45
</span><span class="inferred1"><a name="line536"></a> 536          [0xcc, 0x99, 0xff, 0x00],   # 46
</span><span class="inferred0"><a name="line537"></a> 537          [0xff, 0xcc, 0x99, 0x00],   # 47
</span><span class="inferred1"><a name="line538"></a> 538          [0x33, 0x66, 0xff, 0x00],   # 48
</span><span class="inferred0"><a name="line539"></a> 539          [0x33, 0xcc, 0xcc, 0x00],   # 49
</span><span class="inferred1"><a name="line540"></a> 540          [0x99, 0xcc, 0x00, 0x00],   # 50
</span><span class="inferred0"><a name="line541"></a> 541          [0xff, 0xcc, 0x00, 0x00],   # 51
</span><span class="inferred1"><a name="line542"></a> 542          [0xff, 0x99, 0x00, 0x00],   # 52
</span><span class="inferred0"><a name="line543"></a> 543          [0xff, 0x66, 0x00, 0x00],   # 53
</span><span class="inferred1"><a name="line544"></a> 544          [0x66, 0x66, 0x99, 0x00],   # 54
</span><span class="inferred0"><a name="line545"></a> 545          [0x96, 0x96, 0x96, 0x00],   # 55
</span><span class="inferred1"><a name="line546"></a> 546          [0x00, 0x33, 0x66, 0x00],   # 56
</span><span class="inferred0"><a name="line547"></a> 547          [0x33, 0x99, 0x66, 0x00],   # 57
</span><span class="inferred1"><a name="line548"></a> 548          [0x00, 0x33, 0x00, 0x00],   # 58
</span><span class="inferred0"><a name="line549"></a> 549          [0x33, 0x33, 0x00, 0x00],   # 59
</span><span class="inferred1"><a name="line550"></a> 550          [0x99, 0x33, 0x00, 0x00],   # 60
</span><span class="inferred0"><a name="line551"></a> 551          [0x99, 0x33, 0x66, 0x00],   # 61
</span><span class="inferred1"><a name="line552"></a> 552          [0x33, 0x33, 0x99, 0x00],   # 62
</span><span class="inferred0"><a name="line553"></a> 553          [0x33, 0x33, 0x33, 0x00]    # 63
</span><span class="inferred1"><a name="line554"></a> 554      ]
</span><span class="marked0"><a name="line555"></a> 555      return 0
</span><span class="inferred1"><a name="line556"></a> 556    end
</span><span class="inferred0"><a name="line557"></a> 557 
</span><span class="inferred1"><a name="line558"></a> 558    ###############################################################################
</span><span class="inferred0"><a name="line559"></a> 559    #
</span><span class="inferred1"><a name="line560"></a> 560    # set_tempdir()
</span><span class="inferred0"><a name="line561"></a> 561    #
</span><span class="inferred1"><a name="line562"></a> 562    # Change the default temp directory used by _initialize() in Worksheet.pm.
</span><span class="inferred0"><a name="line563"></a> 563    #
</span><span class="marked1"><a name="line564"></a> 564    def set_tempdir(dir = '')
</span><span class="marked0"><a name="line565"></a> 565       raise &quot;#{dir} is not a valid directory&quot; if dir != '' &amp;&amp; !FileTest.directory?(dir)
</span><span class="marked1"><a name="line566"></a> 566       raise &quot;set_tempdir must be called before add_worksheet&quot; unless sheets.empty?
</span><span class="uncovered0"><a name="line567"></a> 567 
</span><span class="uncovered1"><a name="line568"></a> 568       @tempdir = dir
</span><span class="uncovered0"><a name="line569"></a> 569    end
</span><span class="inferred1"><a name="line570"></a> 570 
</span><span class="inferred0"><a name="line571"></a> 571    ###############################################################################
</span><span class="inferred1"><a name="line572"></a> 572    #
</span><span class="inferred0"><a name="line573"></a> 573    # set_codepage()
</span><span class="inferred1"><a name="line574"></a> 574    #
</span><span class="inferred0"><a name="line575"></a> 575    # See also the _store_codepage method. This is used to store the code page, i.e.
</span><span class="inferred1"><a name="line576"></a> 576    # the character set used in the workbook.
</span><span class="inferred0"><a name="line577"></a> 577    #
</span><span class="marked1"><a name="line578"></a> 578    def set_codepage(type = 1)
</span><span class="uncovered0"><a name="line579"></a> 579       if type == 2
</span><span class="uncovered1"><a name="line580"></a> 580          @codepage = 0x8000
</span><span class="uncovered0"><a name="line581"></a> 581       else
</span><span class="uncovered1"><a name="line582"></a> 582          @codepage = 0x04E4
</span><span class="uncovered0"><a name="line583"></a> 583       end
</span><span class="uncovered1"><a name="line584"></a> 584    end
</span><span class="inferred0"><a name="line585"></a> 585 
</span><span class="inferred1"><a name="line586"></a> 586    ###############################################################################
</span><span class="inferred0"><a name="line587"></a> 587    #
</span><span class="inferred1"><a name="line588"></a> 588    # set_properties()
</span><span class="inferred0"><a name="line589"></a> 589    #
</span><span class="inferred1"><a name="line590"></a> 590    # Set the document properties such as Title, Author etc. These are written to
</span><span class="inferred0"><a name="line591"></a> 591    # property sets in the OLE container.
</span><span class="inferred1"><a name="line592"></a> 592    #
</span><span class="marked0"><a name="line593"></a> 593    def set_properties(*args)
</span><span class="uncovered1"><a name="line594"></a> 594       # Ignore if no args were passed.
</span><span class="uncovered0"><a name="line595"></a> 595       return -1 unless args.size == 0
</span><span class="uncovered1"><a name="line596"></a> 596 
</span><span class="uncovered0"><a name="line597"></a> 597       # Allow the parameters to be passed as a hash or hash ref.
</span><span class="uncovered1"><a name="line598"></a> 598       param = args[0].kind_of?(Hash) ? args[0] : Hash[*args]
</span><span class="uncovered0"><a name="line599"></a> 599 
</span><span class="uncovered1"><a name="line600"></a> 600       # List of valid input parameters.
</span><span class="uncovered0"><a name="line601"></a> 601       properties = {
</span><span class="uncovered1"><a name="line602"></a> 602                              :codepage      =&gt; [0x0001, 'VT_I2'      ],
</span><span class="uncovered0"><a name="line603"></a> 603                              :title         =&gt; [0x0002, 'VT_LPSTR'   ],
</span><span class="uncovered1"><a name="line604"></a> 604                              :subject       =&gt; [0x0003, 'VT_LPSTR'   ],
</span><span class="uncovered0"><a name="line605"></a> 605                              :author        =&gt; [0x0004, 'VT_LPSTR'   ],
</span><span class="uncovered1"><a name="line606"></a> 606                              :keywords      =&gt; [0x0005, 'VT_LPSTR'   ],
</span><span class="uncovered0"><a name="line607"></a> 607                              :comments      =&gt; [0x0006, 'VT_LPSTR'   ],
</span><span class="uncovered1"><a name="line608"></a> 608                              :last_author   =&gt; [0x0008, 'VT_LPSTR'   ],
</span><span class="uncovered0"><a name="line609"></a> 609                              :created       =&gt; [0x000C, 'VT_FILETIME'],
</span><span class="uncovered1"><a name="line610"></a> 610                              :category      =&gt; [0x0002, 'VT_LPSTR'   ],
</span><span class="uncovered0"><a name="line611"></a> 611                              :manager       =&gt; [0x000E, 'VT_LPSTR'   ],
</span><span class="uncovered1"><a name="line612"></a> 612                              :company       =&gt; [0x000F, 'VT_LPSTR'   ],
</span><span class="uncovered0"><a name="line613"></a> 613                              :utf8          =&gt; 1
</span><span class="uncovered1"><a name="line614"></a> 614                   }
</span><span class="uncovered0"><a name="line615"></a> 615 
</span><span class="uncovered1"><a name="line616"></a> 616       # Check for valid input parameters.
</span><span class="uncovered0"><a name="line617"></a> 617       param.each_key do |k|
</span><span class="uncovered1"><a name="line618"></a> 618          unless properties.has_key?(k)
</span><span class="uncovered0"><a name="line619"></a> 619             raise &quot;Unknown parameter '#{k}' in set_properties()&quot;;
</span><span class="uncovered1"><a name="line620"></a> 620          end
</span><span class="uncovered0"><a name="line621"></a> 621       end
</span><span class="uncovered1"><a name="line622"></a> 622 
</span><span class="uncovered0"><a name="line623"></a> 623       # Set the creation time unless specified by the user.
</span><span class="uncovered1"><a name="line624"></a> 624       unless param.has_key(:created)
</span><span class="uncovered0"><a name="line625"></a> 625          param[:created] = @localtime
</span><span class="uncovered1"><a name="line626"></a> 626       end
</span><span class="uncovered0"><a name="line627"></a> 627 
</span><span class="uncovered1"><a name="line628"></a> 628       #
</span><span class="uncovered0"><a name="line629"></a> 629       # Create the SummaryInformation property set.
</span><span class="uncovered1"><a name="line630"></a> 630       #
</span><span class="uncovered0"><a name="line631"></a> 631 
</span><span class="uncovered1"><a name="line632"></a> 632       # Get the codepage of the strings in the property set.
</span><span class="uncovered0"><a name="line633"></a> 633       strings = [&quot;title&quot;, &quot;subject&quot;, &quot;author&quot;, &quot;keywords&quot;,  &quot;comments&quot;, &quot;last_author&quot;]
</span><span class="uncovered1"><a name="line634"></a> 634       param[:codepage] = get_property_set_codepage(param, strings)
</span><span class="uncovered0"><a name="line635"></a> 635 
</span><span class="uncovered1"><a name="line636"></a> 636       # Create an array of property set values.
</span><span class="uncovered0"><a name="line637"></a> 637       property_sets = []
</span><span class="uncovered1"><a name="line638"></a> 638       strings.unshift(&quot;codepage&quot;)
</span><span class="uncovered0"><a name="line639"></a> 639       strings.push(&quot;created&quot;)
</span><span class="uncovered1"><a name="line640"></a> 640       strings.each do |property|
</span><span class="uncovered0"><a name="line641"></a> 641          if param.has_key?(property) &amp;&amp; !param[property].nil?
</span><span class="uncovered1"><a name="line642"></a> 642             property_sets.push(
</span><span class="uncovered0"><a name="line643"></a> 643                [ properties[property][0],
</span><span class="uncovered1"><a name="line644"></a> 644                  properties[property][1],
</span><span class="uncovered0"><a name="line645"></a> 645                   param[property]  ]
</span><span class="uncovered1"><a name="line646"></a> 646                )
</span><span class="uncovered0"><a name="line647"></a> 647          end
</span><span class="uncovered1"><a name="line648"></a> 648       end
</span><span class="uncovered0"><a name="line649"></a> 649 
</span><span class="uncovered1"><a name="line650"></a> 650       # Pack the property sets.
</span><span class="uncovered0"><a name="line651"></a> 651       @summary = create_summary_property_set(property_sets)
</span><span class="uncovered1"><a name="line652"></a> 652 
</span><span class="uncovered0"><a name="line653"></a> 653       #
</span><span class="uncovered1"><a name="line654"></a> 654       # Create the DocSummaryInformation property set.
</span><span class="uncovered0"><a name="line655"></a> 655       #
</span><span class="uncovered1"><a name="line656"></a> 656 
</span><span class="uncovered0"><a name="line657"></a> 657       # Get the codepage of the strings in the property set.
</span><span class="uncovered1"><a name="line658"></a> 658       strings = [&quot;category&quot;, &quot;manager&quot;, &quot;company&quot;]
</span><span class="uncovered0"><a name="line659"></a> 659       param[:codepage] = get_property_set_codepage(param, strings)
</span><span class="uncovered1"><a name="line660"></a> 660 
</span><span class="uncovered0"><a name="line661"></a> 661       # Create an array of property set values.
</span><span class="uncovered1"><a name="line662"></a> 662       property_sets = []
</span><span class="uncovered0"><a name="line663"></a> 663 
</span><span class="uncovered1"><a name="line664"></a> 664       [&quot;codepage&quot;, &quot;category&quot;, &quot;manager&quot;, &quot;company&quot;].each do |property|
</span><span class="uncovered0"><a name="line665"></a> 665          if param.has_key?(property) &amp;&amp; !param[property].nil?
</span><span class="uncovered1"><a name="line666"></a> 666             property_sets.push(
</span><span class="uncovered0"><a name="line667"></a> 667                [ properties[property][0],
</span><span class="uncovered1"><a name="line668"></a> 668                  properties[property][1],
</span><span class="uncovered0"><a name="line669"></a> 669                  param[property]  ]
</span><span class="uncovered1"><a name="line670"></a> 670                )
</span><span class="uncovered0"><a name="line671"></a> 671          end
</span><span class="uncovered1"><a name="line672"></a> 672       end
</span><span class="uncovered0"><a name="line673"></a> 673 
</span><span class="uncovered1"><a name="line674"></a> 674       # Pack the property sets.
</span><span class="uncovered0"><a name="line675"></a> 675       @doc_summary = create_doc_summary_property_set(property_sets)
</span><span class="uncovered1"><a name="line676"></a> 676 
</span><span class="uncovered0"><a name="line677"></a> 677       # Set a flag for when the files is written.
</span><span class="uncovered1"><a name="line678"></a> 678       @add_doc_properties = 1
</span><span class="uncovered0"><a name="line679"></a> 679    end
</span><span class="inferred1"><a name="line680"></a> 680 
</span><span class="inferred0"><a name="line681"></a> 681    ###############################################################################
</span><span class="inferred1"><a name="line682"></a> 682    #
</span><span class="inferred0"><a name="line683"></a> 683    # _get_property_set_codepage()
</span><span class="inferred1"><a name="line684"></a> 684    #
</span><span class="inferred0"><a name="line685"></a> 685    # Get the character codepage used by the strings in a property set. If one of
</span><span class="inferred1"><a name="line686"></a> 686    # the strings used is utf8 then the codepage is marked as utf8. Otherwise
</span><span class="inferred0"><a name="line687"></a> 687    # Latin 1 is used (although in our case this is limited to 7bit ASCII).
</span><span class="inferred1"><a name="line688"></a> 688    #
</span><span class="marked0"><a name="line689"></a> 689    def get_property_set_codepage(params, strings)
</span><span class="uncovered1"><a name="line690"></a> 690       # Allow for manually marked utf8 strings.
</span><span class="uncovered0"><a name="line691"></a> 691       unless params[utf8].nil?
</span><span class="uncovered1"><a name="line692"></a> 692          return 0xFDE9
</span><span class="uncovered0"><a name="line693"></a> 693       else
</span><span class="uncovered1"><a name="line694"></a> 694          return 0x04E4; # Default codepage, Latin 1.
</span><span class="uncovered0"><a name="line695"></a> 695       end
</span><span class="uncovered1"><a name="line696"></a> 696    end
</span><span class="inferred0"><a name="line697"></a> 697 
</span><span class="inferred1"><a name="line698"></a> 698    ###############################################################################
</span><span class="inferred0"><a name="line699"></a> 699    #
</span><span class="inferred1"><a name="line700"></a> 700    # _store_workbook()
</span><span class="inferred0"><a name="line701"></a> 701    #
</span><span class="inferred1"><a name="line702"></a> 702    # Assemble worksheets into a workbook and send the BIFF data to an OLE
</span><span class="inferred0"><a name="line703"></a> 703    # storage.
</span><span class="inferred1"><a name="line704"></a> 704    #
</span><span class="marked0"><a name="line705"></a> 705    def store_workbook
</span><span class="uncovered1"><a name="line706"></a> 706       # Add a default worksheet if non have been added.
</span><span class="uncovered0"><a name="line707"></a> 707       add_worksheet if @worksheets.size == 0
</span><span class="uncovered1"><a name="line708"></a> 708 
</span><span class="uncovered0"><a name="line709"></a> 709       # Calculate size required for MSO records and update worksheets.
</span><span class="uncovered1"><a name="line710"></a> 710       calc_mso_sizes
</span><span class="uncovered0"><a name="line711"></a> 711 
</span><span class="uncovered1"><a name="line712"></a> 712       # Ensure that at least one worksheet has been selected.
</span><span class="uncovered0"><a name="line713"></a> 713       if @activesheet == 0
</span><span class="uncovered1"><a name="line714"></a> 714          @worksheets[0].selected = 1
</span><span class="uncovered0"><a name="line715"></a> 715          @worksheets[0].hidden   = 0
</span><span class="uncovered1"><a name="line716"></a> 716       end
</span><span class="uncovered0"><a name="line717"></a> 717    
</span><span class="uncovered1"><a name="line718"></a> 718       # Calculate the number of selected worksheet tabs and call the finalization
</span><span class="uncovered0"><a name="line719"></a> 719       # methods for each worksheet
</span><span class="uncovered1"><a name="line720"></a> 720       @worksheets.each do |sheet|
</span><span class="uncovered0"><a name="line721"></a> 721          @selected    += 1 if sheet.selected != 0
</span><span class="uncovered1"><a name="line722"></a> 722          sheet.active  = 1 if sheet.index == @activesheet
</span><span class="uncovered0"><a name="line723"></a> 723       end
</span><span class="uncovered1"><a name="line724"></a> 724    
</span><span class="uncovered0"><a name="line725"></a> 725       # Add Workbook globals
</span><span class="uncovered1"><a name="line726"></a> 726       store_bof(0x0005)
</span><span class="uncovered0"><a name="line727"></a> 727       store_codepage()
</span><span class="uncovered1"><a name="line728"></a> 728       store_window1()
</span><span class="uncovered0"><a name="line729"></a> 729       store_hideobj()
</span><span class="uncovered1"><a name="line730"></a> 730       store_1904()
</span><span class="uncovered0"><a name="line731"></a> 731       store_all_fonts()
</span><span class="uncovered1"><a name="line732"></a> 732       store_all_num_formats()
</span><span class="uncovered0"><a name="line733"></a> 733       store_all_xfs()
</span><span class="uncovered1"><a name="line734"></a> 734       store_all_styles()
</span><span class="uncovered0"><a name="line735"></a> 735       store_palette()
</span><span class="uncovered1"><a name="line736"></a> 736    
</span><span class="uncovered0"><a name="line737"></a> 737       # Calculate the offsets required by the BOUNDSHEET records
</span><span class="uncovered1"><a name="line738"></a> 738       calc_sheet_offsets()
</span><span class="uncovered0"><a name="line739"></a> 739    
</span><span class="uncovered1"><a name="line740"></a> 740       # Add BOUNDSHEET records.
</span><span class="uncovered0"><a name="line741"></a> 741       @worksheets.each do |sheet|
</span><span class="uncovered1"><a name="line742"></a> 742          store_boundsheet(sheet.name,
</span><span class="uncovered0"><a name="line743"></a> 743                           sheet.offset,
</span><span class="uncovered1"><a name="line744"></a> 744                           sheet.type,
</span><span class="uncovered0"><a name="line745"></a> 745                           sheet.hidden,
</span><span class="uncovered1"><a name="line746"></a> 746                           sheet.encoding)
</span><span class="uncovered0"><a name="line747"></a> 747       end
</span><span class="uncovered1"><a name="line748"></a> 748    
</span><span class="uncovered0"><a name="line749"></a> 749       # NOTE: If any records are added between here and EOF the
</span><span class="uncovered1"><a name="line750"></a> 750       # _calc_sheet_offsets() should be updated to include the new length.
</span><span class="uncovered0"><a name="line751"></a> 751       store_country()
</span><span class="uncovered1"><a name="line752"></a> 752       if @ext_ref_count != 0
</span><span class="uncovered0"><a name="line753"></a> 753          store_supbook
</span><span class="uncovered1"><a name="line754"></a> 754          store_externsheet
</span><span class="uncovered0"><a name="line755"></a> 755          store_names
</span><span class="uncovered1"><a name="line756"></a> 756       end
</span><span class="uncovered0"><a name="line757"></a> 757       add_mso_drawing_group
</span><span class="uncovered1"><a name="line758"></a> 758       store_shared_strings
</span><span class="uncovered0"><a name="line759"></a> 759       store_extsst
</span><span class="uncovered1"><a name="line760"></a> 760    
</span><span class="uncovered0"><a name="line761"></a> 761       # End Workbook globals
</span><span class="uncovered1"><a name="line762"></a> 762       store_eof
</span><span class="uncovered0"><a name="line763"></a> 763    
</span><span class="uncovered1"><a name="line764"></a> 764       # Store the workbook in an OLE container
</span><span class="uncovered0"><a name="line765"></a> 765       return store_OLE_file
</span><span class="uncovered1"><a name="line766"></a> 766    end
</span><span class="inferred0"><a name="line767"></a> 767 
</span><span class="inferred1"><a name="line768"></a> 768    ###############################################################################
</span><span class="inferred0"><a name="line769"></a> 769    #
</span><span class="inferred1"><a name="line770"></a> 770    # _store_OLE_file()
</span><span class="inferred0"><a name="line771"></a> 771    #
</span><span class="inferred1"><a name="line772"></a> 772    # Store the workbook in an OLE container using the default handler or using
</span><span class="inferred0"><a name="line773"></a> 773    # OLE::Storage_Lite if the workbook data is &gt; ~ 7MB.
</span><span class="inferred1"><a name="line774"></a> 774    #
</span><span class="marked0"><a name="line775"></a> 775    def store_OLE_file
</span><span class="uncovered1"><a name="line776"></a> 776       maxsize = 7087104
</span><span class="uncovered0"><a name="line777"></a> 777    
</span><span class="uncovered1"><a name="line778"></a> 778       if @add_doc_properties == 0 &amp;&amp; @biffsize &lt;= maxsize
</span><span class="uncovered0"><a name="line779"></a> 779          # Write the OLE file using OLEwriter if data &lt;= 7MB
</span><span class="uncovered1"><a name="line780"></a> 780          ole  = OLEwriter.new(@fh_out)
</span><span class="uncovered0"><a name="line781"></a> 781    
</span><span class="uncovered1"><a name="line782"></a> 782          # Write the BIFF data without the OLE container for testing.
</span><span class="uncovered0"><a name="line783"></a> 783          ole.biff_only = @biff_only
</span><span class="uncovered1"><a name="line784"></a> 784    
</span><span class="uncovered0"><a name="line785"></a> 785          # Indicate that we created the filehandle and want to close it.
</span><span class="uncovered1"><a name="line786"></a> 786          ole.internal_fh = @internal_fh
</span><span class="uncovered0"><a name="line787"></a> 787    
</span><span class="uncovered1"><a name="line788"></a> 788          ole.set_size(@biffsize)
</span><span class="uncovered0"><a name="line789"></a> 789          ole.write_header
</span><span class="uncovered1"><a name="line790"></a> 790    
</span><span class="uncovered0"><a name="line791"></a> 791          while tmp = get_data
</span><span class="uncovered1"><a name="line792"></a> 792             ole.write(tmp)
</span><span class="uncovered0"><a name="line793"></a> 793          end
</span><span class="uncovered1"><a name="line794"></a> 794    
</span><span class="uncovered0"><a name="line795"></a> 795          @worksheets.each do |worksheet|
</span><span class="uncovered1"><a name="line796"></a> 796             while tmp = worksheet.get_data
</span><span class="uncovered0"><a name="line797"></a> 797                 ole.write(tmp)
</span><span class="uncovered1"><a name="line798"></a> 798             end
</span><span class="uncovered0"><a name="line799"></a> 799          end
</span><span class="uncovered1"><a name="line800"></a> 800    
</span><span class="uncovered0"><a name="line801"></a> 801          return ole.close
</span><span class="uncovered1"><a name="line802"></a> 802 =begin
</span><span class="uncovered0"><a name="line803"></a> 803       else
</span><span class="uncovered1"><a name="line804"></a> 804          # Write the OLE file using OLE::Storage_Lite if data &gt; 7MB
</span><span class="uncovered0"><a name="line805"></a> 805          eval { require OLE::Storage_Lite };
</span><span class="uncovered1"><a name="line806"></a> 806    
</span><span class="uncovered0"><a name="line807"></a> 807          if (not $@) {
</span><span class="uncovered1"><a name="line808"></a> 808    
</span><span class="uncovered0"><a name="line809"></a> 809             # Protect print() from -l on the command line.
</span><span class="uncovered1"><a name="line810"></a> 810             local $\ = undef;
</span><span class="uncovered0"><a name="line811"></a> 811    
</span><span class="uncovered1"><a name="line812"></a> 812             my @streams;
</span><span class="uncovered0"><a name="line813"></a> 813    
</span><span class="uncovered1"><a name="line814"></a> 814             # Create the Workbook stream.
</span><span class="uncovered0"><a name="line815"></a> 815             my $stream   = pack 'v*', unpack 'C*', 'Workbook';
</span><span class="uncovered1"><a name="line816"></a> 816             my $workbook = OLE::Storage_Lite::PPS::File-&gt;newFile($stream);
</span><span class="uncovered0"><a name="line817"></a> 817    
</span><span class="uncovered1"><a name="line818"></a> 818             while (my $tmp = $self-&gt;get_data()) {
</span><span class="uncovered0"><a name="line819"></a> 819                $workbook-&gt;append($tmp);
</span><span class="uncovered1"><a name="line820"></a> 820             }
</span><span class="uncovered0"><a name="line821"></a> 821    
</span><span class="uncovered1"><a name="line822"></a> 822             foreach my $worksheet (@{$self-&gt;{_worksheets}}) {
</span><span class="uncovered0"><a name="line823"></a> 823                while (my $tmp = $worksheet-&gt;get_data()) {
</span><span class="uncovered1"><a name="line824"></a> 824                     $workbook-&gt;append($tmp);
</span><span class="uncovered0"><a name="line825"></a> 825                }
</span><span class="uncovered1"><a name="line826"></a> 826             }
</span><span class="uncovered0"><a name="line827"></a> 827    
</span><span class="uncovered1"><a name="line828"></a> 828             push @streams, $workbook;
</span><span class="uncovered0"><a name="line829"></a> 829    
</span><span class="uncovered1"><a name="line830"></a> 830    
</span><span class="uncovered0"><a name="line831"></a> 831             # Create the properties streams, if any.
</span><span class="uncovered1"><a name="line832"></a> 832             if ($self-&gt;{_add_doc_properties}) {
</span><span class="uncovered0"><a name="line833"></a> 833                my $stream;
</span><span class="uncovered1"><a name="line834"></a> 834                my $summary;
</span><span class="uncovered0"><a name="line835"></a> 835    
</span><span class="uncovered1"><a name="line836"></a> 836                $stream  = pack 'v*', unpack 'C*', &quot;\5SummaryInformation&quot;;
</span><span class="uncovered0"><a name="line837"></a> 837                $summary = $self-&gt;{summary};
</span><span class="uncovered1"><a name="line838"></a> 838                $summary = OLE::Storage_Lite::PPS::File-&gt;new($stream, $summary);
</span><span class="uncovered0"><a name="line839"></a> 839                push @streams, $summary;
</span><span class="uncovered1"><a name="line840"></a> 840    
</span><span class="uncovered0"><a name="line841"></a> 841                $stream  = pack 'v*', unpack 'C*', &quot;\5DocumentSummaryInformation&quot;;
</span><span class="uncovered1"><a name="line842"></a> 842                $summary = $self-&gt;{doc_summary};
</span><span class="uncovered0"><a name="line843"></a> 843                $summary = OLE::Storage_Lite::PPS::File-&gt;new($stream, $summary);
</span><span class="uncovered1"><a name="line844"></a> 844                push @streams, $summary;
</span><span class="uncovered0"><a name="line845"></a> 845             }
</span><span class="uncovered1"><a name="line846"></a> 846    
</span><span class="uncovered0"><a name="line847"></a> 847             # Create the OLE root document and add the substreams.
</span><span class="uncovered1"><a name="line848"></a> 848             my @localtime = @{ $self-&gt;{_localtime} };
</span><span class="uncovered0"><a name="line849"></a> 849             splice(@localtime, 6);
</span><span class="uncovered1"><a name="line850"></a> 850    
</span><span class="uncovered0"><a name="line851"></a> 851             my $ole_root = OLE::Storage_Lite::PPS::Root-&gt;new(\@localtime,
</span><span class="uncovered1"><a name="line852"></a> 852                                                                 \@localtime,
</span><span class="uncovered0"><a name="line853"></a> 853                                                                 \@streams);
</span><span class="uncovered1"><a name="line854"></a> 854             $ole_root-&gt;save($self-&gt;{_filename});
</span><span class="uncovered0"><a name="line855"></a> 855    
</span><span class="uncovered1"><a name="line856"></a> 856    
</span><span class="uncovered0"><a name="line857"></a> 857             # Close the filehandle if it was created internally.
</span><span class="uncovered1"><a name="line858"></a> 858             return CORE::close($self-&gt;{_fh_out}) if $self-&gt;{_internal_fh};
</span><span class="uncovered0"><a name="line859"></a> 859          }
</span><span class="uncovered1"><a name="line860"></a> 860          else {
</span><span class="uncovered0"><a name="line861"></a> 861             # File in greater than limit, set $! to &quot;File too large&quot;
</span><span class="uncovered1"><a name="line862"></a> 862             $! = 27; # Perl error code &quot;File too large&quot;
</span><span class="uncovered0"><a name="line863"></a> 863    
</span><span class="uncovered1"><a name="line864"></a> 864             croak &quot;Maximum Spreadsheet::WriteExcel filesize, $maxsize bytes, &quot;.
</span><span class="uncovered0"><a name="line865"></a> 865                   &quot;exceeded. To create files bigger than this limit please &quot;  .
</span><span class="uncovered1"><a name="line866"></a> 866                   &quot;install OLE::Storage_Lite\n&quot;;
</span><span class="uncovered0"><a name="line867"></a> 867    
</span><span class="uncovered1"><a name="line868"></a> 868             # return 0;
</span><span class="uncovered0"><a name="line869"></a> 869          }
</span><span class="uncovered1"><a name="line870"></a> 870 =end
</span><span class="uncovered0"><a name="line871"></a> 871       end
</span><span class="uncovered1"><a name="line872"></a> 872    end
</span><span class="inferred0"><a name="line873"></a> 873 
</span><span class="inferred1"><a name="line874"></a> 874    ###############################################################################
</span><span class="inferred0"><a name="line875"></a> 875    #
</span><span class="inferred1"><a name="line876"></a> 876    # _calc_sheet_offsets()
</span><span class="inferred0"><a name="line877"></a> 877    #
</span><span class="inferred1"><a name="line878"></a> 878    # Calculate Worksheet BOF offsets records for use in the BOUNDSHEET records.
</span><span class="inferred0"><a name="line879"></a> 879    #
</span><span class="marked1"><a name="line880"></a> 880    def calc_sheet_offsets
</span><span class="uncovered0"><a name="line881"></a> 881       _bof     = 12
</span><span class="uncovered1"><a name="line882"></a> 882       _eof     = 4
</span><span class="uncovered0"><a name="line883"></a> 883       offset  = @datasize
</span><span class="uncovered1"><a name="line884"></a> 884    
</span><span class="uncovered0"><a name="line885"></a> 885       # Add the length of the COUNTRY record
</span><span class="uncovered1"><a name="line886"></a> 886       offset += 8
</span><span class="uncovered0"><a name="line887"></a> 887    
</span><span class="uncovered1"><a name="line888"></a> 888       # Add the length of the SST and associated CONTINUEs
</span><span class="uncovered0"><a name="line889"></a> 889       offset += calculate_shared_string_sizes
</span><span class="uncovered1"><a name="line890"></a> 890    
</span><span class="uncovered0"><a name="line891"></a> 891       # Add the length of the EXTSST record.
</span><span class="uncovered1"><a name="line892"></a> 892       offset += calculate_extsst_size
</span><span class="uncovered0"><a name="line893"></a> 893    
</span><span class="uncovered1"><a name="line894"></a> 894       # Add the length of the SUPBOOK, EXTERNSHEET and NAME records
</span><span class="uncovered0"><a name="line895"></a> 895       offset += calculate_extern_sizes
</span><span class="uncovered1"><a name="line896"></a> 896    
</span><span class="uncovered0"><a name="line897"></a> 897       # Add the length of the MSODRAWINGGROUP records including an extra 4 bytes
</span><span class="uncovered1"><a name="line898"></a> 898       # for any CONTINUE headers. See _add_mso_drawing_group_continue().
</span><span class="uncovered0"><a name="line899"></a> 899       mso_size = @mso_size
</span><span class="uncovered1"><a name="line900"></a> 900       mso_size += 4 * Integer((mso_size -1) / Float(@limit))
</span><span class="uncovered0"><a name="line901"></a> 901       offset   += mso_size
</span><span class="uncovered1"><a name="line902"></a> 902    
</span><span class="uncovered0"><a name="line903"></a> 903       @worksheets.each do |sheet|
</span><span class="uncovered1"><a name="line904"></a> 904          offset += _bof + sheet.name.length
</span><span class="uncovered0"><a name="line905"></a> 905       end
</span><span class="uncovered1"><a name="line906"></a> 906    
</span><span class="uncovered0"><a name="line907"></a> 907       offset += _eof
</span><span class="uncovered1"><a name="line908"></a> 908    
</span><span class="uncovered0"><a name="line909"></a> 909       @worksheets.each do |sheet|
</span><span class="uncovered1"><a name="line910"></a> 910          sheet.offset = offset
</span><span class="uncovered0"><a name="line911"></a> 911          sheet.close(@sheetnames)
</span><span class="uncovered1"><a name="line912"></a> 912          offset += sheet.datasize
</span><span class="uncovered0"><a name="line913"></a> 913       end
</span><span class="uncovered1"><a name="line914"></a> 914    
</span><span class="uncovered0"><a name="line915"></a> 915       @biffsize = offset
</span><span class="uncovered1"><a name="line916"></a> 916    end
</span><span class="inferred0"><a name="line917"></a> 917 
</span><span class="inferred1"><a name="line918"></a> 918    ###############################################################################
</span><span class="inferred0"><a name="line919"></a> 919    #
</span><span class="inferred1"><a name="line920"></a> 920    # _calc_mso_sizes()
</span><span class="inferred0"><a name="line921"></a> 921    #
</span><span class="inferred1"><a name="line922"></a> 922    # Calculate the MSODRAWINGGROUP sizes and the indexes of the Worksheet
</span><span class="inferred0"><a name="line923"></a> 923    # MSODRAWING records.
</span><span class="inferred1"><a name="line924"></a> 924    #
</span><span class="inferred0"><a name="line925"></a> 925    # In the following SPID is shape id, according to Escher nomenclature.
</span><span class="inferred1"><a name="line926"></a> 926    #
</span><span class="marked0"><a name="line927"></a> 927    def calc_mso_sizes
</span><span class="uncovered1"><a name="line928"></a> 928        mso_size        = 0    # Size of the MSODRAWINGGROUP record
</span><span class="uncovered0"><a name="line929"></a> 929        start_spid      = 1024 # Initial spid for each sheet
</span><span class="uncovered1"><a name="line930"></a> 930        max_spid        = 1024 # spidMax
</span><span class="uncovered0"><a name="line931"></a> 931        num_clusters    = 1    # cidcl
</span><span class="uncovered1"><a name="line932"></a> 932        shapes_saved    = 0    # cspSaved
</span><span class="uncovered0"><a name="line933"></a> 933        drawings_saved  = 0    # cdgSaved
</span><span class="uncovered1"><a name="line934"></a> 934        clusters        = []
</span><span class="uncovered0"><a name="line935"></a> 935    
</span><span class="uncovered1"><a name="line936"></a> 936        process_images
</span><span class="uncovered0"><a name="line937"></a> 937    
</span><span class="uncovered1"><a name="line938"></a> 938        # Add Bstore container size if there are images.
</span><span class="uncovered0"><a name="line939"></a> 939        mso_size += 8 unless @images_data.nil?
</span><span class="uncovered1"><a name="line940"></a> 940    
</span><span class="uncovered0"><a name="line941"></a> 941        # Iterate through the worksheets, calculate the MSODRAWINGGROUP parameters
</span><span class="uncovered1"><a name="line942"></a> 942        # and space required to store the record and the MSODRAWING parameters
</span><span class="uncovered0"><a name="line943"></a> 943        # required by each worksheet.
</span><span class="uncovered1"><a name="line944"></a> 944        #
</span><span class="uncovered0"><a name="line945"></a> 945        @worksheets.each do |sheet|
</span><span class="uncovered1"><a name="line946"></a> 946            next unless sheet.kind_of?(Worksheet)
</span><span class="uncovered0"><a name="line947"></a> 947    
</span><span class="uncovered1"><a name="line948"></a> 948            num_images     = @num_images || 0
</span><span class="uncovered0"><a name="line949"></a> 949            image_mso_size = @image_mso_size || 0
</span><span class="uncovered1"><a name="line950"></a> 950            num_comments   = prepare_comments
</span><span class="uncovered0"><a name="line951"></a> 951            num_charts     = prepare_charts
</span><span class="uncovered1"><a name="line952"></a> 952            num_filters    = @filter_count
</span><span class="uncovered0"><a name="line953"></a> 953    
</span><span class="uncovered1"><a name="line954"></a> 954            next unless num_images + num_comments + num_charts +num_filters != 0
</span><span class="uncovered0"><a name="line955"></a> 955 
</span><span class="uncovered1"><a name="line956"></a> 956            # Include 1 parent MSODRAWING shape, per sheet, in the shape count.
</span><span class="uncovered0"><a name="line957"></a> 957            num_shapes   += 1 + num_images   +
</span><span class="uncovered1"><a name="line958"></a> 958                                num_comments +
</span><span class="uncovered0"><a name="line959"></a> 959                                num_charts   +
</span><span class="uncovered1"><a name="line960"></a> 960                                num_filters
</span><span class="uncovered0"><a name="line961"></a> 961            shapes_saved += num_shapes
</span><span class="uncovered1"><a name="line962"></a> 962            mso_size     += image_mso_size
</span><span class="uncovered0"><a name="line963"></a> 963    
</span><span class="uncovered1"><a name="line964"></a> 964            # Add a drawing object for each sheet with comments.
</span><span class="uncovered0"><a name="line965"></a> 965            drawings_saved += 1
</span><span class="uncovered1"><a name="line966"></a> 966    
</span><span class="uncovered0"><a name="line967"></a> 967            # For each sheet start the spids at the next 1024 interval.
</span><span class="uncovered1"><a name="line968"></a> 968            max_spid   = 1024 * (1 + Integer((max_spid -1)/1024.0))
</span><span class="uncovered0"><a name="line969"></a> 969            start_spid = max_spid
</span><span class="uncovered1"><a name="line970"></a> 970    
</span><span class="uncovered0"><a name="line971"></a> 971            # Max spid for each sheet and eventually for the workbook.
</span><span class="uncovered1"><a name="line972"></a> 972            max_spid  += num_shapes
</span><span class="uncovered0"><a name="line973"></a> 973    
</span><span class="uncovered1"><a name="line974"></a> 974            # Store the cluster ids
</span><span class="uncovered0"><a name="line975"></a> 975            i = num_shapes
</span><span class="uncovered1"><a name="line976"></a> 976            while i &gt; 0
</span><span class="uncovered0"><a name="line977"></a> 977                num_clusters  += 1
</span><span class="uncovered1"><a name="line978"></a> 978                mso_size      += 8
</span><span class="uncovered0"><a name="line979"></a> 979                size           = i &gt; 1024 ? 1024 : i
</span><span class="uncovered1"><a name="line980"></a> 980    
</span><span class="uncovered0"><a name="line981"></a> 981                clusters.push([drawings_saved, size])
</span><span class="uncovered1"><a name="line982"></a> 982                i -= 1024
</span><span class="uncovered0"><a name="line983"></a> 983            end
</span><span class="uncovered1"><a name="line984"></a> 984    
</span><span class="uncovered0"><a name="line985"></a> 985            # Pass calculated values back to the worksheet
</span><span class="uncovered1"><a name="line986"></a> 986            sheet.object_ids = [start_spid, drawings_saved,
</span><span class="uncovered0"><a name="line987"></a> 987                                      num_shapes, max_spid -1]
</span><span class="uncovered1"><a name="line988"></a> 988        end
</span><span class="uncovered0"><a name="line989"></a> 989    
</span><span class="uncovered1"><a name="line990"></a> 990    
</span><span class="uncovered0"><a name="line991"></a> 991        # Calculate the MSODRAWINGGROUP size if we have stored some shapes.
</span><span class="uncovered1"><a name="line992"></a> 992        mso_size              += 86 if mso_size != 0 # Smallest size is 86+8=94
</span><span class="uncovered0"><a name="line993"></a> 993    
</span><span class="uncovered1"><a name="line994"></a> 994        @mso_size      = mso_size
</span><span class="uncovered0"><a name="line995"></a> 995        @mso_clusters  = [
</span><span class="uncovered1"><a name="line996"></a> 996                            max_spid, num_clusters, shapes_saved,
</span><span class="uncovered0"><a name="line997"></a> 997                            drawings_saved, clusters
</span><span class="uncovered1"><a name="line998"></a> 998                         ]
</span><span class="uncovered0"><a name="line999"></a> 999    end
</span><span class="inferred1"><a name="line1000"></a>1000 
</span><span class="inferred0"><a name="line1001"></a>1001    ###############################################################################
</span><span class="inferred1"><a name="line1002"></a>1002    #
</span><span class="inferred0"><a name="line1003"></a>1003    # _process_images()
</span><span class="inferred1"><a name="line1004"></a>1004    #
</span><span class="inferred0"><a name="line1005"></a>1005    # We need to process each image in each worksheet and extract information.
</span><span class="inferred1"><a name="line1006"></a>1006    # Some of this information is stored and used in the Workbook and some is
</span><span class="inferred0"><a name="line1007"></a>1007    # passed back into each Worksheet. The overall size for the image related
</span><span class="inferred1"><a name="line1008"></a>1008    # BIFF structures in the Workbook is calculated here.
</span><span class="inferred0"><a name="line1009"></a>1009    #
</span><span class="inferred1"><a name="line1010"></a>1010    # MSO size =  8 bytes for bstore_container +
</span><span class="inferred0"><a name="line1011"></a>1011    #            44 bytes for blip_store_entry +
</span><span class="inferred1"><a name="line1012"></a>1012    #            25 bytes for blip
</span><span class="inferred0"><a name="line1013"></a>1013    #          = 77 + image size.
</span><span class="inferred1"><a name="line1014"></a>1014    #
</span><span class="marked0"><a name="line1015"></a>1015    def process_images
</span><span class="uncovered1"><a name="line1016"></a>1016        images_seen     = {}
</span><span class="uncovered0"><a name="line1017"></a>1017        image_data      = []
</span><span class="uncovered1"><a name="line1018"></a>1018        previous_images = []
</span><span class="uncovered0"><a name="line1019"></a>1019        image_id        = 1;
</span><span class="uncovered1"><a name="line1020"></a>1020        images_size     = 0;
</span><span class="uncovered0"><a name="line1021"></a>1021 
</span><span class="uncovered1"><a name="line1022"></a>1022        @worksheets.each do |sheet|
</span><span class="uncovered0"><a name="line1023"></a>1023            next unless sheet.kind_of?(Worksheet)
</span><span class="uncovered1"><a name="line1024"></a>1024            next unless sheet.prepare_images
</span><span class="uncovered0"><a name="line1025"></a>1025    
</span><span class="uncovered1"><a name="line1026"></a>1026            num_images      = 0;
</span><span class="uncovered0"><a name="line1027"></a>1027            image_mso_size  = 0;
</span><span class="uncovered1"><a name="line1028"></a>1028 
</span><span class="uncovered0"><a name="line1029"></a>1029            sheet.images_array.each do |image|
</span><span class="uncovered1"><a name="line1030"></a>1030                filename = image[2]
</span><span class="uncovered0"><a name="line1031"></a>1031                num_images += 1
</span><span class="uncovered1"><a name="line1032"></a>1032    
</span><span class="uncovered0"><a name="line1033"></a>1033                #
</span><span class="uncovered1"><a name="line1034"></a>1034                # For each Worksheet image we get a structure like this
</span><span class="uncovered0"><a name="line1035"></a>1035                # [
</span><span class="uncovered1"><a name="line1036"></a>1036                #   $row,
</span><span class="uncovered0"><a name="line1037"></a>1037                #   $col,
</span><span class="uncovered1"><a name="line1038"></a>1038                #   $name,
</span><span class="uncovered0"><a name="line1039"></a>1039                #   $x_offset,
</span><span class="uncovered1"><a name="line1040"></a>1040                #   $y_offset,
</span><span class="uncovered0"><a name="line1041"></a>1041                #   $scale_x,
</span><span class="uncovered1"><a name="line1042"></a>1042                #   $scale_y,
</span><span class="uncovered0"><a name="line1043"></a>1043                # ]
</span><span class="uncovered1"><a name="line1044"></a>1044                #
</span><span class="uncovered0"><a name="line1045"></a>1045                # And we add additional information:
</span><span class="uncovered1"><a name="line1046"></a>1046                #
</span><span class="uncovered0"><a name="line1047"></a>1047                #   $image_id,
</span><span class="uncovered1"><a name="line1048"></a>1048                #   $type,
</span><span class="uncovered0"><a name="line1049"></a>1049                #   $width,
</span><span class="uncovered1"><a name="line1050"></a>1050                #   $height;
</span><span class="uncovered0"><a name="line1051"></a>1051    
</span><span class="uncovered1"><a name="line1052"></a>1052                if images_seen[filename].nil?
</span><span class="uncovered0"><a name="line1053"></a>1053                    # TODO should also match seen images based on checksum.
</span><span class="uncovered1"><a name="line1054"></a>1054    
</span><span class="uncovered0"><a name="line1055"></a>1055                    # Open the image file and import the data.
</span><span class="uncovered1"><a name="line1056"></a>1056                    fh = open(filename, &quot;rb&quot;)
</span><span class="uncovered0"><a name="line1057"></a>1057                    raise &quot;Couldn't import #{filename}: #{$!}&quot; unless fh
</span><span class="uncovered1"><a name="line1058"></a>1058 
</span><span class="uncovered0"><a name="line1059"></a>1059                    # Slurp the file into a string and do some size calcs.
</span><span class="uncovered1"><a name="line1060"></a>1060       #             my $data        = do {local $/; &lt;$fh&gt;};
</span><span class="uncovered0"><a name="line1061"></a>1061                    size        = data.length
</span><span class="uncovered1"><a name="line1062"></a>1062                    checksum1   = image_checksum(data, image_id)
</span><span class="uncovered0"><a name="line1063"></a>1063                    checksum2   = checksum1
</span><span class="uncovered1"><a name="line1064"></a>1064                    ref_count   = 1
</span><span class="uncovered0"><a name="line1065"></a>1065 
</span><span class="uncovered1"><a name="line1066"></a>1066                    # Process the image and extract dimensions.
</span><span class="uncovered0"><a name="line1067"></a>1067                    # Test for PNGs...
</span><span class="uncovered1"><a name="line1068"></a>1068                    if  data.unpack('x A3') ==  'PNG'
</span><span class="uncovered0"><a name="line1069"></a>1069                        type, width, height = process_png(data)
</span><span class="uncovered1"><a name="line1070"></a>1070                    # Test for JFIF and Exif JPEGs...
</span><span class="uncovered0"><a name="line1071"></a>1071                    elsif ( data.unpack('n') == 0xFFD8 &amp;&amp;
</span><span class="uncovered1"><a name="line1072"></a>1072                                 (data.unpack('x6 A4') == 'JFIF' ||
</span><span class="uncovered0"><a name="line1073"></a>1073                                  data.unpack('x6 A4') == 'Exif')
</span><span class="uncovered1"><a name="line1074"></a>1074                                )
</span><span class="uncovered0"><a name="line1075"></a>1075                        type, width, height = process_jpg(data, filename)
</span><span class="uncovered1"><a name="line1076"></a>1076                    # Test for BMPs...
</span><span class="uncovered0"><a name="line1077"></a>1077                    elsif data.unpack('A2') == 'BM'
</span><span class="uncovered1"><a name="line1078"></a>1078                        type, width, height = process_bmp(data, filename)
</span><span class="uncovered0"><a name="line1079"></a>1079                        # The 14 byte header of the BMP is stripped off.
</span><span class="uncovered1"><a name="line1080"></a>1080                        data[0, 13] = ''
</span><span class="uncovered0"><a name="line1081"></a>1081                        
</span><span class="uncovered1"><a name="line1082"></a>1082                        # A checksum of the new image data is also required.
</span><span class="uncovered0"><a name="line1083"></a>1083                        checksum2  = image_checksum(data, image_id, image_id)
</span><span class="uncovered1"><a name="line1084"></a>1084 
</span><span class="uncovered0"><a name="line1085"></a>1085                        # Adjust size -14 (header) + 16 (extra checksum).
</span><span class="uncovered1"><a name="line1086"></a>1086                        size += 2
</span><span class="uncovered0"><a name="line1087"></a>1087                    else
</span><span class="uncovered1"><a name="line1088"></a>1088                        raise &quot;Unsupported image format for file: #{filename}\n&quot;
</span><span class="uncovered0"><a name="line1089"></a>1089                    end
</span><span class="uncovered1"><a name="line1090"></a>1090 
</span><span class="uncovered0"><a name="line1091"></a>1091                    # Push the new data back into the Worksheet array;
</span><span class="uncovered1"><a name="line1092"></a>1092                    image.push(image_id, type, width, height)
</span><span class="uncovered0"><a name="line1093"></a>1093    
</span><span class="uncovered1"><a name="line1094"></a>1094                    # Also store new data for use in duplicate images.
</span><span class="uncovered0"><a name="line1095"></a>1095                    previous_images.push([image_id, type, width, height])
</span><span class="uncovered1"><a name="line1096"></a>1096 
</span><span class="uncovered0"><a name="line1097"></a>1097                    # Store information required by the Workbook.
</span><span class="uncovered1"><a name="line1098"></a>1098                    image_data.push([ref_count, type, data, size,
</span><span class="uncovered0"><a name="line1099"></a>1099                                       checksum1, checksum2])
</span><span class="uncovered1"><a name="line1100"></a>1100 
</span><span class="uncovered0"><a name="line1101"></a>1101                    # Keep track of overall data size.
</span><span class="uncovered1"><a name="line1102"></a>1102                    images_size       += size +61; # Size for bstore container.
</span><span class="uncovered0"><a name="line1103"></a>1103                    image_mso_size    += size +69; # Size for dgg container.
</span><span class="uncovered1"><a name="line1104"></a>1104    
</span><span class="uncovered0"><a name="line1105"></a>1105                    images_seen[filename] = image_id
</span><span class="uncovered1"><a name="line1106"></a>1106                    image_id += 1
</span><span class="uncovered0"><a name="line1107"></a>1107                    close(fh)
</span><span class="uncovered1"><a name="line1108"></a>1108                else
</span><span class="uncovered0"><a name="line1109"></a>1109                    # We've processed this file already.
</span><span class="uncovered1"><a name="line1110"></a>1110                    index = images_seen[filename] -1
</span><span class="uncovered0"><a name="line1111"></a>1111    
</span><span class="uncovered1"><a name="line1112"></a>1112                    # Increase image reference count.
</span><span class="uncovered0"><a name="line1113"></a>1113                    image_data[index][0] += 1
</span><span class="uncovered1"><a name="line1114"></a>1114    
</span><span class="uncovered0"><a name="line1115"></a>1115                    # Add previously calculated data back onto the Worksheet array.
</span><span class="uncovered1"><a name="line1116"></a>1116                    # $image_id, $type, $width, $height
</span><span class="uncovered0"><a name="line1117"></a>1117                    a_ref = images_array[index]
</span><span class="uncovered1"><a name="line1118"></a>1118                    image_ref.push(previous_images[index])
</span><span class="uncovered0"><a name="line1119"></a>1119                end
</span><span class="uncovered1"><a name="line1120"></a>1120            end
</span><span class="uncovered0"><a name="line1121"></a>1121    
</span><span class="uncovered1"><a name="line1122"></a>1122            # Store information required by the Worksheet.
</span><span class="uncovered0"><a name="line1123"></a>1123            @num_images     = num_images
</span><span class="uncovered1"><a name="line1124"></a>1124            @image_mso_size = image_mso_size
</span><span class="uncovered0"><a name="line1125"></a>1125    
</span><span class="uncovered1"><a name="line1126"></a>1126        end
</span><span class="uncovered0"><a name="line1127"></a>1127    
</span><span class="uncovered1"><a name="line1128"></a>1128    
</span><span class="uncovered0"><a name="line1129"></a>1129        # Store information required by the Workbook.
</span><span class="uncovered1"><a name="line1130"></a>1130        @images_size = images_size
</span><span class="uncovered0"><a name="line1131"></a>1131        @images_data = image_data     # Store the data for MSODRAWINGGROUP.
</span><span class="uncovered1"><a name="line1132"></a>1132    
</span><span class="uncovered0"><a name="line1133"></a>1133    end
</span><span class="inferred1"><a name="line1134"></a>1134 
</span><span class="inferred0"><a name="line1135"></a>1135    ###############################################################################
</span><span class="inferred1"><a name="line1136"></a>1136    #
</span><span class="inferred0"><a name="line1137"></a>1137    # _image_checksum()
</span><span class="inferred1"><a name="line1138"></a>1138    #
</span><span class="inferred0"><a name="line1139"></a>1139    # Generate a checksum for the image using whichever module is available..The
</span><span class="inferred1"><a name="line1140"></a>1140    # available modules are checked in _get_checksum_method(). Excel uses an MD4
</span><span class="inferred0"><a name="line1141"></a>1141    # checksum but any other will do. In the event of no checksum module being
</span><span class="inferred1"><a name="line1142"></a>1142    # available we simulate a checksum using the image index.
</span><span class="inferred0"><a name="line1143"></a>1143    #
</span><span class="marked1"><a name="line1144"></a>1144    def image_checksum(data, index1, index2 = 0)
</span><span class="uncovered0"><a name="line1145"></a>1145        if    @checksum_method == 1
</span><span class="uncovered1"><a name="line1146"></a>1146            # Digest::MD4
</span><span class="uncovered0"><a name="line1147"></a>1147 #           return Digest::MD4::md4_hex($data);
</span><span class="uncovered1"><a name="line1148"></a>1148        elsif @checksum_method == 2
</span><span class="uncovered0"><a name="line1149"></a>1149            # Digest::Perl::MD4
</span><span class="uncovered1"><a name="line1150"></a>1150 #           return Digest::Perl::MD4::md4_hex($data);
</span><span class="uncovered0"><a name="line1151"></a>1151        elsif @checksum_method == 3
</span><span class="uncovered1"><a name="line1152"></a>1152            # Digest::MD5
</span><span class="uncovered0"><a name="line1153"></a>1153            return Digest::MD5.hexdigest(data)
</span><span class="inferred1"><a name="line1154"></a>1154        else
</span><span class="inferred0"><a name="line1155"></a>1155            # Default
</span><span class="inferred1"><a name="line1156"></a>1156            return sprintf('%016X%016X', index2, index1)
</span><span class="inferred0"><a name="line1157"></a>1157        end
</span><span class="inferred1"><a name="line1158"></a>1158    end
</span><span class="inferred0"><a name="line1159"></a>1159 
</span><span class="inferred1"><a name="line1160"></a>1160    ###############################################################################
</span><span class="inferred0"><a name="line1161"></a>1161    #
</span><span class="inferred1"><a name="line1162"></a>1162    # _process_png()
</span><span class="inferred0"><a name="line1163"></a>1163    #
</span><span class="inferred1"><a name="line1164"></a>1164    # Extract width and height information from a PNG file.
</span><span class="inferred0"><a name="line1165"></a>1165    #
</span><span class="marked1"><a name="line1166"></a>1166    def process_png(data)
</span><span class="inferred0"><a name="line1167"></a>1167        type    = 6 # Excel Blip type (MSOBLIPTYPE).
</span><span class="inferred1"><a name="line1168"></a>1168        width   = data[16, 4].unpack(&quot;N&quot;)
</span><span class="inferred0"><a name="line1169"></a>1169        height  = data[20, 4].unpack(&quot;N&quot;)
</span><span class="uncovered1"><a name="line1170"></a>1170 
</span><span class="uncovered0"><a name="line1171"></a>1171        return [type, width, height]
</span><span class="uncovered1"><a name="line1172"></a>1172    end
</span><span class="inferred0"><a name="line1173"></a>1173 
</span><span class="inferred1"><a name="line1174"></a>1174    ###############################################################################
</span><span class="inferred0"><a name="line1175"></a>1175    #
</span><span class="inferred1"><a name="line1176"></a>1176    # _process_bmp()
</span><span class="inferred0"><a name="line1177"></a>1177    #
</span><span class="inferred1"><a name="line1178"></a>1178    # Extract width and height information from a BMP file.
</span><span class="inferred0"><a name="line1179"></a>1179    #
</span><span class="inferred1"><a name="line1180"></a>1180    # Most of these checks came from the old Worksheet::_process_bitmap() method.
</span><span class="inferred0"><a name="line1181"></a>1181    #
</span><span class="marked1"><a name="line1182"></a>1182    def process_bmp(data, filename)
</span><span class="uncovered0"><a name="line1183"></a>1183        type     = 7   # Excel Blip type (MSOBLIPTYPE).
</span><span class="uncovered1"><a name="line1184"></a>1184 
</span><span class="uncovered0"><a name="line1185"></a>1185        # Check that the file is big enough to be a bitmap.
</span><span class="uncovered1"><a name="line1186"></a>1186        if data.length  &lt;= 0x36
</span><span class="uncovered0"><a name="line1187"></a>1187            raise &quot;#{filename} doesn't contain enough data.&quot;
</span><span class="uncovered1"><a name="line1188"></a>1188        end
</span><span class="uncovered0"><a name="line1189"></a>1189 
</span><span class="uncovered1"><a name="line1190"></a>1190        # Read the bitmap width and height. Verify the sizes.
</span><span class="uncovered0"><a name="line1191"></a>1191        width, height = data.unpack(&quot;x18 V2&quot;)
</span><span class="uncovered1"><a name="line1192"></a>1192 
</span><span class="uncovered0"><a name="line1193"></a>1193        if width &gt; 0xFFFF
</span><span class="uncovered1"><a name="line1194"></a>1194            raise &quot;#{filename}: largest image width #{width} supported is 65k.&quot;
</span><span class="uncovered0"><a name="line1195"></a>1195        end
</span><span class="uncovered1"><a name="line1196"></a>1196    
</span><span class="uncovered0"><a name="line1197"></a>1197        if height &gt; 0xFFFF
</span><span class="uncovered1"><a name="line1198"></a>1198            raise &quot;#{filename}: largest image height supported is 65k.&quot;
</span><span class="uncovered0"><a name="line1199"></a>1199        end
</span><span class="uncovered1"><a name="line1200"></a>1200    
</span><span class="uncovered0"><a name="line1201"></a>1201        # Read the bitmap planes and bpp data. Verify them.
</span><span class="uncovered1"><a name="line1202"></a>1202        planes, bitcount = data.unpack(&quot;x26 v2&quot;)
</span><span class="uncovered0"><a name="line1203"></a>1203 
</span><span class="uncovered1"><a name="line1204"></a>1204        if bitcount != 24
</span><span class="uncovered0"><a name="line1205"></a>1205            raise &quot;#{filename} isn't a 24bit true color bitmap.&quot;
</span><span class="uncovered1"><a name="line1206"></a>1206        end
</span><span class="uncovered0"><a name="line1207"></a>1207    
</span><span class="uncovered1"><a name="line1208"></a>1208        if planes != 1
</span><span class="uncovered0"><a name="line1209"></a>1209            raise &quot;#{filename}: only 1 plane supported in bitmap image.&quot;
</span><span class="uncovered1"><a name="line1210"></a>1210        end
</span><span class="uncovered0"><a name="line1211"></a>1211 
</span><span class="uncovered1"><a name="line1212"></a>1212        # Read the bitmap compression. Verify compression.
</span><span class="uncovered0"><a name="line1213"></a>1213        compression = data.unpack(&quot;x30 V&quot;)
</span><span class="uncovered1"><a name="line1214"></a>1214    
</span><span class="uncovered0"><a name="line1215"></a>1215        if compression != 0
</span><span class="uncovered1"><a name="line1216"></a>1216            raise &quot;#{filename}: compression not supported in bitmap image.&quot;
</span><span class="uncovered0"><a name="line1217"></a>1217        end
</span><span class="uncovered1"><a name="line1218"></a>1218    
</span><span class="uncovered0"><a name="line1219"></a>1219        return [type, width, height]
</span><span class="uncovered1"><a name="line1220"></a>1220    end
</span><span class="inferred0"><a name="line1221"></a>1221 
</span><span class="inferred1"><a name="line1222"></a>1222    ###############################################################################
</span><span class="inferred0"><a name="line1223"></a>1223    #
</span><span class="inferred1"><a name="line1224"></a>1224    # _process_jpg()
</span><span class="inferred0"><a name="line1225"></a>1225    #
</span><span class="inferred1"><a name="line1226"></a>1226    # Extract width and height information from a JPEG file.
</span><span class="inferred0"><a name="line1227"></a>1227    #
</span><span class="marked1"><a name="line1228"></a>1228    def process_jpg(data, filename)
</span><span class="uncovered0"><a name="line1229"></a>1229        type     = 5  # Excel Blip type (MSOBLIPTYPE).
</span><span class="uncovered1"><a name="line1230"></a>1230    
</span><span class="uncovered0"><a name="line1231"></a>1231        offset = 2;
</span><span class="uncovered1"><a name="line1232"></a>1232        data_length = data.length
</span><span class="uncovered0"><a name="line1233"></a>1233 
</span><span class="uncovered1"><a name="line1234"></a>1234        # Search through the image data to find the 0xFFC0 marker. The height and
</span><span class="uncovered0"><a name="line1235"></a>1235        # width are contained in the data for that sub element.
</span><span class="uncovered1"><a name="line1236"></a>1236        while offset &lt; data_length
</span><span class="uncovered0"><a name="line1237"></a>1237            marker  = [data[offset,   2]].unpack(&quot;n&quot;)
</span><span class="uncovered1"><a name="line1238"></a>1238            length  = [data[offset+2, 2]].unpack(&quot;n&quot;)
</span><span class="uncovered0"><a name="line1239"></a>1239 
</span><span class="uncovered1"><a name="line1240"></a>1240            if marker == 0xFFC0
</span><span class="uncovered0"><a name="line1241"></a>1241                height = [data[offset+5, 2]].unpack(&quot;n&quot;)
</span><span class="uncovered1"><a name="line1242"></a>1242                width  = [data[offset+7, 2]].unpack(&quot;n&quot;)
</span><span class="uncovered0"><a name="line1243"></a>1243                break
</span><span class="uncovered1"><a name="line1244"></a>1244            end
</span><span class="uncovered0"><a name="line1245"></a>1245    
</span><span class="uncovered1"><a name="line1246"></a>1246            offset = offset + length + 2
</span><span class="uncovered0"><a name="line1247"></a>1247            breakt if marker == 0xFFDA
</span><span class="uncovered1"><a name="line1248"></a>1248        end
</span><span class="uncovered0"><a name="line1249"></a>1249    
</span><span class="uncovered1"><a name="line1250"></a>1250        if height.nil?
</span><span class="uncovered0"><a name="line1251"></a>1251           raise &quot;#{filename}: no size data found in image.\n&quot;
</span><span class="uncovered1"><a name="line1252"></a>1252        end
</span><span class="uncovered0"><a name="line1253"></a>1253    
</span><span class="uncovered1"><a name="line1254"></a>1254        return [type, width, height]
</span><span class="uncovered0"><a name="line1255"></a>1255    end
</span><span class="inferred1"><a name="line1256"></a>1256 
</span><span class="inferred0"><a name="line1257"></a>1257    ###############################################################################
</span><span class="inferred1"><a name="line1258"></a>1258    #
</span><span class="inferred0"><a name="line1259"></a>1259    # _store_all_fonts()
</span><span class="inferred1"><a name="line1260"></a>1260    #
</span><span class="inferred0"><a name="line1261"></a>1261    # Store the Excel FONT records.
</span><span class="inferred1"><a name="line1262"></a>1262    #
</span><span class="marked0"><a name="line1263"></a>1263    def store_all_fonts
</span><span class="uncovered1"><a name="line1264"></a>1264        format  = @formats[15]   # The default cell format.
</span><span class="uncovered0"><a name="line1265"></a>1265        font    = format.get_font
</span><span class="uncovered1"><a name="line1266"></a>1266    
</span><span class="uncovered0"><a name="line1267"></a>1267        # Fonts are 0-indexed. According to the SDK there is no index 4,
</span><span class="uncovered1"><a name="line1268"></a>1268        (0..3).each do
</span><span class="uncovered0"><a name="line1269"></a>1269            append(font)
</span><span class="uncovered1"><a name="line1270"></a>1270        end
</span><span class="uncovered0"><a name="line1271"></a>1271 
</span><span class="uncovered1"><a name="line1272"></a>1272        # Add the font for comments. This isn't connected to any XF format.
</span><span class="uncovered0"><a name="line1273"></a>1273        tmp    = Format.new(nil, font =&gt; 'Tahoma', size =&gt; 8)
</span><span class="uncovered1"><a name="line1274"></a>1274        font   = tmp.get_font
</span><span class="uncovered0"><a name="line1275"></a>1275        append(font)
</span><span class="uncovered1"><a name="line1276"></a>1276 
</span><span class="uncovered0"><a name="line1277"></a>1277        # Iterate through the XF objects and write a FONT record if it isn't the
</span><span class="uncovered1"><a name="line1278"></a>1278        # same as the default FONT and if it hasn't already been used.
</span><span class="uncovered0"><a name="line1279"></a>1279        #
</span><span class="uncovered1"><a name="line1280"></a>1280        fonts = {}
</span><span class="uncovered0"><a name="line1281"></a>1281        index = 6                    # The first user defined FONT
</span><span class="uncovered1"><a name="line1282"></a>1282    
</span><span class="uncovered0"><a name="line1283"></a>1283        key = format.get_font_key    # The default font for cell formats.
</span><span class="uncovered1"><a name="line1284"></a>1284        fonts[key] = 0               # Index of the default font
</span><span class="uncovered0"><a name="line1285"></a>1285    
</span><span class="uncovered1"><a name="line1286"></a>1286        # Fonts that are marked as '_font_only' are always stored. These are used
</span><span class="uncovered0"><a name="line1287"></a>1287        # mainly for charts and may not have an associated XF record.
</span><span class="uncovered1"><a name="line1288"></a>1288    
</span><span class="uncovered0"><a name="line1289"></a>1289        @formats.each do |format|
</span><span class="uncovered1"><a name="line1290"></a>1290            key = format.get_font_key
</span><span class="uncovered0"><a name="line1291"></a>1291    
</span><span class="uncovered1"><a name="line1292"></a>1292            if format.font_only == 0 and !fonts[key].nil?
</span><span class="uncovered0"><a name="line1293"></a>1293                # FONT has already been used
</span><span class="uncovered1"><a name="line1294"></a>1294                format.font_index = fonts[key]
</span><span class="uncovered0"><a name="line1295"></a>1295            else
</span><span class="uncovered1"><a name="line1296"></a>1296                # Add a new FONT record
</span><span class="uncovered0"><a name="line1297"></a>1297    
</span><span class="uncovered1"><a name="line1298"></a>1298                if format.font_only == 0
</span><span class="uncovered0"><a name="line1299"></a>1299                    fonts[key] = index
</span><span class="uncovered1"><a name="line1300"></a>1300                end
</span><span class="uncovered0"><a name="line1301"></a>1301    
</span><span class="uncovered1"><a name="line1302"></a>1302                format.font_index = index
</span><span class="uncovered0"><a name="line1303"></a>1303                index += 1
</span><span class="uncovered1"><a name="line1304"></a>1304                font = format.get_font
</span><span class="uncovered0"><a name="line1305"></a>1305                append(font)
</span><span class="uncovered1"><a name="line1306"></a>1306            end
</span><span class="uncovered0"><a name="line1307"></a>1307        end
</span><span class="uncovered1"><a name="line1308"></a>1308    end
</span><span class="inferred0"><a name="line1309"></a>1309 
</span><span class="inferred1"><a name="line1310"></a>1310    ###############################################################################
</span><span class="inferred0"><a name="line1311"></a>1311    #
</span><span class="inferred1"><a name="line1312"></a>1312    # _store_all_num_formats()
</span><span class="inferred0"><a name="line1313"></a>1313    #
</span><span class="inferred1"><a name="line1314"></a>1314    # Store user defined numerical formats i.e. FORMAT records
</span><span class="inferred0"><a name="line1315"></a>1315    #
</span><span class="marked1"><a name="line1316"></a>1316    def store_all_num_formats
</span><span class="uncovered0"><a name="line1317"></a>1317        num_formats = {}
</span><span class="uncovered1"><a name="line1318"></a>1318        index = 164       # User defined FORMAT records start from 0xA4
</span><span class="uncovered0"><a name="line1319"></a>1319 
</span><span class="uncovered1"><a name="line1320"></a>1320        # Iterate through the XF objects and write a FORMAT record if it isn't a
</span><span class="uncovered0"><a name="line1321"></a>1321        # built-in format type and if the FORMAT string hasn't already been used.
</span><span class="uncovered1"><a name="line1322"></a>1322        #
</span><span class="uncovered0"><a name="line1323"></a>1323        @formats.each do |format|
</span><span class="uncovered1"><a name="line1324"></a>1324            num_format = format.num_format
</span><span class="uncovered0"><a name="line1325"></a>1325            encoding   = format.num_format_enc
</span><span class="uncovered1"><a name="line1326"></a>1326    
</span><span class="uncovered0"><a name="line1327"></a>1327            # Check if $num_format is an index to a built-in format.
</span><span class="uncovered1"><a name="line1328"></a>1328            # Also check for a string of zeros, which is a valid format string
</span><span class="uncovered0"><a name="line1329"></a>1329            # but would evaluate to zero.
</span><span class="uncovered1"><a name="line1330"></a>1330            #
</span><span class="uncovered0"><a name="line1331"></a>1331            unless num_format =~ /^0+\d/
</span><span class="uncovered1"><a name="line1332"></a>1332                next if num_format =~ /^\d+$/   # built-in
</span><span class="uncovered0"><a name="line1333"></a>1333            end
</span><span class="uncovered1"><a name="line1334"></a>1334    
</span><span class="uncovered0"><a name="line1335"></a>1335            unless @num_formats[num_format].nil?
</span><span class="uncovered1"><a name="line1336"></a>1336                # FORMAT has already been used
</span><span class="uncovered0"><a name="line1337"></a>1337                format.num_format = num_formats[num_format]
</span><span class="uncovered1"><a name="line1338"></a>1338            else
</span><span class="uncovered0"><a name="line1339"></a>1339                # Add a new FORMAT
</span><span class="uncovered1"><a name="line1340"></a>1340                num_formats[num_format] = index
</span><span class="uncovered0"><a name="line1341"></a>1341                format.num_format       = index
</span><span class="uncovered1"><a name="line1342"></a>1342                store_num_format(num_format, index, encoding)
</span><span class="uncovered0"><a name="line1343"></a>1343                index += 1
</span><span class="uncovered1"><a name="line1344"></a>1344            end
</span><span class="uncovered0"><a name="line1345"></a>1345        end
</span><span class="uncovered1"><a name="line1346"></a>1346    end
</span><span class="inferred0"><a name="line1347"></a>1347 
</span><span class="inferred1"><a name="line1348"></a>1348    ###############################################################################
</span><span class="inferred0"><a name="line1349"></a>1349    #
</span><span class="inferred1"><a name="line1350"></a>1350    # _store_all_xfs()
</span><span class="inferred0"><a name="line1351"></a>1351    #
</span><span class="inferred1"><a name="line1352"></a>1352    # Write all XF records.
</span><span class="inferred0"><a name="line1353"></a>1353    #
</span><span class="marked1"><a name="line1354"></a>1354    def store_all_xfs
</span><span class="uncovered0"><a name="line1355"></a>1355        @formats.each do |format|
</span><span class="uncovered1"><a name="line1356"></a>1356            xf = format.get_xf
</span><span class="uncovered0"><a name="line1357"></a>1357            append(xf)
</span><span class="uncovered1"><a name="line1358"></a>1358        end
</span><span class="uncovered0"><a name="line1359"></a>1359    end
</span><span class="inferred1"><a name="line1360"></a>1360 
</span><span class="inferred0"><a name="line1361"></a>1361    ###############################################################################
</span><span class="inferred1"><a name="line1362"></a>1362    #
</span><span class="inferred0"><a name="line1363"></a>1363    # _store_all_styles()
</span><span class="inferred1"><a name="line1364"></a>1364    #
</span><span class="inferred0"><a name="line1365"></a>1365    # Write all STYLE records.
</span><span class="inferred1"><a name="line1366"></a>1366    #
</span><span class="marked0"><a name="line1367"></a>1367    def store_all_styles
</span><span class="uncovered1"><a name="line1368"></a>1368        # Excel adds the built-in styles in alphabetical order.
</span><span class="uncovered0"><a name="line1369"></a>1369        built_ins = [
</span><span class="uncovered1"><a name="line1370"></a>1370            [0x03, 16], # Comma
</span><span class="uncovered0"><a name="line1371"></a>1371            [0x06, 17], # Comma[0]
</span><span class="uncovered1"><a name="line1372"></a>1372            [0x04, 18], # Currency
</span><span class="uncovered0"><a name="line1373"></a>1373            [0x07, 19], # Currency[0]
</span><span class="uncovered1"><a name="line1374"></a>1374            [0x00,  0], # Normal
</span><span class="uncovered0"><a name="line1375"></a>1375            [0x05, 20]  # Percent
</span><span class="uncovered1"><a name="line1376"></a>1376    
</span><span class="uncovered0"><a name="line1377"></a>1377            # We don't deal with these styles yet.
</span><span class="uncovered1"><a name="line1378"></a>1378            #[0x08, 21], # Hyperlink
</span><span class="uncovered0"><a name="line1379"></a>1379            #[0x02,  8], # ColLevel_n
</span><span class="uncovered1"><a name="line1380"></a>1380            #[0x01,  1], # RowLevel_n
</span><span class="uncovered0"><a name="line1381"></a>1381        ]
</span><span class="uncovered1"><a name="line1382"></a>1382 
</span><span class="uncovered0"><a name="line1383"></a>1383        @built_ins.each do |aref|
</span><span class="uncovered1"><a name="line1384"></a>1384            type     = aref[0]
</span><span class="uncovered0"><a name="line1385"></a>1385            xf_index = aref[1]
</span><span class="uncovered1"><a name="line1386"></a>1386    
</span><span class="uncovered0"><a name="line1387"></a>1387            store_style(type, xf_index)
</span><span class="uncovered1"><a name="line1388"></a>1388        end
</span><span class="uncovered0"><a name="line1389"></a>1389    end
</span><span class="inferred1"><a name="line1390"></a>1390 
</span><span class="inferred0"><a name="line1391"></a>1391    ###############################################################################
</span><span class="inferred1"><a name="line1392"></a>1392    #
</span><span class="inferred0"><a name="line1393"></a>1393    # _store_names()
</span><span class="inferred1"><a name="line1394"></a>1394    #
</span><span class="inferred0"><a name="line1395"></a>1395    # Write the NAME record to define the print area and the repeat rows and cols.
</span><span class="inferred1"><a name="line1396"></a>1396    #
</span><span class="marked0"><a name="line1397"></a>1397    def store_names
</span><span class="uncovered1"><a name="line1398"></a>1398        index       = 0
</span><span class="uncovered0"><a name="line1399"></a>1399    
</span><span class="uncovered1"><a name="line1400"></a>1400        # Create the print area NAME records
</span><span class="uncovered0"><a name="line1401"></a>1401        @worksheets.each do |worksheet|
</span><span class="uncovered1"><a name="line1402"></a>1402 
</span><span class="uncovered0"><a name="line1403"></a>1403            key = &quot;#{index}:#{index}&quot;
</span><span class="uncovered1"><a name="line1404"></a>1404            ref = @ext_refs[key]
</span><span class="uncovered0"><a name="line1405"></a>1405            index += 1
</span><span class="uncovered1"><a name="line1406"></a>1406    
</span><span class="uncovered0"><a name="line1407"></a>1407            # Write a Name record if Autofilter has been defined
</span><span class="uncovered1"><a name="line1408"></a>1408            if worksheet.filter_count != 0
</span><span class="uncovered0"><a name="line1409"></a>1409                store_name_short(
</span><span class="uncovered1"><a name="line1410"></a>1410                    worksheet.index,
</span><span class="uncovered0"><a name="line1411"></a>1411                    0x0D, # NAME type = Filter Database
</span><span class="uncovered1"><a name="line1412"></a>1412                    ref,
</span><span class="uncovered0"><a name="line1413"></a>1413                    worksheet.filter_area[0],
</span><span class="uncovered1"><a name="line1414"></a>1414                    worksheet.filter_area[1],
</span><span class="uncovered0"><a name="line1415"></a>1415                    worksheet.filter_area[2],
</span><span class="uncovered1"><a name="line1416"></a>1416                    worksheet.filter_area[3],
</span><span class="uncovered0"><a name="line1417"></a>1417                    1     # Hidden
</span><span class="uncovered1"><a name="line1418"></a>1418                )
</span><span class="uncovered0"><a name="line1419"></a>1419            end
</span><span class="uncovered1"><a name="line1420"></a>1420    
</span><span class="uncovered0"><a name="line1421"></a>1421            # Write a Name record if the print area has been defined
</span><span class="uncovered1"><a name="line1422"></a>1422            if worksheet.print_rowmin
</span><span class="uncovered0"><a name="line1423"></a>1423                store_name_short(
</span><span class="uncovered1"><a name="line1424"></a>1424                    worksheet.index,
</span><span class="uncovered0"><a name="line1425"></a>1425                    0x06, # NAME type = Print_Area
</span><span class="uncovered1"><a name="line1426"></a>1426                    ref,
</span><span class="uncovered0"><a name="line1427"></a>1427                    worksheet.print_rowmin,
</span><span class="uncovered1"><a name="line1428"></a>1428                    worksheet.print_rowmax,
</span><span class="uncovered0"><a name="line1429"></a>1429                    worksheet.print_colmin,
</span><span class="uncovered1"><a name="line1430"></a>1430                    worksheet.print_colmax
</span><span class="uncovered0"><a name="line1431"></a>1431                )
</span><span class="uncovered1"><a name="line1432"></a>1432            end
</span><span class="uncovered0"><a name="line1433"></a>1433    
</span><span class="uncovered1"><a name="line1434"></a>1434        end
</span><span class="uncovered0"><a name="line1435"></a>1435    
</span><span class="uncovered1"><a name="line1436"></a>1436        index = 0
</span><span class="uncovered0"><a name="line1437"></a>1437    
</span><span class="uncovered1"><a name="line1438"></a>1438        # Create the print title NAME records
</span><span class="uncovered0"><a name="line1439"></a>1439        @worksheets.each do |worksheet|
</span><span class="uncovered1"><a name="line1440"></a>1440 
</span><span class="uncovered0"><a name="line1441"></a>1441            rowmin = worksheet.title_rowmin
</span><span class="uncovered1"><a name="line1442"></a>1442            rowmax = worksheet.title_rowmax
</span><span class="uncovered0"><a name="line1443"></a>1443            colmin = worksheet.title_colmin
</span><span class="uncovered1"><a name="line1444"></a>1444            colmax = worksheet.title_colmax
</span><span class="uncovered0"><a name="line1445"></a>1445            key = &quot;#{index}:#{index}&quot;
</span><span class="uncovered1"><a name="line1446"></a>1446            ref = @ext_refs[key]
</span><span class="uncovered0"><a name="line1447"></a>1447            index += 1
</span><span class="uncovered1"><a name="line1448"></a>1448    
</span><span class="uncovered0"><a name="line1449"></a>1449            # Determine if row + col, row, col or nothing has been defined
</span><span class="uncovered1"><a name="line1450"></a>1450            # and write the appropriate record
</span><span class="uncovered0"><a name="line1451"></a>1451            #
</span><span class="uncovered1"><a name="line1452"></a>1452            if rowmin &amp;&amp; colmin
</span><span class="uncovered0"><a name="line1453"></a>1453                # Row and column titles have been defined.
</span><span class="uncovered1"><a name="line1454"></a>1454                # Row title has been defined.
</span><span class="uncovered0"><a name="line1455"></a>1455                store_name_long(
</span><span class="uncovered1"><a name="line1456"></a>1456                    worksheet.index,
</span><span class="uncovered0"><a name="line1457"></a>1457                    0x07, # NAME type = Print_Titles
</span><span class="uncovered1"><a name="line1458"></a>1458                    ref,
</span><span class="uncovered0"><a name="line1459"></a>1459                    rowmin,
</span><span class="uncovered1"><a name="line1460"></a>1460                    rowmax,
</span><span class="uncovered0"><a name="line1461"></a>1461                    colmin,
</span><span class="uncovered1"><a name="line1462"></a>1462                    colmax
</span><span class="uncovered0"><a name="line1463"></a>1463               )
</span><span class="uncovered1"><a name="line1464"></a>1464            elsif rowmin
</span><span class="uncovered0"><a name="line1465"></a>1465                # Row title has been defined.
</span><span class="uncovered1"><a name="line1466"></a>1466                store_name_short(
</span><span class="uncovered0"><a name="line1467"></a>1467                    worksheet.index,
</span><span class="uncovered1"><a name="line1468"></a>1468                    0x07, # NAME type = Print_Titles
</span><span class="uncovered0"><a name="line1469"></a>1469                    ref,
</span><span class="uncovered1"><a name="line1470"></a>1470                    rowmin,
</span><span class="uncovered0"><a name="line1471"></a>1471                    rowmax,
</span><span class="uncovered1"><a name="line1472"></a>1472                    0x00,
</span><span class="uncovered0"><a name="line1473"></a>1473                    0xff
</span><span class="uncovered1"><a name="line1474"></a>1474                )
</span><span class="uncovered0"><a name="line1475"></a>1475            elsif colmin
</span><span class="uncovered1"><a name="line1476"></a>1476                # Column title has been defined.
</span><span class="uncovered0"><a name="line1477"></a>1477                store_name_short(
</span><span class="uncovered1"><a name="line1478"></a>1478                    worksheet.index,
</span><span class="uncovered0"><a name="line1479"></a>1479                    0x07, # NAME type = Print_Titles
</span><span class="uncovered1"><a name="line1480"></a>1480                    ref,
</span><span class="uncovered0"><a name="line1481"></a>1481                    0x0000,
</span><span class="uncovered1"><a name="line1482"></a>1482                    0xffff,
</span><span class="uncovered0"><a name="line1483"></a>1483                    colmin,
</span><span class="uncovered1"><a name="line1484"></a>1484                    colmax
</span><span class="uncovered0"><a name="line1485"></a>1485                )
</span><span class="uncovered1"><a name="line1486"></a>1486            else
</span><span class="uncovered0"><a name="line1487"></a>1487                # Nothing left to do
</span><span class="uncovered1"><a name="line1488"></a>1488            end
</span><span class="uncovered0"><a name="line1489"></a>1489        end
</span><span class="uncovered1"><a name="line1490"></a>1490    end
</span><span class="inferred0"><a name="line1491"></a>1491 
</span><span class="inferred1"><a name="line1492"></a>1492    ###############################################################################
</span><span class="inferred0"><a name="line1493"></a>1493    ###############################################################################
</span><span class="inferred1"><a name="line1494"></a>1494    #
</span><span class="inferred0"><a name="line1495"></a>1495    # BIFF RECORDS
</span><span class="inferred1"><a name="line1496"></a>1496    #
</span><span class="inferred0"><a name="line1497"></a>1497    
</span><span class="inferred1"><a name="line1498"></a>1498    
</span><span class="inferred0"><a name="line1499"></a>1499    ###############################################################################
</span><span class="inferred1"><a name="line1500"></a>1500    #
</span><span class="inferred0"><a name="line1501"></a>1501    # _store_window1()
</span><span class="inferred1"><a name="line1502"></a>1502    #
</span><span class="inferred0"><a name="line1503"></a>1503    # Write Excel BIFF WINDOW1 record.
</span><span class="inferred1"><a name="line1504"></a>1504    #
</span><span class="marked0"><a name="line1505"></a>1505    def store_window1
</span><span class="uncovered1"><a name="line1506"></a>1506        record    = 0x003D                 # Record identifier
</span><span class="uncovered0"><a name="line1507"></a>1507        length    = 0x0012                 # Number of bytes to follow
</span><span class="uncovered1"><a name="line1508"></a>1508    
</span><span class="uncovered0"><a name="line1509"></a>1509        xWn       = 0x0000                 # Horizontal position of window
</span><span class="uncovered1"><a name="line1510"></a>1510        yWn       = 0x0000                 # Vertical position of window
</span><span class="uncovered0"><a name="line1511"></a>1511        dxWn      = 0x355C                 # Width of window
</span><span class="uncovered1"><a name="line1512"></a>1512        dyWn      = 0x30ED                 # Height of window
</span><span class="uncovered0"><a name="line1513"></a>1513    
</span><span class="uncovered1"><a name="line1514"></a>1514        grbit     = 0x0038                 # Option flags
</span><span class="uncovered0"><a name="line1515"></a>1515        ctabsel   = @selected              # Number of workbook tabs selected
</span><span class="uncovered1"><a name="line1516"></a>1516        wTabRatio = 0x0258                 # Tab to scrollbar ratio
</span><span class="uncovered0"><a name="line1517"></a>1517    
</span><span class="uncovered1"><a name="line1518"></a>1518        itabFirst = @firstsheet            # 1st displayed worksheet
</span><span class="uncovered0"><a name="line1519"></a>1519        itabCur   = @activesheet           # Active worksheet
</span><span class="uncovered1"><a name="line1520"></a>1520    
</span><span class="uncovered0"><a name="line1521"></a>1521        header    = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line1522"></a>1522        data      = [xWn, yWn, dxWn, dyWn,
</span><span class="uncovered0"><a name="line1523"></a>1523                     grbit, itabCur, itabFirst,
</span><span class="uncovered1"><a name="line1524"></a>1524                     ctabsel, wTabRatio].pack(&quot;vvvvvvvvv&quot;)
</span><span class="uncovered0"><a name="line1525"></a>1525 
</span><span class="uncovered1"><a name="line1526"></a>1526        append(header, data)
</span><span class="uncovered0"><a name="line1527"></a>1527    end
</span><span class="inferred1"><a name="line1528"></a>1528 
</span><span class="inferred0"><a name="line1529"></a>1529    ###############################################################################
</span><span class="inferred1"><a name="line1530"></a>1530    #
</span><span class="inferred0"><a name="line1531"></a>1531    # _store_boundsheet()
</span><span class="inferred1"><a name="line1532"></a>1532    #    my $sheetname = $_[0];                # Worksheet name
</span><span class="inferred0"><a name="line1533"></a>1533    #    my $offset    = $_[1];                # Location of worksheet BOF
</span><span class="inferred1"><a name="line1534"></a>1534    #    my $type      = $_[2];                # Worksheet type
</span><span class="inferred0"><a name="line1535"></a>1535    #    my $hidden    = $_[3];                # Worksheet hidden flag
</span><span class="inferred1"><a name="line1536"></a>1536    #    my $encoding  = $_[4];                # Sheet name encoding
</span><span class="inferred0"><a name="line1537"></a>1537    #
</span><span class="inferred1"><a name="line1538"></a>1538    # Writes Excel BIFF BOUNDSHEET record.
</span><span class="inferred0"><a name="line1539"></a>1539    #
</span><span class="marked1"><a name="line1540"></a>1540    def store_boundsheet(sheetname, offset, type, hidden, encoding)
</span><span class="uncovered0"><a name="line1541"></a>1541        record    = 0x0085                    # Record identifier
</span><span class="uncovered1"><a name="line1542"></a>1542        length    = 0x08 + sheetname.length   # Number of bytes to follow
</span><span class="uncovered0"><a name="line1543"></a>1543    
</span><span class="uncovered1"><a name="line1544"></a>1544        cch       = sheetname.length          # Length of sheet name
</span><span class="uncovered0"><a name="line1545"></a>1545    
</span><span class="uncovered1"><a name="line1546"></a>1546        grbit     = type | hidden
</span><span class="uncovered0"><a name="line1547"></a>1547    
</span><span class="uncovered1"><a name="line1548"></a>1548        # Character length is num of chars not num of bytes
</span><span class="uncovered0"><a name="line1549"></a>1549        cch /= 2 if encoding
</span><span class="uncovered1"><a name="line1550"></a>1550    
</span><span class="uncovered0"><a name="line1551"></a>1551        # Change the UTF-16 name from BE to LE
</span><span class="uncovered1"><a name="line1552"></a>1552        sheetname = [sheetname].unpack('v*').pack('n*') if encoding != 0
</span><span class="uncovered0"><a name="line1553"></a>1553    
</span><span class="uncovered1"><a name="line1554"></a>1554        header    = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1555"></a>1555        data      = [offset, grbit, cch, encoding].pack(&quot;VvCC&quot;)
</span><span class="uncovered1"><a name="line1556"></a>1556    
</span><span class="uncovered0"><a name="line1557"></a>1557        append(header, data, sheetname)
</span><span class="uncovered1"><a name="line1558"></a>1558    end
</span><span class="inferred0"><a name="line1559"></a>1559 
</span><span class="inferred1"><a name="line1560"></a>1560    ###############################################################################
</span><span class="inferred0"><a name="line1561"></a>1561    #
</span><span class="inferred1"><a name="line1562"></a>1562    # _store_style()
</span><span class="inferred0"><a name="line1563"></a>1563    #    type      = $_[0]  # Built-in style
</span><span class="inferred1"><a name="line1564"></a>1564    #    xf_index  = $_[1]  # Index to style XF
</span><span class="inferred0"><a name="line1565"></a>1565    #
</span><span class="inferred1"><a name="line1566"></a>1566    # Write Excel BIFF STYLE records.
</span><span class="inferred0"><a name="line1567"></a>1567    #
</span><span class="marked1"><a name="line1568"></a>1568    def store_style(type, xf_index)
</span><span class="uncovered0"><a name="line1569"></a>1569        record    = 0x0293    # Record identifier
</span><span class="uncovered1"><a name="line1570"></a>1570        length    = 0x0004    # Bytes to follow
</span><span class="uncovered0"><a name="line1571"></a>1571    
</span><span class="uncovered1"><a name="line1572"></a>1572        level     = 0xff      # Outline style level
</span><span class="uncovered0"><a name="line1573"></a>1573    
</span><span class="uncovered1"><a name="line1574"></a>1574        xf_index    |= 0x8000 # Add flag to indicate built-in style.
</span><span class="uncovered0"><a name="line1575"></a>1575    
</span><span class="uncovered1"><a name="line1576"></a>1576        header    = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1577"></a>1577        data      = [xf_index, type, level].pack(&quot;vCC&quot;)
</span><span class="uncovered1"><a name="line1578"></a>1578    
</span><span class="uncovered0"><a name="line1579"></a>1579        append(header, data)
</span><span class="uncovered1"><a name="line1580"></a>1580    end
</span><span class="inferred0"><a name="line1581"></a>1581 
</span><span class="inferred1"><a name="line1582"></a>1582    ###############################################################################
</span><span class="inferred0"><a name="line1583"></a>1583    #
</span><span class="inferred1"><a name="line1584"></a>1584    # _store_num_format()
</span><span class="inferred0"><a name="line1585"></a>1585    #    my $format    = $_[0];          # Custom format string
</span><span class="inferred1"><a name="line1586"></a>1586    #    my $ifmt      = $_[1];          # Format index code
</span><span class="inferred0"><a name="line1587"></a>1587    #    my $encoding  = $_[2];          # Char encoding for format string
</span><span class="inferred1"><a name="line1588"></a>1588    #
</span><span class="inferred0"><a name="line1589"></a>1589    # Writes Excel FORMAT record for non &quot;built-in&quot; numerical formats.
</span><span class="inferred1"><a name="line1590"></a>1590    #
</span><span class="marked0"><a name="line1591"></a>1591    def store_num_format(format, ifmt, encoding)
</span><span class="uncovered1"><a name="line1592"></a>1592        record    = 0x041E         # Record identifier
</span><span class="uncovered0"><a name="line1593"></a>1593        length                     # Number of bytes to follow
</span><span class="uncovered1"><a name="line1594"></a>1594 
</span><span class="uncovered0"><a name="line1595"></a>1595    
</span><span class="uncovered1"><a name="line1596"></a>1596        # Char length of format string
</span><span class="uncovered0"><a name="line1597"></a>1597        cch = format.length
</span><span class="uncovered1"><a name="line1598"></a>1598    
</span><span class="uncovered0"><a name="line1599"></a>1599    
</span><span class="uncovered1"><a name="line1600"></a>1600        # Handle Unicode format strings.
</span><span class="uncovered0"><a name="line1601"></a>1601        if encoding == 1
</span><span class="uncovered1"><a name="line1602"></a>1602            raise &quot;Uneven number of bytes in Unicode font name&quot; if cch % 2 != 0
</span><span class="uncovered0"><a name="line1603"></a>1603            cch /= 2 if encoding != 0
</span><span class="uncovered1"><a name="line1604"></a>1604            format  = [format].unpack('n*').pack('v*')
</span><span class="uncovered0"><a name="line1605"></a>1605        end
</span><span class="uncovered1"><a name="line1606"></a>1606 
</span><span class="uncovered0"><a name="line1607"></a>1607        # Special case to handle Euro symbol, 0x80, in non-Unicode strings.
</span><span class="uncovered1"><a name="line1608"></a>1608        if encoding == 0 and format =~ /\x80/
</span><span class="uncovered0"><a name="line1609"></a>1609            format   =  [format].unpack('C*').pack('v*')
</span><span class="uncovered1"><a name="line1610"></a>1610            format.gsub!(/\x80\x00/, &quot;\xAC\x20&quot;)
</span><span class="uncovered0"><a name="line1611"></a>1611            encoding =  1
</span><span class="uncovered1"><a name="line1612"></a>1612        end
</span><span class="uncovered0"><a name="line1613"></a>1613    
</span><span class="uncovered1"><a name="line1614"></a>1614        length    = 0x05 + format.length
</span><span class="uncovered0"><a name="line1615"></a>1615    
</span><span class="uncovered1"><a name="line1616"></a>1616        header    = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1617"></a>1617        data      = [ifmt, cch, encodinf].pack(&quot;vvC&quot;)
</span><span class="uncovered1"><a name="line1618"></a>1618    
</span><span class="uncovered0"><a name="line1619"></a>1619        append(header, data, format)
</span><span class="uncovered1"><a name="line1620"></a>1620    end
</span><span class="inferred0"><a name="line1621"></a>1621 
</span><span class="inferred1"><a name="line1622"></a>1622    ###############################################################################
</span><span class="inferred0"><a name="line1623"></a>1623    #
</span><span class="inferred1"><a name="line1624"></a>1624    # _store_1904()
</span><span class="inferred0"><a name="line1625"></a>1625    #
</span><span class="inferred1"><a name="line1626"></a>1626    # Write Excel 1904 record to indicate the date system in use.
</span><span class="inferred0"><a name="line1627"></a>1627    #
</span><span class="marked1"><a name="line1628"></a>1628    def store_1904
</span><span class="uncovered0"><a name="line1629"></a>1629        record    = 0x0022         # Record identifier
</span><span class="uncovered1"><a name="line1630"></a>1630        length    = 0x0002         # Bytes to follow
</span><span class="uncovered0"><a name="line1631"></a>1631    
</span><span class="uncovered1"><a name="line1632"></a>1632        f1904     = @v1904         # Flag for 1904 date system
</span><span class="uncovered0"><a name="line1633"></a>1633    
</span><span class="uncovered1"><a name="line1634"></a>1634        header    = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1635"></a>1635        data      = [f1904].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1636"></a>1636    
</span><span class="uncovered0"><a name="line1637"></a>1637        append(header, data)
</span><span class="uncovered1"><a name="line1638"></a>1638    end
</span><span class="inferred0"><a name="line1639"></a>1639 
</span><span class="inferred1"><a name="line1640"></a>1640    ###############################################################################
</span><span class="inferred0"><a name="line1641"></a>1641    #
</span><span class="inferred1"><a name="line1642"></a>1642    # _store_supbook()
</span><span class="inferred0"><a name="line1643"></a>1643    #
</span><span class="inferred1"><a name="line1644"></a>1644    # Write BIFF record SUPBOOK to indicate that the workbook contains external
</span><span class="inferred0"><a name="line1645"></a>1645    # references, in our case, formula, print area and print title refs.
</span><span class="inferred1"><a name="line1646"></a>1646    #
</span><span class="marked0"><a name="line1647"></a>1647    def store_supbook
</span><span class="uncovered1"><a name="line1648"></a>1648        record      = 0x01AE                   # Record identifier
</span><span class="uncovered0"><a name="line1649"></a>1649        length      = 0x0004                   # Number of bytes to follow
</span><span class="uncovered1"><a name="line1650"></a>1650    
</span><span class="uncovered0"><a name="line1651"></a>1651        ctabs       = @worksheets.size         # Number of worksheets
</span><span class="uncovered1"><a name="line1652"></a>1652        stVirtPath  = 0x0401                   # Encoded workbook filename
</span><span class="uncovered0"><a name="line1653"></a>1653    
</span><span class="uncovered1"><a name="line1654"></a>1654        header    = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1655"></a>1655        data      = [ctabs, stVirtPath].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line1656"></a>1656    
</span><span class="uncovered0"><a name="line1657"></a>1657        append(header, data)
</span><span class="uncovered1"><a name="line1658"></a>1658    end
</span><span class="inferred0"><a name="line1659"></a>1659 
</span><span class="inferred1"><a name="line1660"></a>1660    ###############################################################################
</span><span class="inferred0"><a name="line1661"></a>1661    #
</span><span class="inferred1"><a name="line1662"></a>1662    # _store_externsheet()
</span><span class="inferred0"><a name="line1663"></a>1663    #
</span><span class="inferred1"><a name="line1664"></a>1664    # Writes the Excel BIFF EXTERNSHEET record. These references are used by
</span><span class="inferred0"><a name="line1665"></a>1665    # formulas. TODO NAME record is required to define the print area and the
</span><span class="inferred1"><a name="line1666"></a>1666    # repeat rows and columns.
</span><span class="inferred0"><a name="line1667"></a>1667    #
</span><span class="marked1"><a name="line1668"></a>1668    def store_externsheet
</span><span class="uncovered0"><a name="line1669"></a>1669        record      = 0x0017                   # Record identifier
</span><span class="uncovered1"><a name="line1670"></a>1670    
</span><span class="uncovered0"><a name="line1671"></a>1671        # Get the external refs
</span><span class="uncovered1"><a name="line1672"></a>1672        ext_refs = @ext_refs
</span><span class="uncovered0"><a name="line1673"></a>1673        ext = sort ext_refs.keys
</span><span class="uncovered1"><a name="line1674"></a>1674    
</span><span class="uncovered0"><a name="line1675"></a>1675        # Change the external refs from stringified &quot;1:1&quot; to [1, 1]
</span><span class="uncovered1"><a name="line1676"></a>1676        ext.each do |e|
</span><span class="uncovered0"><a name="line1677"></a>1677            e = e.split(/:/)
</span><span class="uncovered1"><a name="line1678"></a>1678        end
</span><span class="uncovered0"><a name="line1679"></a>1679 
</span><span class="uncovered1"><a name="line1680"></a>1680        cxti        = @ext.size                # Number of Excel XTI structures
</span><span class="uncovered0"><a name="line1681"></a>1681        rgxti       = ''                       # Array of XTI structures
</span><span class="uncovered1"><a name="line1682"></a>1682    
</span><span class="uncovered0"><a name="line1683"></a>1683        # Write the XTI structs
</span><span class="uncovered1"><a name="line1684"></a>1684        ext.each do |e|
</span><span class="uncovered0"><a name="line1685"></a>1685            rgxti = rgxti + [0, e[0], e[1]].pack(&quot;vvv&quot;)
</span><span class="uncovered1"><a name="line1686"></a>1686        end
</span><span class="uncovered0"><a name="line1687"></a>1687 
</span><span class="uncovered1"><a name="line1688"></a>1688        data        = [cxti].pack(&quot;v&quot;) + rgxti
</span><span class="uncovered0"><a name="line1689"></a>1689        header    = [record, data.length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line1690"></a>1690    
</span><span class="uncovered0"><a name="line1691"></a>1691        append(header, data)
</span><span class="uncovered1"><a name="line1692"></a>1692    end
</span><span class="inferred0"><a name="line1693"></a>1693 
</span><span class="inferred1"><a name="line1694"></a>1694    ###############################################################################
</span><span class="inferred0"><a name="line1695"></a>1695    #
</span><span class="inferred1"><a name="line1696"></a>1696    # _store_name_short()
</span><span class="inferred0"><a name="line1697"></a>1697    #    index           = shift        # Sheet index
</span><span class="inferred1"><a name="line1698"></a>1698    #    type            = shift
</span><span class="inferred0"><a name="line1699"></a>1699    #    ext_ref         = shift        # TODO
</span><span class="inferred1"><a name="line1700"></a>1700    #    rowmin          = $_[0]        # Start row
</span><span class="inferred0"><a name="line1701"></a>1701    #    rowmax          = $_[1]        # End row
</span><span class="inferred1"><a name="line1702"></a>1702    #    colmin          = $_[2]        # Start column
</span><span class="inferred0"><a name="line1703"></a>1703    #    colmax          = $_[3]        # end column
</span><span class="inferred1"><a name="line1704"></a>1704    #    hidden          = $_[4]        # Name is hidden
</span><span class="inferred0"><a name="line1705"></a>1705    #
</span><span class="inferred1"><a name="line1706"></a>1706    #
</span><span class="inferred0"><a name="line1707"></a>1707    # Store the NAME record in the short format that is used for storing the print
</span><span class="inferred1"><a name="line1708"></a>1708    # area, repeat rows only and repeat columns only.
</span><span class="inferred0"><a name="line1709"></a>1709    #
</span><span class="marked1"><a name="line1710"></a>1710    def store_name_short(index, type, ext_ref, rowmin, rowmax, colmin, colmax)
</span><span class="uncovered0"><a name="line1711"></a>1711        record          = 0x0018       # Record identifier
</span><span class="uncovered1"><a name="line1712"></a>1712        length          = 0x001b       # Number of bytes to follow
</span><span class="uncovered0"><a name="line1713"></a>1713    
</span><span class="uncovered1"><a name="line1714"></a>1714        index           = shift        # Sheet index
</span><span class="uncovered0"><a name="line1715"></a>1715        type            = shift
</span><span class="uncovered1"><a name="line1716"></a>1716        ext_ref         = shift        # TODO
</span><span class="uncovered0"><a name="line1717"></a>1717    
</span><span class="uncovered1"><a name="line1718"></a>1718        grbit           = 0x0020       # Option flags
</span><span class="uncovered0"><a name="line1719"></a>1719        chKey           = 0x00         # Keyboard shortcut
</span><span class="uncovered1"><a name="line1720"></a>1720        cch             = 0x01         # Length of text name
</span><span class="uncovered0"><a name="line1721"></a>1721        cce             = 0x000b       # Length of text definition
</span><span class="uncovered1"><a name="line1722"></a>1722        unknown01       = 0x0000       #
</span><span class="uncovered0"><a name="line1723"></a>1723        ixals           = index +1     # Sheet index
</span><span class="uncovered1"><a name="line1724"></a>1724        unknown02       = 0x00         #
</span><span class="uncovered0"><a name="line1725"></a>1725        cchCustMenu     = 0x00         # Length of cust menu text
</span><span class="uncovered1"><a name="line1726"></a>1726        cchDescription  = 0x00         # Length of description text
</span><span class="uncovered0"><a name="line1727"></a>1727        cchHelptopic    = 0x00         # Length of help topic text
</span><span class="uncovered1"><a name="line1728"></a>1728        cchStatustext   = 0x00         # Length of status bar text
</span><span class="uncovered0"><a name="line1729"></a>1729        rgch            = type         # Built-in name type
</span><span class="uncovered1"><a name="line1730"></a>1730        unknown03       = 0x3b         #
</span><span class="uncovered0"><a name="line1731"></a>1731 
</span><span class="uncovered1"><a name="line1732"></a>1732        grbit           = 0x0021 if hidden
</span><span class="uncovered0"><a name="line1733"></a>1733    
</span><span class="uncovered1"><a name="line1734"></a>1734        header          = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1735"></a>1735        data            = [grbit].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1736"></a>1736        data            = data + [chKey].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1737"></a>1737        data            = data + [cch].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1738"></a>1738        data            = data + [cce].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1739"></a>1739        data            = data + [unknown01].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1740"></a>1740        data            = data + [ixals].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1741"></a>1741        data            = data + [unknown02].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1742"></a>1742        data            = data + [cchCustMenu].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1743"></a>1743        data            = data + [cchDescription].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1744"></a>1744        data            = data + [cchHelptopic].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1745"></a>1745        data            = data + [cchStatustext].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1746"></a>1746        data            = data + [rgch].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1747"></a>1747        data            = data + [unknown03].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1748"></a>1748        data            = data + [ext_ref].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1749"></a>1749    
</span><span class="uncovered1"><a name="line1750"></a>1750        data            = data + [rowmin].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1751"></a>1751        data            = data + [rowmax].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1752"></a>1752        data            = data + [colmin].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1753"></a>1753        data            = data + [colmax].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1754"></a>1754    
</span><span class="uncovered0"><a name="line1755"></a>1755        append(header, data)
</span><span class="uncovered1"><a name="line1756"></a>1756    end
</span><span class="inferred0"><a name="line1757"></a>1757 
</span><span class="inferred1"><a name="line1758"></a>1758    ###############################################################################
</span><span class="inferred0"><a name="line1759"></a>1759    #
</span><span class="inferred1"><a name="line1760"></a>1760    # _store_name_long()
</span><span class="inferred0"><a name="line1761"></a>1761    #    my $index           = shift;        # Sheet index
</span><span class="inferred1"><a name="line1762"></a>1762    #    my $type            = shift;
</span><span class="inferred0"><a name="line1763"></a>1763    #    my $ext_ref         = shift;        # TODO
</span><span class="inferred1"><a name="line1764"></a>1764    #    my $rowmin          = $_[0];        # Start row
</span><span class="inferred0"><a name="line1765"></a>1765    #    my $rowmax          = $_[1];        # End row
</span><span class="inferred1"><a name="line1766"></a>1766    #    my $colmin          = $_[2];        # Start column
</span><span class="inferred0"><a name="line1767"></a>1767    #    my $colmax          = $_[3];        # end column
</span><span class="inferred1"><a name="line1768"></a>1768    #
</span><span class="inferred0"><a name="line1769"></a>1769    #
</span><span class="inferred1"><a name="line1770"></a>1770    # Store the NAME record in the long format that is used for storing the repeat
</span><span class="inferred0"><a name="line1771"></a>1771    # rows and columns when both are specified. This share a lot of code with
</span><span class="inferred1"><a name="line1772"></a>1772    # _store_name_short() but we use a separate method to keep the code clean.
</span><span class="inferred0"><a name="line1773"></a>1773    # Code abstraction for reuse can be carried too far, and I should know. ;-)
</span><span class="inferred1"><a name="line1774"></a>1774    #
</span><span class="marked0"><a name="line1775"></a>1775    def store_name_long(index, type, ext_ref, rowmin, rowmax, colmin, colmax)
</span><span class="uncovered1"><a name="line1776"></a>1776        record          = 0x0018       # Record identifier
</span><span class="uncovered0"><a name="line1777"></a>1777        length          = 0x002a       # Number of bytes to follow
</span><span class="uncovered1"><a name="line1778"></a>1778    
</span><span class="uncovered0"><a name="line1779"></a>1779        index           = shift        # Sheet index
</span><span class="uncovered1"><a name="line1780"></a>1780        type            = shift
</span><span class="uncovered0"><a name="line1781"></a>1781        ext_ref         = shift        # TODO
</span><span class="uncovered1"><a name="line1782"></a>1782    
</span><span class="uncovered0"><a name="line1783"></a>1783        grbit           = 0x0020       # Option flags
</span><span class="uncovered1"><a name="line1784"></a>1784        chKey           = 0x00         # Keyboard shortcut
</span><span class="uncovered0"><a name="line1785"></a>1785        cch             = 0x01         # Length of text name
</span><span class="uncovered1"><a name="line1786"></a>1786        cce             = 0x001a       # Length of text definition
</span><span class="uncovered0"><a name="line1787"></a>1787        unknown01       = 0x0000       #
</span><span class="uncovered1"><a name="line1788"></a>1788        ixals           = index +1     # Sheet index
</span><span class="uncovered0"><a name="line1789"></a>1789        unknown02       = 0x00         #
</span><span class="uncovered1"><a name="line1790"></a>1790        cchCustMenu     = 0x00         # Length of cust menu text
</span><span class="uncovered0"><a name="line1791"></a>1791        cchDescription  = 0x00         # Length of description text
</span><span class="uncovered1"><a name="line1792"></a>1792        cchHelptopic    = 0x00         # Length of help topic text
</span><span class="uncovered0"><a name="line1793"></a>1793        cchStatustext   = 0x00         # Length of status bar text
</span><span class="uncovered1"><a name="line1794"></a>1794        rgch            = type         # Built-in name type
</span><span class="uncovered0"><a name="line1795"></a>1795    
</span><span class="uncovered1"><a name="line1796"></a>1796        unknown03       = 0x29
</span><span class="uncovered0"><a name="line1797"></a>1797        unknown04       = 0x0017
</span><span class="uncovered1"><a name="line1798"></a>1798        unknown05       = 0x3b
</span><span class="uncovered0"><a name="line1799"></a>1799 
</span><span class="uncovered1"><a name="line1800"></a>1800        header          = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1801"></a>1801        data            = [grbit].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1802"></a>1802        data            = data + [chKey].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1803"></a>1803        data            = data + [cch].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1804"></a>1804        data            = data + [cce].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1805"></a>1805        data            = data + [unknown01].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1806"></a>1806        data            = data + [ixals].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1807"></a>1807        data            = data + [unknown02].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1808"></a>1808        data            = data + [cchCustMenu].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1809"></a>1809        data            = data + [cchDescription].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1810"></a>1810        data            = data + [cchHelptopic].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1811"></a>1811        data            = data + [cchStatustext].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1812"></a>1812        data            = data + [rgch].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1813"></a>1813    
</span><span class="uncovered1"><a name="line1814"></a>1814        # Column definition
</span><span class="uncovered0"><a name="line1815"></a>1815        data            = data + [unknown03].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1816"></a>1816        data            = data + [unknown04].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1817"></a>1817        data            = data + [unknown05].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1818"></a>1818        data            = data + [ext_ref].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1819"></a>1819        data            = data + [0x0000].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1820"></a>1820        data            = data + [0xffff].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1821"></a>1821        data            = data + [colmin].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1822"></a>1822        data            = data + [colmax].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1823"></a>1823    
</span><span class="uncovered1"><a name="line1824"></a>1824        # Row definition
</span><span class="uncovered0"><a name="line1825"></a>1825        data            = data + [unknown05].pack(&quot;C&quot;)
</span><span class="uncovered1"><a name="line1826"></a>1826        data            = data + [ext_ref].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1827"></a>1827        data            = data + [rowmin].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1828"></a>1828        data            = data + [rowmax].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1829"></a>1829        data            = data + [0x00].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1830"></a>1830        data            = data + [0xff].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1831"></a>1831        # End of data
</span><span class="uncovered1"><a name="line1832"></a>1832        data            = data + [0x10].pack(&quot;C&quot;)
</span><span class="uncovered0"><a name="line1833"></a>1833    
</span><span class="uncovered1"><a name="line1834"></a>1834        append(header, data)
</span><span class="uncovered0"><a name="line1835"></a>1835    end
</span><span class="inferred1"><a name="line1836"></a>1836 
</span><span class="inferred0"><a name="line1837"></a>1837    ###############################################################################
</span><span class="inferred1"><a name="line1838"></a>1838    #
</span><span class="inferred0"><a name="line1839"></a>1839    # _store_palette()
</span><span class="inferred1"><a name="line1840"></a>1840    #
</span><span class="inferred0"><a name="line1841"></a>1841    # Stores the PALETTE biff record.
</span><span class="inferred1"><a name="line1842"></a>1842    #
</span><span class="marked0"><a name="line1843"></a>1843    def store_palette(*args)
</span><span class="uncovered1"><a name="line1844"></a>1844        aref            = @palette
</span><span class="uncovered0"><a name="line1845"></a>1845    
</span><span class="uncovered1"><a name="line1846"></a>1846        record          = 0x0092             # Record identifier
</span><span class="uncovered0"><a name="line1847"></a>1847        length          = 2 + 4 * aref.size  # Number of bytes to follow
</span><span class="uncovered1"><a name="line1848"></a>1848        ccv             =         aref.size  # Number of RGB values to follow
</span><span class="uncovered0"><a name="line1849"></a>1849        data                                 # The RGB data
</span><span class="uncovered1"><a name="line1850"></a>1850    
</span><span class="uncovered0"><a name="line1851"></a>1851        # Pack the RGB data
</span><span class="uncovered1"><a name="line1852"></a>1852        tmp = []
</span><span class="uncovered0"><a name="line1853"></a>1853        aref.each do |a|
</span><span class="uncovered1"><a name="line1854"></a>1854          tmp &lt;&lt; a
</span><span class="uncovered0"><a name="line1855"></a>1855        end
</span><span class="uncovered1"><a name="line1856"></a>1856        data = data + tmp.pack('CCCC')
</span><span class="uncovered0"><a name="line1857"></a>1857    
</span><span class="uncovered1"><a name="line1858"></a>1858        header = [record, length, ccv].pack(&quot;vvv&quot;)
</span><span class="uncovered0"><a name="line1859"></a>1859        
</span><span class="uncovered1"><a name="line1860"></a>1860        append(header, data)
</span><span class="uncovered0"><a name="line1861"></a>1861    end
</span><span class="inferred1"><a name="line1862"></a>1862 
</span><span class="inferred0"><a name="line1863"></a>1863    ###############################################################################
</span><span class="inferred1"><a name="line1864"></a>1864    #
</span><span class="inferred0"><a name="line1865"></a>1865    # _store_codepage()
</span><span class="inferred1"><a name="line1866"></a>1866    #
</span><span class="inferred0"><a name="line1867"></a>1867    # Stores the CODEPAGE biff record.
</span><span class="inferred1"><a name="line1868"></a>1868    #
</span><span class="marked0"><a name="line1869"></a>1869    def store_codepage
</span><span class="uncovered1"><a name="line1870"></a>1870        record          = 0x0042               # Record identifier
</span><span class="uncovered0"><a name="line1871"></a>1871        length          = 0x0002               # Number of bytes to follow
</span><span class="uncovered1"><a name="line1872"></a>1872        cv              = @codepage            # The code page
</span><span class="uncovered0"><a name="line1873"></a>1873    
</span><span class="uncovered1"><a name="line1874"></a>1874        header          = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1875"></a>1875        data            = [cv].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line1876"></a>1876 
</span><span class="uncovered0"><a name="line1877"></a>1877        append(header, data)
</span><span class="uncovered1"><a name="line1878"></a>1878    end
</span><span class="inferred0"><a name="line1879"></a>1879 
</span><span class="inferred1"><a name="line1880"></a>1880    ###############################################################################
</span><span class="inferred0"><a name="line1881"></a>1881    #
</span><span class="inferred1"><a name="line1882"></a>1882    # _store_country()
</span><span class="inferred0"><a name="line1883"></a>1883    #
</span><span class="inferred1"><a name="line1884"></a>1884    # Stores the COUNTRY biff record.
</span><span class="inferred0"><a name="line1885"></a>1885    #
</span><span class="inferred1"><a name="line1886"></a>1886    # Will add setter method for the country codes when/if required.
</span><span class="inferred0"><a name="line1887"></a>1887    #
</span><span class="marked1"><a name="line1888"></a>1888    def store_country
</span><span class="uncovered0"><a name="line1889"></a>1889        record          = 0x008C               # Record identifier
</span><span class="uncovered1"><a name="line1890"></a>1890        length          = 0x0004               # Number of bytes to follow
</span><span class="uncovered0"><a name="line1891"></a>1891        country_default = 1
</span><span class="uncovered1"><a name="line1892"></a>1892        country_win_ini = 1
</span><span class="uncovered0"><a name="line1893"></a>1893    
</span><span class="uncovered1"><a name="line1894"></a>1894        header          = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line1895"></a>1895        data            = [country_default, country_win_ini].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line1896"></a>1896    
</span><span class="uncovered0"><a name="line1897"></a>1897        append(header, data)
</span><span class="uncovered1"><a name="line1898"></a>1898    end
</span><span class="inferred0"><a name="line1899"></a>1899 
</span><span class="inferred1"><a name="line1900"></a>1900    ###############################################################################
</span><span class="inferred0"><a name="line1901"></a>1901    #
</span><span class="inferred1"><a name="line1902"></a>1902    # _store_hideobj()
</span><span class="inferred0"><a name="line1903"></a>1903    #
</span><span class="inferred1"><a name="line1904"></a>1904    # Stores the HIDEOBJ biff record.
</span><span class="inferred0"><a name="line1905"></a>1905    #
</span><span class="marked1"><a name="line1906"></a>1906    def store_hideobj
</span><span class="uncovered0"><a name="line1907"></a>1907        record          = 0x008D               # Record identifier
</span><span class="uncovered1"><a name="line1908"></a>1908        length          = 0x0002               # Number of bytes to follow
</span><span class="uncovered0"><a name="line1909"></a>1909        hide            = @hideobj             # Option to hide objects
</span><span class="uncovered1"><a name="line1910"></a>1910    
</span><span class="uncovered0"><a name="line1911"></a>1911        header          = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line1912"></a>1912        data            = [hide].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line1913"></a>1913    
</span><span class="uncovered1"><a name="line1914"></a>1914        append(header, data)
</span><span class="uncovered0"><a name="line1915"></a>1915    end
</span><span class="inferred1"><a name="line1916"></a>1916 
</span><span class="inferred0"><a name="line1917"></a>1917    ###############################################################################
</span><span class="inferred1"><a name="line1918"></a>1918    ###############################################################################
</span><span class="inferred0"><a name="line1919"></a>1919    ###############################################################################
</span><span class="inferred1"><a name="line1920"></a>1920 
</span><span class="inferred0"><a name="line1921"></a>1921 
</span><span class="inferred1"><a name="line1922"></a>1922 
</span><span class="inferred0"><a name="line1923"></a>1923    ###############################################################################
</span><span class="inferred1"><a name="line1924"></a>1924    #
</span><span class="inferred0"><a name="line1925"></a>1925    # _calculate_extern_sizes()
</span><span class="inferred1"><a name="line1926"></a>1926    #
</span><span class="inferred0"><a name="line1927"></a>1927    # We need to calculate the space required by the SUPBOOK, EXTERNSHEET and NAME
</span><span class="inferred1"><a name="line1928"></a>1928    # records so that it can be added to the BOUNDSHEET offsets.
</span><span class="inferred0"><a name="line1929"></a>1929    #
</span><span class="marked1"><a name="line1930"></a>1930    def calculate_extern_sizes
</span><span class="uncovered0"><a name="line1931"></a>1931        ext_refs        = @parser.get_ext_sheets
</span><span class="uncovered1"><a name="line1932"></a>1932        ext_ref_count   = ext_refs.keys.size
</span><span class="uncovered0"><a name="line1933"></a>1933        length          = 0
</span><span class="uncovered1"><a name="line1934"></a>1934        index           = 0
</span><span class="uncovered0"><a name="line1935"></a>1935    
</span><span class="uncovered1"><a name="line1936"></a>1936        @worksheets.each do |worksheet|
</span><span class="uncovered0"><a name="line1937"></a>1937        
</span><span class="uncovered1"><a name="line1938"></a>1938            rowmin      = worksheet.title_rowmin
</span><span class="uncovered0"><a name="line1939"></a>1939            colmin      = worksheet.title_colmin
</span><span class="uncovered1"><a name="line1940"></a>1940            filter      = worksheet.filter_count
</span><span class="uncovered0"><a name="line1941"></a>1941            key         = &quot;#{index}:#{index}&quot;
</span><span class="uncovered1"><a name="line1942"></a>1942            index += 1
</span><span class="uncovered0"><a name="line1943"></a>1943 
</span><span class="uncovered1"><a name="line1944"></a>1944            # Add area NAME records
</span><span class="uncovered0"><a name="line1945"></a>1945            #
</span><span class="uncovered1"><a name="line1946"></a>1946            if worksheet.print_rowmin
</span><span class="uncovered0"><a name="line1947"></a>1947               if ext_ref[key].nil?
</span><span class="uncovered1"><a name="line1948"></a>1948                  ext_refs[key] = ext_ref_count
</span><span class="uncovered0"><a name="line1949"></a>1949                  ext_ref_count += 1
</span><span class="uncovered1"><a name="line1950"></a>1950               end
</span><span class="uncovered0"><a name="line1951"></a>1951               length += 31 
</span><span class="uncovered1"><a name="line1952"></a>1952            end
</span><span class="uncovered0"><a name="line1953"></a>1953 
</span><span class="uncovered1"><a name="line1954"></a>1954            # Add title  NAME records
</span><span class="uncovered0"><a name="line1955"></a>1955            #
</span><span class="uncovered1"><a name="line1956"></a>1956            if rowmin and colmin
</span><span class="uncovered0"><a name="line1957"></a>1957               if ext_ref[key].nil?
</span><span class="uncovered1"><a name="line1958"></a>1958                  ext_refs[key] = ext_ref_count
</span><span class="uncovered0"><a name="line1959"></a>1959                  ext_ref_count += 1
</span><span class="uncovered1"><a name="line1960"></a>1960               end
</span><span class="uncovered0"><a name="line1961"></a>1961    
</span><span class="uncovered1"><a name="line1962"></a>1962               length += 46
</span><span class="uncovered0"><a name="line1963"></a>1963            elsif rowmin or colmin
</span><span class="uncovered1"><a name="line1964"></a>1964               if ext_ref[key].nil?
</span><span class="uncovered0"><a name="line1965"></a>1965                  ext_refs[key] = ext_ref_count
</span><span class="uncovered1"><a name="line1966"></a>1966                  ext_ref_count += 1
</span><span class="uncovered0"><a name="line1967"></a>1967               end
</span><span class="uncovered1"><a name="line1968"></a>1968               length += 31
</span><span class="uncovered0"><a name="line1969"></a>1969            else
</span><span class="uncovered1"><a name="line1970"></a>1970                # TODO, may need this later.
</span><span class="uncovered0"><a name="line1971"></a>1971            end
</span><span class="uncovered1"><a name="line1972"></a>1972 
</span><span class="uncovered0"><a name="line1973"></a>1973            # Add Autofilter  NAME records
</span><span class="uncovered1"><a name="line1974"></a>1974            #
</span><span class="uncovered0"><a name="line1975"></a>1975            if filter != 0
</span><span class="uncovered1"><a name="line1976"></a>1976               if ext_ref[key].nil?
</span><span class="uncovered0"><a name="line1977"></a>1977                  ext_refs[key] = ext_ref_count
</span><span class="uncovered1"><a name="line1978"></a>1978                  ext_ref_count += 1
</span><span class="uncovered0"><a name="line1979"></a>1979               end
</span><span class="uncovered1"><a name="line1980"></a>1980               length += 31
</span><span class="uncovered0"><a name="line1981"></a>1981            end
</span><span class="uncovered1"><a name="line1982"></a>1982        end
</span><span class="uncovered0"><a name="line1983"></a>1983 
</span><span class="uncovered1"><a name="line1984"></a>1984        # Update the ref counts.
</span><span class="uncovered0"><a name="line1985"></a>1985        @ext_ref_count = ext_ref_count
</span><span class="uncovered1"><a name="line1986"></a>1986        @ext_refs      = ext_refs
</span><span class="uncovered0"><a name="line1987"></a>1987 
</span><span class="uncovered1"><a name="line1988"></a>1988        # If there are no external refs then we don't write, SUPBOOK, EXTERNSHEET
</span><span class="uncovered0"><a name="line1989"></a>1989        # and NAME. Therefore the length is 0.
</span><span class="uncovered1"><a name="line1990"></a>1990    
</span><span class="uncovered0"><a name="line1991"></a>1991        return length = 0 if ext_ref_count == 0
</span><span class="uncovered1"><a name="line1992"></a>1992 
</span><span class="uncovered0"><a name="line1993"></a>1993        # The SUPBOOK record is 8 bytes
</span><span class="uncovered1"><a name="line1994"></a>1994        length += 8
</span><span class="uncovered0"><a name="line1995"></a>1995    
</span><span class="uncovered1"><a name="line1996"></a>1996        # The EXTERNSHEET record is 6 bytes + 6 bytes for each external ref
</span><span class="uncovered0"><a name="line1997"></a>1997        length += 6 * (1 + ext_ref_count)
</span><span class="uncovered1"><a name="line1998"></a>1998    
</span><span class="uncovered0"><a name="line1999"></a>1999        return length
</span><span class="uncovered1"><a name="line2000"></a>2000    end
</span><span class="inferred0"><a name="line2001"></a>2001 
</span><span class="inferred1"><a name="line2002"></a>2002    ###############################################################################
</span><span class="inferred0"><a name="line2003"></a>2003    #
</span><span class="inferred1"><a name="line2004"></a>2004    # _calculate_shared_string_sizes()
</span><span class="inferred0"><a name="line2005"></a>2005    #
</span><span class="inferred1"><a name="line2006"></a>2006    # Handling of the SST continue blocks is complicated by the need to include an
</span><span class="inferred0"><a name="line2007"></a>2007    # additional continuation byte depending on whether the string is split between
</span><span class="inferred1"><a name="line2008"></a>2008    # blocks or whether it starts at the beginning of the block. (There are also
</span><span class="inferred0"><a name="line2009"></a>2009    # additional complications that will arise later when/if Rich Strings are
</span><span class="inferred1"><a name="line2010"></a>2010    # supported). As such we cannot use the simple CONTINUE mechanism provided by
</span><span class="inferred0"><a name="line2011"></a>2011    # the _add_continue() method in BIFFwriter.pm. Thus we have to make two passes
</span><span class="inferred1"><a name="line2012"></a>2012    # through the strings data. The first is to calculate the required block sizes
</span><span class="inferred0"><a name="line2013"></a>2013    # and the second, in _store_shared_strings(), is to write the actual strings.
</span><span class="inferred1"><a name="line2014"></a>2014    # The first pass through the data is also used to calculate the size of the SST
</span><span class="inferred0"><a name="line2015"></a>2015    # and CONTINUE records for use in setting the BOUNDSHEET record offsets. The
</span><span class="inferred1"><a name="line2016"></a>2016    # downside of this is that the same algorithm repeated in _store_shared_strings.
</span><span class="inferred0"><a name="line2017"></a>2017    #
</span><span class="marked1"><a name="line2018"></a>2018    def calculate_shared_string_sizes
</span><span class="uncovered0"><a name="line2019"></a>2019        strings = []
</span><span class="uncovered1"><a name="line2020"></a>2020        #strings = self-&gt;{_str_unique} -1 # Pre-extend array
</span><span class="uncovered0"><a name="line2021"></a>2021    
</span><span class="uncovered1"><a name="line2022"></a>2022        @str_table.each_key do |key|
</span><span class="uncovered0"><a name="line2023"></a>2023            strings[@str_table[key]] = key
</span><span class="uncovered1"><a name="line2024"></a>2024        end
</span><span class="uncovered0"><a name="line2025"></a>2025    
</span><span class="uncovered1"><a name="line2026"></a>2026        # The SST data could be very large, free some memory (maybe).
</span><span class="uncovered0"><a name="line2027"></a>2027        @str_table = nil
</span><span class="uncovered1"><a name="line2028"></a>2028        @str_array = @strings
</span><span class="uncovered0"><a name="line2029"></a>2029 
</span><span class="uncovered1"><a name="line2030"></a>2030        # Iterate through the strings to calculate the CONTINUE block sizes.
</span><span class="uncovered0"><a name="line2031"></a>2031        #
</span><span class="uncovered1"><a name="line2032"></a>2032        # The SST blocks requires a specialised CONTINUE block, so we have to
</span><span class="uncovered0"><a name="line2033"></a>2033        # ensure that the maximum data block size is less than the limit used by
</span><span class="uncovered1"><a name="line2034"></a>2034        # _add_continue() in BIFFwriter.pm. For simplicity we use the same size
</span><span class="uncovered0"><a name="line2035"></a>2035        # for the SST and CONTINUE records:
</span><span class="uncovered1"><a name="line2036"></a>2036        #   8228 : Maximum Excel97 block size
</span><span class="uncovered0"><a name="line2037"></a>2037        #     -4 : Length of block header
</span><span class="uncovered1"><a name="line2038"></a>2038        #     -8 : Length of additional SST header information
</span><span class="uncovered0"><a name="line2039"></a>2039        #     -8 : Arbitrary number to keep within _add_continue() limit
</span><span class="uncovered1"><a name="line2040"></a>2040        # = 8208
</span><span class="uncovered0"><a name="line2041"></a>2041        #
</span><span class="uncovered1"><a name="line2042"></a>2042        continue_limit = 8208
</span><span class="uncovered0"><a name="line2043"></a>2043        block_length   = 0
</span><span class="uncovered1"><a name="line2044"></a>2044        written        = 0
</span><span class="uncovered0"><a name="line2045"></a>2045        block_sizes    = []
</span><span class="uncovered1"><a name="line2046"></a>2046        continue       = 0
</span><span class="uncovered0"><a name="line2047"></a>2047    
</span><span class="uncovered1"><a name="line2048"></a>2048        @strings.each do |string|
</span><span class="uncovered0"><a name="line2049"></a>2049 
</span><span class="uncovered1"><a name="line2050"></a>2050            string_length = string.length
</span><span class="uncovered0"><a name="line2051"></a>2051            encoding      = [string].unpack(&quot;xx C&quot;)
</span><span class="uncovered1"><a name="line2052"></a>2052            split_string  = 0
</span><span class="uncovered0"><a name="line2053"></a>2053 
</span><span class="uncovered1"><a name="line2054"></a>2054            # Block length is the total length of the strings that will be
</span><span class="uncovered0"><a name="line2055"></a>2055            # written out in a single SST or CONTINUE block.
</span><span class="uncovered1"><a name="line2056"></a>2056            #
</span><span class="uncovered0"><a name="line2057"></a>2057            block_length += string_length
</span><span class="uncovered1"><a name="line2058"></a>2058 
</span><span class="uncovered0"><a name="line2059"></a>2059            # We can write the string if it doesn't cross a CONTINUE boundary
</span><span class="uncovered1"><a name="line2060"></a>2060            if block_length &lt; continue_limit
</span><span class="uncovered0"><a name="line2061"></a>2061                written += string_length
</span><span class="uncovered1"><a name="line2062"></a>2062                next
</span><span class="uncovered0"><a name="line2063"></a>2063            end
</span><span class="uncovered1"><a name="line2064"></a>2064    
</span><span class="uncovered0"><a name="line2065"></a>2065    
</span><span class="uncovered1"><a name="line2066"></a>2066            # Deal with the cases where the next string to be written will exceed
</span><span class="uncovered0"><a name="line2067"></a>2067            # the CONTINUE boundary. If the string is very long it may need to be
</span><span class="uncovered1"><a name="line2068"></a>2068            # written in more than one CONTINUE record.
</span><span class="uncovered0"><a name="line2069"></a>2069            #
</span><span class="uncovered1"><a name="line2070"></a>2070            while block_length &gt;= continue_limit
</span><span class="uncovered0"><a name="line2071"></a>2071    
</span><span class="uncovered1"><a name="line2072"></a>2072                # We need to avoid the case where a string is continued in the first
</span><span class="uncovered0"><a name="line2073"></a>2073                # n bytes that contain the string header information.
</span><span class="uncovered1"><a name="line2074"></a>2074                #
</span><span class="uncovered0"><a name="line2075"></a>2075                header_length   = 3 # Min string + header size -1
</span><span class="uncovered1"><a name="line2076"></a>2076                space_remaining = continue_limit -written -continue
</span><span class="uncovered0"><a name="line2077"></a>2077    
</span><span class="uncovered1"><a name="line2078"></a>2078    
</span><span class="uncovered0"><a name="line2079"></a>2079                # Unicode data should only be split on char (2 byte) boundaries.
</span><span class="uncovered1"><a name="line2080"></a>2080                # Therefore, in some cases we need to reduce the amount of available
</span><span class="uncovered0"><a name="line2081"></a>2081                # space by 1 byte to ensure the correct alignment.
</span><span class="uncovered1"><a name="line2082"></a>2082                align = 0
</span><span class="uncovered0"><a name="line2083"></a>2083    
</span><span class="uncovered1"><a name="line2084"></a>2084                # Only applies to Unicode strings
</span><span class="uncovered0"><a name="line2085"></a>2085                if encoding == 1
</span><span class="uncovered1"><a name="line2086"></a>2086                    # Min string + header size -1
</span><span class="uncovered0"><a name="line2087"></a>2087                    header_length = 4
</span><span class="uncovered1"><a name="line2088"></a>2088    
</span><span class="uncovered0"><a name="line2089"></a>2089                    if space_remaining &gt; header_length
</span><span class="uncovered1"><a name="line2090"></a>2090                        # String contains 3 byte header =&gt; split on odd boundary
</span><span class="uncovered0"><a name="line2091"></a>2091                        if split_string == 0 and space_remaining % 2 != 1
</span><span class="uncovered1"><a name="line2092"></a>2092                            space_remaining -= 1
</span><span class="uncovered0"><a name="line2093"></a>2093                            align = 1
</span><span class="uncovered1"><a name="line2094"></a>2094                        # Split section without header =&gt; split on even boundary
</span><span class="uncovered0"><a name="line2095"></a>2095                        elsif split_string != 0 and space_remaining % 2 == 1
</span><span class="uncovered1"><a name="line2096"></a>2096                            space_remaining -= 1
</span><span class="uncovered0"><a name="line2097"></a>2097                            align = 1
</span><span class="uncovered1"><a name="line2098"></a>2098                        end
</span><span class="uncovered0"><a name="line2099"></a>2099    
</span><span class="uncovered1"><a name="line2100"></a>2100                        split_string = 1
</span><span class="uncovered0"><a name="line2101"></a>2101                    end
</span><span class="uncovered1"><a name="line2102"></a>2102                end
</span><span class="uncovered0"><a name="line2103"></a>2103 
</span><span class="uncovered1"><a name="line2104"></a>2104                if space_remaining &gt; header_length
</span><span class="uncovered0"><a name="line2105"></a>2105                    # Write as much as possible of the string in the current block
</span><span class="uncovered1"><a name="line2106"></a>2106                    written      += space_remaining
</span><span class="uncovered0"><a name="line2107"></a>2107    
</span><span class="uncovered1"><a name="line2108"></a>2108                    # Reduce the current block length by the amount written
</span><span class="uncovered0"><a name="line2109"></a>2109                    block_length -= continue_limit -continue -align
</span><span class="uncovered1"><a name="line2110"></a>2110    
</span><span class="uncovered0"><a name="line2111"></a>2111                    # Store the max size for this block
</span><span class="uncovered1"><a name="line2112"></a>2112                    block_sizes.push(continue_limit -align)
</span><span class="uncovered0"><a name="line2113"></a>2113 
</span><span class="uncovered1"><a name="line2114"></a>2114                    # If the current string was split then the next CONTINUE block
</span><span class="uncovered0"><a name="line2115"></a>2115                    # should have the string continue flag (grbit) set unless the
</span><span class="uncovered1"><a name="line2116"></a>2116                    # split string fits exactly into the remaining space.
</span><span class="uncovered0"><a name="line2117"></a>2117                    #
</span><span class="uncovered1"><a name="line2118"></a>2118                    if block_length &gt; 0
</span><span class="uncovered0"><a name="line2119"></a>2119                        continue = 1
</span><span class="uncovered1"><a name="line2120"></a>2120                    else
</span><span class="uncovered0"><a name="line2121"></a>2121                        continue = 0
</span><span class="uncovered1"><a name="line2122"></a>2122                    end
</span><span class="uncovered0"><a name="line2123"></a>2123                else
</span><span class="uncovered1"><a name="line2124"></a>2124                    # Store the max size for this block
</span><span class="uncovered0"><a name="line2125"></a>2125                    block_sizes.push(written +continue)
</span><span class="uncovered1"><a name="line2126"></a>2126    
</span><span class="uncovered0"><a name="line2127"></a>2127                    # Not enough space to start the string in the current block
</span><span class="uncovered1"><a name="line2128"></a>2128                    block_length -= continue_limit -space_remaining -continue
</span><span class="uncovered0"><a name="line2129"></a>2129                    continue = 0
</span><span class="uncovered1"><a name="line2130"></a>2130                end
</span><span class="uncovered0"><a name="line2131"></a>2131    
</span><span class="uncovered1"><a name="line2132"></a>2132                # If the string (or substr) is small enough we can write it in the
</span><span class="uncovered0"><a name="line2133"></a>2133                # new CONTINUE block. Else, go through the loop again to write it in
</span><span class="uncovered1"><a name="line2134"></a>2134                # one or more CONTINUE blocks
</span><span class="uncovered0"><a name="line2135"></a>2135                #
</span><span class="uncovered1"><a name="line2136"></a>2136                if block_length &lt; continue_limit
</span><span class="uncovered0"><a name="line2137"></a>2137                    written = block_length
</span><span class="uncovered1"><a name="line2138"></a>2138                else
</span><span class="uncovered0"><a name="line2139"></a>2139                    written = 0
</span><span class="uncovered1"><a name="line2140"></a>2140                end
</span><span class="uncovered0"><a name="line2141"></a>2141            end
</span><span class="uncovered1"><a name="line2142"></a>2142        end
</span><span class="uncovered0"><a name="line2143"></a>2143    
</span><span class="uncovered1"><a name="line2144"></a>2144        # Store the max size for the last block unless it is empty
</span><span class="uncovered0"><a name="line2145"></a>2145        block_sizes.push(written +continue) if written +continue != 0
</span><span class="uncovered1"><a name="line2146"></a>2146 
</span><span class="uncovered0"><a name="line2147"></a>2147        @str_block_sizes = block_sizes
</span><span class="uncovered1"><a name="line2148"></a>2148 
</span><span class="uncovered0"><a name="line2149"></a>2149        # Calculate the total length of the SST and associated CONTINUEs (if any).
</span><span class="uncovered1"><a name="line2150"></a>2150        # The SST record will have a length even if it contains no strings.
</span><span class="uncovered0"><a name="line2151"></a>2151        # This length is required to set the offsets in the BOUNDSHEET records since
</span><span class="uncovered1"><a name="line2152"></a>2152        # they must be written before the SST records
</span><span class="uncovered0"><a name="line2153"></a>2153        #
</span><span class="uncovered1"><a name="line2154"></a>2154        length  = 12
</span><span class="uncovered0"><a name="line2155"></a>2155        length    +=     block_sizes.shift if    block_sizes != 0 # SST
</span><span class="uncovered1"><a name="line2156"></a>2156        length    += 4 + block_sizes.shift while block_sizes != 0 # CONTINUEs
</span><span class="uncovered0"><a name="line2157"></a>2157    
</span><span class="uncovered1"><a name="line2158"></a>2158        return length
</span><span class="uncovered0"><a name="line2159"></a>2159    end
</span><span class="inferred1"><a name="line2160"></a>2160 
</span><span class="inferred0"><a name="line2161"></a>2161    ###############################################################################
</span><span class="inferred1"><a name="line2162"></a>2162    #
</span><span class="inferred0"><a name="line2163"></a>2163    # _store_shared_strings()
</span><span class="inferred1"><a name="line2164"></a>2164    #
</span><span class="inferred0"><a name="line2165"></a>2165    # Write all of the workbooks strings into an indexed array.
</span><span class="inferred1"><a name="line2166"></a>2166    #
</span><span class="inferred0"><a name="line2167"></a>2167    # See the comments in _calculate_shared_string_sizes() for more information.
</span><span class="inferred1"><a name="line2168"></a>2168    #
</span><span class="inferred0"><a name="line2169"></a>2169    # We also use this routine to record the offsets required by the EXTSST table.
</span><span class="inferred1"><a name="line2170"></a>2170    # In order to do this we first identify the first string in an EXTSST bucket
</span><span class="inferred0"><a name="line2171"></a>2171    # and then store its global and local offset within the SST table. The offset
</span><span class="inferred1"><a name="line2172"></a>2172    # occurs wherever the start of the bucket string is written out via append().
</span><span class="inferred0"><a name="line2173"></a>2173    #
</span><span class="marked1"><a name="line2174"></a>2174    def store_shared_strings
</span><span class="uncovered0"><a name="line2175"></a>2175        strings = str_array
</span><span class="uncovered1"><a name="line2176"></a>2176 
</span><span class="uncovered0"><a name="line2177"></a>2177        record              = 0x00FC   # Record identifier
</span><span class="uncovered1"><a name="line2178"></a>2178        length              = 0x0008   # Number of bytes to follow
</span><span class="uncovered0"><a name="line2179"></a>2179        total               = 0x0000
</span><span class="uncovered1"><a name="line2180"></a>2180    
</span><span class="uncovered0"><a name="line2181"></a>2181        # Iterate through the strings to calculate the CONTINUE block sizes
</span><span class="uncovered1"><a name="line2182"></a>2182        continue_limit = 8208
</span><span class="uncovered0"><a name="line2183"></a>2183        block_length   = 0
</span><span class="uncovered1"><a name="line2184"></a>2184        written        = 0
</span><span class="uncovered0"><a name="line2185"></a>2185        continue       = 0
</span><span class="uncovered1"><a name="line2186"></a>2186    
</span><span class="uncovered0"><a name="line2187"></a>2187        # The SST and CONTINUE block sizes have been pre-calculated by
</span><span class="uncovered1"><a name="line2188"></a>2188        # _calculate_shared_string_sizes()
</span><span class="uncovered0"><a name="line2189"></a>2189        block_sizes    = str_block_sizes
</span><span class="uncovered1"><a name="line2190"></a>2190 
</span><span class="uncovered0"><a name="line2191"></a>2191        # The SST record is required even if it contains no strings. Thus we will
</span><span class="uncovered1"><a name="line2192"></a>2192        # always have a length
</span><span class="uncovered0"><a name="line2193"></a>2193        #
</span><span class="uncovered1"><a name="line2194"></a>2194        if block_sizes.size != 0
</span><span class="uncovered0"><a name="line2195"></a>2195            length = 8 + block_sizes.shift
</span><span class="uncovered1"><a name="line2196"></a>2196        else
</span><span class="uncovered0"><a name="line2197"></a>2197            # No strings
</span><span class="uncovered1"><a name="line2198"></a>2198            length = 8
</span><span class="uncovered0"><a name="line2199"></a>2199        end
</span><span class="uncovered1"><a name="line2200"></a>2200 
</span><span class="uncovered0"><a name="line2201"></a>2201        # Initialise variables used to track EXTSST bucket offsets.
</span><span class="uncovered1"><a name="line2202"></a>2202        extsst_str_num  = -1
</span><span class="uncovered0"><a name="line2203"></a>2203        sst_block_start = @datasize
</span><span class="uncovered1"><a name="line2204"></a>2204 
</span><span class="uncovered0"><a name="line2205"></a>2205        # Write the SST block header information
</span><span class="uncovered1"><a name="line2206"></a>2206        header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line2207"></a>2207        data        = [@str_total, @str_unique].pack(&quot;VV&quot;)
</span><span class="uncovered1"><a name="line2208"></a>2208        append(header, data)
</span><span class="uncovered0"><a name="line2209"></a>2209 
</span><span class="uncovered1"><a name="line2210"></a>2210        # Iterate through the strings and write them out
</span><span class="uncovered0"><a name="line2211"></a>2211        @strings.each do |string|
</span><span class="uncovered1"><a name="line2212"></a>2212 
</span><span class="uncovered0"><a name="line2213"></a>2213            string_length = string.length
</span><span class="uncovered1"><a name="line2214"></a>2214            encoding      = [string].unpack(&quot;xx C&quot;)
</span><span class="uncovered0"><a name="line2215"></a>2215            split_string  = 0
</span><span class="uncovered1"><a name="line2216"></a>2216            bucket_string = 0 # Used to track EXTSST bucket offsets.
</span><span class="uncovered0"><a name="line2217"></a>2217 
</span><span class="uncovered1"><a name="line2218"></a>2218            # Check if the string is at the start of a EXTSST bucket.
</span><span class="uncovered0"><a name="line2219"></a>2219            extsst_str_num += 1
</span><span class="uncovered1"><a name="line2220"></a>2220            if extsst_str_num % @extsst_bucket_size == 0
</span><span class="uncovered0"><a name="line2221"></a>2221                bucket_string = 1
</span><span class="uncovered1"><a name="line2222"></a>2222            end
</span><span class="uncovered0"><a name="line2223"></a>2223 
</span><span class="uncovered1"><a name="line2224"></a>2224            # Block length is the total length of the strings that will be
</span><span class="uncovered0"><a name="line2225"></a>2225            # written out in a single SST or CONTINUE block.
</span><span class="uncovered1"><a name="line2226"></a>2226            #
</span><span class="uncovered0"><a name="line2227"></a>2227            block_length += string_length
</span><span class="uncovered1"><a name="line2228"></a>2228 
</span><span class="uncovered0"><a name="line2229"></a>2229            # We can write the string if it doesn't cross a CONTINUE boundary
</span><span class="uncovered1"><a name="line2230"></a>2230            if block_length &lt; continue_limit
</span><span class="uncovered0"><a name="line2231"></a>2231    
</span><span class="uncovered1"><a name="line2232"></a>2232                # Store location of EXTSST bucket string.
</span><span class="uncovered0"><a name="line2233"></a>2233                if bucket_string != 0
</span><span class="uncovered1"><a name="line2234"></a>2234                    global_offset   = @datasize
</span><span class="uncovered0"><a name="line2235"></a>2235                    local_offset    = @datasize - sst_block_start
</span><span class="uncovered1"><a name="line2236"></a>2236    
</span><span class="uncovered0"><a name="line2237"></a>2237                    @extsst_offsets.push([global_offset, local_offset])
</span><span class="uncovered1"><a name="line2238"></a>2238                    bucket_string = 0
</span><span class="uncovered0"><a name="line2239"></a>2239                end
</span><span class="uncovered1"><a name="line2240"></a>2240    
</span><span class="uncovered0"><a name="line2241"></a>2241                append(string)
</span><span class="uncovered1"><a name="line2242"></a>2242                written += string_length
</span><span class="uncovered0"><a name="line2243"></a>2243                next
</span><span class="uncovered1"><a name="line2244"></a>2244            end
</span><span class="uncovered0"><a name="line2245"></a>2245 
</span><span class="uncovered1"><a name="line2246"></a>2246            # Deal with the cases where the next string to be written will exceed
</span><span class="uncovered0"><a name="line2247"></a>2247            # the CONTINUE boundary. If the string is very long it may need to be
</span><span class="uncovered1"><a name="line2248"></a>2248            # written in more than one CONTINUE record.
</span><span class="uncovered0"><a name="line2249"></a>2249            #
</span><span class="uncovered1"><a name="line2250"></a>2250            while block_length &gt;= continue_limit
</span><span class="uncovered0"><a name="line2251"></a>2251    
</span><span class="uncovered1"><a name="line2252"></a>2252                # We need to avoid the case where a string is continued in the first
</span><span class="uncovered0"><a name="line2253"></a>2253                # n bytes that contain the string header information.
</span><span class="uncovered1"><a name="line2254"></a>2254                #
</span><span class="uncovered0"><a name="line2255"></a>2255                header_length   = 3 # Min string + header size -1
</span><span class="uncovered1"><a name="line2256"></a>2256                space_remaining = continue_limit -written -continue
</span><span class="uncovered0"><a name="line2257"></a>2257    
</span><span class="uncovered1"><a name="line2258"></a>2258    
</span><span class="uncovered0"><a name="line2259"></a>2259                # Unicode data should only be split on char (2 byte) boundaries.
</span><span class="uncovered1"><a name="line2260"></a>2260                # Therefore, in some cases we need to reduce the amount of available
</span><span class="uncovered0"><a name="line2261"></a>2261                # space by 1 byte to ensure the correct alignment.
</span><span class="uncovered1"><a name="line2262"></a>2262                align = 0
</span><span class="uncovered0"><a name="line2263"></a>2263    
</span><span class="uncovered1"><a name="line2264"></a>2264                # Only applies to Unicode strings
</span><span class="uncovered0"><a name="line2265"></a>2265                if encoding == 1
</span><span class="uncovered1"><a name="line2266"></a>2266                    # Min string + header size -1
</span><span class="uncovered0"><a name="line2267"></a>2267                    header_length = 4
</span><span class="uncovered1"><a name="line2268"></a>2268    
</span><span class="uncovered0"><a name="line2269"></a>2269                    if space_remaining &gt; header_length
</span><span class="uncovered1"><a name="line2270"></a>2270                        # String contains 3 byte header =&gt; split on odd boundary
</span><span class="uncovered0"><a name="line2271"></a>2271                        if split_string == 0 and space_remaining % 2 != 1
</span><span class="uncovered1"><a name="line2272"></a>2272                            space_remaining -= 1
</span><span class="uncovered0"><a name="line2273"></a>2273                            align = 1
</span><span class="uncovered1"><a name="line2274"></a>2274                        # Split section without header =&gt; split on even boundary
</span><span class="uncovered0"><a name="line2275"></a>2275                        elsif split_string != 0 and space_remaining % 2 == 1
</span><span class="uncovered1"><a name="line2276"></a>2276                            space_remaining -= 1
</span><span class="uncovered0"><a name="line2277"></a>2277                            align = 1
</span><span class="uncovered1"><a name="line2278"></a>2278                        end
</span><span class="uncovered0"><a name="line2279"></a>2279    
</span><span class="uncovered1"><a name="line2280"></a>2280                        split_string = 1
</span><span class="uncovered0"><a name="line2281"></a>2281                    end
</span><span class="uncovered1"><a name="line2282"></a>2282                end
</span><span class="uncovered0"><a name="line2283"></a>2283 
</span><span class="uncovered1"><a name="line2284"></a>2284                if space_remaining &gt; header_length
</span><span class="uncovered0"><a name="line2285"></a>2285                    # Write as much as possible of the string in the current block
</span><span class="uncovered1"><a name="line2286"></a>2286                    tmp = string[0, space_remaining]
</span><span class="uncovered0"><a name="line2287"></a>2287    
</span><span class="uncovered1"><a name="line2288"></a>2288                    # Store location of EXTSST bucket string.
</span><span class="uncovered0"><a name="line2289"></a>2289                    if bucket_string != 0
</span><span class="uncovered1"><a name="line2290"></a>2290                        global_offset   = @datasize
</span><span class="uncovered0"><a name="line2291"></a>2291                        local_offset    = @datasize - sst_block_start
</span><span class="uncovered1"><a name="line2292"></a>2292    
</span><span class="uncovered0"><a name="line2293"></a>2293                        @extsst_offsets.push([global_offset, local_offset])
</span><span class="uncovered1"><a name="line2294"></a>2294                        bucket_string = 0
</span><span class="uncovered0"><a name="line2295"></a>2295                    end
</span><span class="uncovered1"><a name="line2296"></a>2296    
</span><span class="uncovered0"><a name="line2297"></a>2297                    append(tmp)
</span><span class="uncovered1"><a name="line2298"></a>2298    
</span><span class="uncovered0"><a name="line2299"></a>2299    
</span><span class="uncovered1"><a name="line2300"></a>2300                    # The remainder will be written in the next block(s)
</span><span class="uncovered0"><a name="line2301"></a>2301                    string = string[space_remaining .. string.length-1]
</span><span class="uncovered1"><a name="line2302"></a>2302    
</span><span class="uncovered0"><a name="line2303"></a>2303                    # Reduce the current block length by the amount written
</span><span class="uncovered1"><a name="line2304"></a>2304                    block_length -= continue_limit -continue -align
</span><span class="uncovered0"><a name="line2305"></a>2305    
</span><span class="uncovered1"><a name="line2306"></a>2306                    # If the current string was split then the next CONTINUE block
</span><span class="uncovered0"><a name="line2307"></a>2307                    # should have the string continue flag (grbit) set unless the
</span><span class="uncovered1"><a name="line2308"></a>2308                    # split string fits exactly into the remaining space.
</span><span class="uncovered0"><a name="line2309"></a>2309                    #
</span><span class="uncovered1"><a name="line2310"></a>2310                    if block_length &gt; 0
</span><span class="uncovered0"><a name="line2311"></a>2311                        continue = 1
</span><span class="uncovered1"><a name="line2312"></a>2312                    else
</span><span class="uncovered0"><a name="line2313"></a>2313                        continue = 0
</span><span class="uncovered1"><a name="line2314"></a>2314                    end
</span><span class="uncovered0"><a name="line2315"></a>2315                else
</span><span class="uncovered1"><a name="line2316"></a>2316                    # Not enough space to start the string in the current block
</span><span class="uncovered0"><a name="line2317"></a>2317                    block_length -= continue_limit -space_remaining -continue
</span><span class="uncovered1"><a name="line2318"></a>2318                    continue = 0
</span><span class="uncovered0"><a name="line2319"></a>2319                end
</span><span class="uncovered1"><a name="line2320"></a>2320    
</span><span class="uncovered0"><a name="line2321"></a>2321                # Write the CONTINUE block header
</span><span class="uncovered1"><a name="line2322"></a>2322                if block_sizes.size != 0
</span><span class="uncovered0"><a name="line2323"></a>2323                    sst_block_start= @datasize # Reset EXTSST offset.
</span><span class="uncovered1"><a name="line2324"></a>2324    
</span><span class="uncovered0"><a name="line2325"></a>2325                    record         = 0x003C
</span><span class="uncovered1"><a name="line2326"></a>2326                    length         = block_sizes.shift
</span><span class="uncovered0"><a name="line2327"></a>2327    
</span><span class="uncovered1"><a name="line2328"></a>2328                    header         = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line2329"></a>2329                    header         = header + [encoding].pack(&quot;C&quot;) if continue != 0
</span><span class="uncovered1"><a name="line2330"></a>2330    
</span><span class="uncovered0"><a name="line2331"></a>2331                    append(header)
</span><span class="uncovered1"><a name="line2332"></a>2332                end
</span><span class="uncovered0"><a name="line2333"></a>2333    
</span><span class="uncovered1"><a name="line2334"></a>2334                # If the string (or substr) is small enough we can write it in the
</span><span class="uncovered0"><a name="line2335"></a>2335                # new CONTINUE block. Else, go through the loop again to write it in
</span><span class="uncovered1"><a name="line2336"></a>2336                # one or more CONTINUE blocks
</span><span class="uncovered0"><a name="line2337"></a>2337                #
</span><span class="uncovered1"><a name="line2338"></a>2338                if block_length &lt; continue_limit
</span><span class="uncovered0"><a name="line2339"></a>2339    
</span><span class="uncovered1"><a name="line2340"></a>2340                    # Store location of EXTSST bucket string.
</span><span class="uncovered0"><a name="line2341"></a>2341                    if bucket_string != 0
</span><span class="uncovered1"><a name="line2342"></a>2342                        global_offset   = @datasize
</span><span class="uncovered0"><a name="line2343"></a>2343                        local_offset    = @datasize - sst_block_start
</span><span class="uncovered1"><a name="line2344"></a>2344    
</span><span class="uncovered0"><a name="line2345"></a>2345                        @extsst_offsets.push([global_offset, local_offset])
</span><span class="uncovered1"><a name="line2346"></a>2346    
</span><span class="uncovered0"><a name="line2347"></a>2347                        bucket_string = 0
</span><span class="uncovered1"><a name="line2348"></a>2348                    end
</span><span class="uncovered0"><a name="line2349"></a>2349                    append(string)
</span><span class="uncovered1"><a name="line2350"></a>2350    
</span><span class="uncovered0"><a name="line2351"></a>2351                    written = block_length
</span><span class="uncovered1"><a name="line2352"></a>2352                else
</span><span class="uncovered0"><a name="line2353"></a>2353                    written = 0
</span><span class="uncovered1"><a name="line2354"></a>2354                end
</span><span class="uncovered0"><a name="line2355"></a>2355            end
</span><span class="uncovered1"><a name="line2356"></a>2356        end
</span><span class="uncovered0"><a name="line2357"></a>2357    end
</span><span class="inferred1"><a name="line2358"></a>2358 
</span><span class="inferred0"><a name="line2359"></a>2359    ###############################################################################
</span><span class="inferred1"><a name="line2360"></a>2360    #
</span><span class="inferred0"><a name="line2361"></a>2361    # _calculate_extsst_size
</span><span class="inferred1"><a name="line2362"></a>2362    #
</span><span class="inferred0"><a name="line2363"></a>2363    # The number of buckets used in the EXTSST is between 0 and 128. The number of
</span><span class="inferred1"><a name="line2364"></a>2364    # strings per bucket (bucket size) has a minimum value of 8 and a theoretical
</span><span class="inferred0"><a name="line2365"></a>2365    # maximum of 2^16. For &quot;number of strings&quot; &lt; 1024 there is a constant bucket
</span><span class="inferred1"><a name="line2366"></a>2366    # size of 8. The following algorithm generates the same size/bucket ratio
</span><span class="inferred0"><a name="line2367"></a>2367    # as Excel.
</span><span class="inferred1"><a name="line2368"></a>2368    #
</span><span class="marked0"><a name="line2369"></a>2369    def calculate_extsst_size
</span><span class="uncovered1"><a name="line2370"></a>2370        unique_strings  = @str_unique
</span><span class="uncovered0"><a name="line2371"></a>2371    
</span><span class="uncovered1"><a name="line2372"></a>2372        bucket_size
</span><span class="uncovered0"><a name="line2373"></a>2373        buckets
</span><span class="uncovered1"><a name="line2374"></a>2374    
</span><span class="uncovered0"><a name="line2375"></a>2375        if unique_strings &lt; 1024
</span><span class="uncovered1"><a name="line2376"></a>2376            bucket_size = 8
</span><span class="uncovered0"><a name="line2377"></a>2377        else
</span><span class="uncovered1"><a name="line2378"></a>2378            bucket_size = 1 + Integer(unique_strings / 128.0)
</span><span class="uncovered0"><a name="line2379"></a>2379        end
</span><span class="uncovered1"><a name="line2380"></a>2380    
</span><span class="uncovered0"><a name="line2381"></a>2381        buckets = Integer((unique_strings + bucket_size -1)  / Float(bucket_size))
</span><span class="uncovered1"><a name="line2382"></a>2382 
</span><span class="uncovered0"><a name="line2383"></a>2383        @extsst_buckets        = buckets 
</span><span class="uncovered1"><a name="line2384"></a>2384        @extsst_bucket_size    = bucket_size
</span><span class="uncovered0"><a name="line2385"></a>2385 
</span><span class="uncovered1"><a name="line2386"></a>2386        return 6 + 8 * buckets
</span><span class="uncovered0"><a name="line2387"></a>2387    end
</span><span class="inferred1"><a name="line2388"></a>2388 
</span><span class="inferred0"><a name="line2389"></a>2389    ###############################################################################
</span><span class="inferred1"><a name="line2390"></a>2390    #
</span><span class="inferred0"><a name="line2391"></a>2391    # _store_extsst
</span><span class="inferred1"><a name="line2392"></a>2392    #
</span><span class="inferred0"><a name="line2393"></a>2393    # Write EXTSST table using the offsets calculated in _store_shared_strings().
</span><span class="inferred1"><a name="line2394"></a>2394    #
</span><span class="marked0"><a name="line2395"></a>2395    def store_extsst
</span><span class="uncovered1"><a name="line2396"></a>2396        offsets     = @extsst_offsets
</span><span class="uncovered0"><a name="line2397"></a>2397        bucket_size = @extsst_bucket_size
</span><span class="uncovered1"><a name="line2398"></a>2398    
</span><span class="uncovered0"><a name="line2399"></a>2399        record      = 0x00FF                 # Record identifier
</span><span class="uncovered1"><a name="line2400"></a>2400        length      = 2 + 8 * offsets.size   # Bytes to follow
</span><span class="uncovered0"><a name="line2401"></a>2401    
</span><span class="uncovered1"><a name="line2402"></a>2402        header      = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line2403"></a>2403        data        = [bucket_size].pack('v')
</span><span class="uncovered1"><a name="line2404"></a>2404 
</span><span class="uncovered0"><a name="line2405"></a>2405        offsets.each do |offset|
</span><span class="uncovered1"><a name="line2406"></a>2406           data = data + [offset[0], offset[1], 0].pack('Vvv')
</span><span class="uncovered0"><a name="line2407"></a>2407        end
</span><span class="uncovered1"><a name="line2408"></a>2408    
</span><span class="uncovered0"><a name="line2409"></a>2409        append(header, data)
</span><span class="uncovered1"><a name="line2410"></a>2410    
</span><span class="uncovered0"><a name="line2411"></a>2411    end
</span><span class="inferred1"><a name="line2412"></a>2412 
</span><span class="inferred0"><a name="line2413"></a>2413    #
</span><span class="inferred1"><a name="line2414"></a>2414    # Methods related to comments and MSO objects.
</span><span class="inferred0"><a name="line2415"></a>2415    #
</span><span class="inferred1"><a name="line2416"></a>2416    
</span><span class="inferred0"><a name="line2417"></a>2417    ###############################################################################
</span><span class="inferred1"><a name="line2418"></a>2418    #
</span><span class="inferred0"><a name="line2419"></a>2419    # _add_mso_drawing_group()
</span><span class="inferred1"><a name="line2420"></a>2420    #
</span><span class="inferred0"><a name="line2421"></a>2421    # Write the MSODRAWINGGROUP record that keeps track of the Escher drawing
</span><span class="inferred1"><a name="line2422"></a>2422    # objects in the file such as images, comments and filters.
</span><span class="inferred0"><a name="line2423"></a>2423    #
</span><span class="marked1"><a name="line2424"></a>2424    def add_mso_drawing_group
</span><span class="uncovered0"><a name="line2425"></a>2425        return unless @mso_size != 0
</span><span class="uncovered1"><a name="line2426"></a>2426    
</span><span class="uncovered0"><a name="line2427"></a>2427        record  = 0x00EB               # Record identifier
</span><span class="uncovered1"><a name="line2428"></a>2428        length  = 0x0000               # Number of bytes to follow
</span><span class="uncovered0"><a name="line2429"></a>2429    
</span><span class="uncovered1"><a name="line2430"></a>2430        data    = store_mso_dgg_container
</span><span class="uncovered0"><a name="line2431"></a>2431        data    = data + store_mso_dgg(@mso_clusters)
</span><span class="uncovered1"><a name="line2432"></a>2432        data    = data + store_mso_bstore_container
</span><span class="uncovered0"><a name="line2433"></a>2433        @images_data.each do |image|
</span><span class="uncovered1"><a name="line2434"></a>2434           data = data + store_mso_images(image)
</span><span class="uncovered0"><a name="line2435"></a>2435        end
</span><span class="uncovered1"><a name="line2436"></a>2436        data    = data + store_mso_opt
</span><span class="uncovered0"><a name="line2437"></a>2437        data    = data + store_mso_split_menu_colors
</span><span class="uncovered1"><a name="line2438"></a>2438    
</span><span class="uncovered0"><a name="line2439"></a>2439        length  = data.length
</span><span class="uncovered1"><a name="line2440"></a>2440        header  = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line2441"></a>2441    
</span><span class="uncovered1"><a name="line2442"></a>2442        add_mso_drawing_group_continue(header . data)
</span><span class="uncovered0"><a name="line2443"></a>2443    
</span><span class="uncovered1"><a name="line2444"></a>2444        return header + data # For testing only.
</span><span class="uncovered0"><a name="line2445"></a>2445    end
</span><span class="inferred1"><a name="line2446"></a>2446 
</span><span class="inferred0"><a name="line2447"></a>2447    ###############################################################################
</span><span class="inferred1"><a name="line2448"></a>2448    #
</span><span class="inferred0"><a name="line2449"></a>2449    # _add_mso_drawing_group_continue()
</span><span class="inferred1"><a name="line2450"></a>2450    #
</span><span class="inferred0"><a name="line2451"></a>2451    # See first the Spreadsheet::WriteExcel::BIFFwriter::_add_continue() method.
</span><span class="inferred1"><a name="line2452"></a>2452    #
</span><span class="inferred0"><a name="line2453"></a>2453    # Add specialised CONTINUE headers to large MSODRAWINGGROUP data block.
</span><span class="inferred1"><a name="line2454"></a>2454    # We use the Excel 97 max block size of 8228 - 4 bytes for the header = 8224.
</span><span class="inferred0"><a name="line2455"></a>2455    #
</span><span class="inferred1"><a name="line2456"></a>2456    # The structure depends on the size of the data block:
</span><span class="inferred0"><a name="line2457"></a>2457    #
</span><span class="inferred1"><a name="line2458"></a>2458    #     Case 1:  &lt;=   8224 bytes      1 MSODRAWINGGROUP
</span><span class="inferred0"><a name="line2459"></a>2459    #     Case 2:  &lt;= 2*8224 bytes      1 MSODRAWINGGROUP + 1 CONTINUE
</span><span class="inferred1"><a name="line2460"></a>2460    #     Case 3:  &gt;  2*8224 bytes      2 MSODRAWINGGROUP + n CONTINUE
</span><span class="inferred0"><a name="line2461"></a>2461    #
</span><span class="marked1"><a name="line2462"></a>2462    def add_mso_drawing_group_continue(data)
</span><span class="uncovered0"><a name="line2463"></a>2463        limit       = 8228 -4
</span><span class="uncovered1"><a name="line2464"></a>2464        mso_group   = 0x00EB # Record identifier
</span><span class="uncovered0"><a name="line2465"></a>2465        continue    = 0x003C # Record identifier
</span><span class="uncovered1"><a name="line2466"></a>2466        block_count = 1
</span><span class="uncovered0"><a name="line2467"></a>2467    
</span><span class="uncovered1"><a name="line2468"></a>2468        # Ignore the base class _add_continue() method.
</span><span class="uncovered0"><a name="line2469"></a>2469        @ignore_continue = 1
</span><span class="uncovered1"><a name="line2470"></a>2470    
</span><span class="uncovered0"><a name="line2471"></a>2471        # Case 1 above. Just return the data as it is.
</span><span class="uncovered1"><a name="line2472"></a>2472        if data.length &lt;= limit
</span><span class="uncovered0"><a name="line2473"></a>2473            append(data)
</span><span class="uncovered1"><a name="line2474"></a>2474            return
</span><span class="uncovered0"><a name="line2475"></a>2475        end
</span><span class="uncovered1"><a name="line2476"></a>2476    
</span><span class="uncovered0"><a name="line2477"></a>2477        # Change length field of the first MSODRAWINGGROUP block. Case 2 and 3.
</span><span class="uncovered1"><a name="line2478"></a>2478        tmp = data.dup
</span><span class="uncovered0"><a name="line2479"></a>2479        tmp[0, limit + 4] = &quot;&quot;
</span><span class="uncovered1"><a name="line2480"></a>2480        tmp[2, 2] = [limit].pack('v')
</span><span class="uncovered0"><a name="line2481"></a>2481        append(tmp)
</span><span class="uncovered1"><a name="line2482"></a>2482 
</span><span class="uncovered0"><a name="line2483"></a>2483        # Add MSODRAWINGGROUP and CONTINUE blocks for Case 3 above.
</span><span class="uncovered1"><a name="line2484"></a>2484        while data.length &gt; limit
</span><span class="uncovered0"><a name="line2485"></a>2485            if block_count == 1
</span><span class="uncovered1"><a name="line2486"></a>2486                # Add extra MSODRAWINGGROUP block header.
</span><span class="uncovered0"><a name="line2487"></a>2487                header = [mso_group, limit].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2488"></a>2488                block_count += 1
</span><span class="uncovered0"><a name="line2489"></a>2489            else
</span><span class="uncovered1"><a name="line2490"></a>2490                # Add normal CONTINUE header.
</span><span class="uncovered0"><a name="line2491"></a>2491                header = [continue, limit].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2492"></a>2492            end
</span><span class="uncovered0"><a name="line2493"></a>2493    
</span><span class="uncovered1"><a name="line2494"></a>2494            tmp = data.dup
</span><span class="uncovered0"><a name="line2495"></a>2495            tmp[0, limit] = ''
</span><span class="uncovered1"><a name="line2496"></a>2496            append(header, tmp)
</span><span class="uncovered0"><a name="line2497"></a>2497        end
</span><span class="uncovered1"><a name="line2498"></a>2498 
</span><span class="uncovered0"><a name="line2499"></a>2499        # Last CONTINUE block for remaining data. Case 2 and 3 above.
</span><span class="uncovered1"><a name="line2500"></a>2500        header = [continue, data.length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line2501"></a>2501        append(header, data)
</span><span class="uncovered1"><a name="line2502"></a>2502 
</span><span class="uncovered0"><a name="line2503"></a>2503        # Turn the base class _add_continue() method back on.
</span><span class="uncovered1"><a name="line2504"></a>2504        @ignore_continue = 0
</span><span class="uncovered0"><a name="line2505"></a>2505    end
</span><span class="inferred1"><a name="line2506"></a>2506 
</span><span class="inferred0"><a name="line2507"></a>2507    ###############################################################################
</span><span class="inferred1"><a name="line2508"></a>2508    #
</span><span class="inferred0"><a name="line2509"></a>2509    # _store_mso_dgg_container()
</span><span class="inferred1"><a name="line2510"></a>2510    #
</span><span class="inferred0"><a name="line2511"></a>2511    # Write the Escher DggContainer record that is part of MSODRAWINGGROUP.
</span><span class="inferred1"><a name="line2512"></a>2512    #
</span><span class="marked0"><a name="line2513"></a>2513    def store_mso_dgg_container
</span><span class="uncovered1"><a name="line2514"></a>2514        type        = 0xF000
</span><span class="uncovered0"><a name="line2515"></a>2515        version     = 15
</span><span class="uncovered1"><a name="line2516"></a>2516        instance    = 0
</span><span class="uncovered0"><a name="line2517"></a>2517        data        = ''
</span><span class="uncovered1"><a name="line2518"></a>2518        length      = @mso_size -12 # -4 (biff header) -8 (for this).
</span><span class="uncovered0"><a name="line2519"></a>2519 
</span><span class="uncovered1"><a name="line2520"></a>2520        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line2521"></a>2521    end
</span><span class="inferred1"><a name="line2522"></a>2522    
</span><span class="inferred0"><a name="line2523"></a>2523    
</span><span class="inferred1"><a name="line2524"></a>2524    ###############################################################################
</span><span class="inferred0"><a name="line2525"></a>2525    #
</span><span class="inferred1"><a name="line2526"></a>2526    # _store_mso_dgg()
</span><span class="inferred0"><a name="line2527"></a>2527    #    my $max_spid        = $_[0];
</span><span class="inferred1"><a name="line2528"></a>2528    #    my $num_clusters    = $_[1];
</span><span class="inferred0"><a name="line2529"></a>2529    #    my $shapes_saved    = $_[2];
</span><span class="inferred1"><a name="line2530"></a>2530    #    my $drawings_saved  = $_[3];
</span><span class="inferred0"><a name="line2531"></a>2531    #    my $clusters        = $_[4];
</span><span class="inferred1"><a name="line2532"></a>2532    #
</span><span class="inferred0"><a name="line2533"></a>2533    # Write the Escher Dgg record that is part of MSODRAWINGGROUP.
</span><span class="inferred1"><a name="line2534"></a>2534    #
</span><span class="marked0"><a name="line2535"></a>2535    def store_mso_dgg(max_spid, num_clusters, shapes_saved, drawings_saved, clusters)
</span><span class="uncovered1"><a name="line2536"></a>2536        type            = 0xF006
</span><span class="uncovered0"><a name="line2537"></a>2537        version         = 0
</span><span class="uncovered1"><a name="line2538"></a>2538        instance        = 0
</span><span class="uncovered0"><a name="line2539"></a>2539        data            = ''
</span><span class="uncovered1"><a name="line2540"></a>2540 
</span><span class="uncovered0"><a name="line2541"></a>2541        data            = [max_spid, num_clusters,
</span><span class="uncovered1"><a name="line2542"></a>2542                           shapes_saved, drawings_saved].pack(&quot;VVVV&quot;)
</span><span class="uncovered0"><a name="line2543"></a>2543 
</span><span class="uncovered1"><a name="line2544"></a>2544        clusters.each do |aref|
</span><span class="uncovered0"><a name="line2545"></a>2545            drawing_id      = aref[0]
</span><span class="uncovered1"><a name="line2546"></a>2546            shape_ids_used  = aref[1]
</span><span class="uncovered0"><a name="line2547"></a>2547    
</span><span class="uncovered1"><a name="line2548"></a>2548            data            = data + [drawing_id, shape_ids_used].pack(&quot;VV&quot;)  
</span><span class="uncovered0"><a name="line2549"></a>2549        end
</span><span class="uncovered1"><a name="line2550"></a>2550 
</span><span class="uncovered0"><a name="line2551"></a>2551        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line2552"></a>2552    end
</span><span class="inferred0"><a name="line2553"></a>2553 
</span><span class="inferred1"><a name="line2554"></a>2554    ###############################################################################
</span><span class="inferred0"><a name="line2555"></a>2555    #
</span><span class="inferred1"><a name="line2556"></a>2556    # _store_mso_bstore_container()
</span><span class="inferred0"><a name="line2557"></a>2557    #
</span><span class="inferred1"><a name="line2558"></a>2558    # Write the Escher BstoreContainer record that is part of MSODRAWINGGROUP.
</span><span class="inferred0"><a name="line2559"></a>2559    #
</span><span class="marked1"><a name="line2560"></a>2560    def store_mso_bstore_container
</span><span class="uncovered0"><a name="line2561"></a>2561        return '' if @images_size == 0
</span><span class="uncovered1"><a name="line2562"></a>2562    
</span><span class="uncovered0"><a name="line2563"></a>2563        type        = 0xF001
</span><span class="uncovered1"><a name="line2564"></a>2564        version     = 15
</span><span class="uncovered0"><a name="line2565"></a>2565        instance    = @images_data.size          # Number of images.
</span><span class="uncovered1"><a name="line2566"></a>2566        data        = ''
</span><span class="uncovered0"><a name="line2567"></a>2567        length      = @images_size +8 *instance
</span><span class="uncovered1"><a name="line2568"></a>2568    
</span><span class="uncovered0"><a name="line2569"></a>2569        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line2570"></a>2570    end
</span><span class="inferred0"><a name="line2571"></a>2571 
</span><span class="inferred1"><a name="line2572"></a>2572    ###############################################################################
</span><span class="inferred0"><a name="line2573"></a>2573    #
</span><span class="inferred1"><a name="line2574"></a>2574    # _store_mso_images()
</span><span class="inferred0"><a name="line2575"></a>2575    #    ref_count   = $_[0]
</span><span class="inferred1"><a name="line2576"></a>2576    #    image_type  = $_[1]
</span><span class="inferred0"><a name="line2577"></a>2577    #    image       = $_[2]
</span><span class="inferred1"><a name="line2578"></a>2578    #    size        = $_[3]
</span><span class="inferred0"><a name="line2579"></a>2579    #    checksum1   = $_[4]
</span><span class="inferred1"><a name="line2580"></a>2580    #    checksum2   = $_[5]
</span><span class="inferred0"><a name="line2581"></a>2581    #
</span><span class="inferred1"><a name="line2582"></a>2582    # Write the Escher BstoreContainer record that is part of MSODRAWINGGROUP.
</span><span class="inferred0"><a name="line2583"></a>2583    #
</span><span class="marked1"><a name="line2584"></a>2584    def store_mso_images(ref_count, image_type, image, size, checksum1, checksum2)
</span><span class="uncovered0"><a name="line2585"></a>2585        blip_store_entry =  store_mso_blip_store_entry(
</span><span class="uncovered1"><a name="line2586"></a>2586                               ref_count,
</span><span class="uncovered0"><a name="line2587"></a>2587                               image_type,
</span><span class="uncovered1"><a name="line2588"></a>2588                               size,
</span><span class="uncovered0"><a name="line2589"></a>2589                               checksum1)
</span><span class="uncovered1"><a name="line2590"></a>2590    
</span><span class="uncovered0"><a name="line2591"></a>2591        blip             =  store_mso_blip(
</span><span class="uncovered1"><a name="line2592"></a>2592                               image_type,
</span><span class="uncovered0"><a name="line2593"></a>2593                               image,
</span><span class="uncovered1"><a name="line2594"></a>2594                               size,
</span><span class="uncovered0"><a name="line2595"></a>2595                               checksum1,
</span><span class="uncovered1"><a name="line2596"></a>2596                               checksum2)
</span><span class="uncovered0"><a name="line2597"></a>2597    
</span><span class="uncovered1"><a name="line2598"></a>2598        return blip_store_entry + blip
</span><span class="uncovered0"><a name="line2599"></a>2599    end
</span><span class="inferred1"><a name="line2600"></a>2600 
</span><span class="inferred0"><a name="line2601"></a>2601    ###############################################################################
</span><span class="inferred1"><a name="line2602"></a>2602    #
</span><span class="inferred0"><a name="line2603"></a>2603    # _store_mso_blip_store_entry()
</span><span class="inferred1"><a name="line2604"></a>2604    #    ref_count   = $_[0]
</span><span class="inferred0"><a name="line2605"></a>2605    #    image_type  = $_[1]
</span><span class="inferred1"><a name="line2606"></a>2606    #    size        = $_[2]
</span><span class="inferred0"><a name="line2607"></a>2607    #    checksum1   = $_[3]
</span><span class="inferred1"><a name="line2608"></a>2608    #
</span><span class="inferred0"><a name="line2609"></a>2609    # Write the Escher BlipStoreEntry record that is part of MSODRAWINGGROUP.
</span><span class="inferred1"><a name="line2610"></a>2610    #
</span><span class="marked0"><a name="line2611"></a>2611    def store_mso_blip_store_entry(ref_count, image_type, size, checksum1)
</span><span class="uncovered1"><a name="line2612"></a>2612        type        = 0xF007
</span><span class="uncovered0"><a name="line2613"></a>2613        version     = 2
</span><span class="uncovered1"><a name="line2614"></a>2614        instance    = image_type
</span><span class="uncovered0"><a name="line2615"></a>2615        length      = size +61
</span><span class="uncovered1"><a name="line2616"></a>2616        data        = [image_type].pack('C')  +    # Win32
</span><span class="uncovered0"><a name="line2617"></a>2617                      [image_type].pack('C')  +    # Mac
</span><span class="uncovered1"><a name="line2618"></a>2618                      [checksum1].pack('H*')  +    # Uid checksum
</span><span class="uncovered0"><a name="line2619"></a>2619                      [0xFF].pack('v')        +    # Tag
</span><span class="uncovered1"><a name="line2620"></a>2620                      [size +25].pack('V')    +    # Next Blip size
</span><span class="uncovered0"><a name="line2621"></a>2621                      [ref_count].pack('V')   +    # Image ref count
</span><span class="uncovered1"><a name="line2622"></a>2622                      [0x00000000].pack('V')  +    # File offset
</span><span class="uncovered0"><a name="line2623"></a>2623                      [0x00].pack('C')        +    # Usage
</span><span class="uncovered1"><a name="line2624"></a>2624                      [0x00].pack('C')        +    # Name length
</span><span class="uncovered0"><a name="line2625"></a>2625                      [0x00].pack('C')        +    # Unused
</span><span class="uncovered1"><a name="line2626"></a>2626                      [0x00].pack('C')             # Unused
</span><span class="uncovered0"><a name="line2627"></a>2627 
</span><span class="uncovered1"><a name="line2628"></a>2628        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line2629"></a>2629    end
</span><span class="inferred1"><a name="line2630"></a>2630 
</span><span class="inferred0"><a name="line2631"></a>2631    ###############################################################################
</span><span class="inferred1"><a name="line2632"></a>2632    #
</span><span class="inferred0"><a name="line2633"></a>2633    # _store_mso_blip()
</span><span class="inferred1"><a name="line2634"></a>2634    #    image_type  = $_[0]
</span><span class="inferred0"><a name="line2635"></a>2635    #    image_data  = $_[1]
</span><span class="inferred1"><a name="line2636"></a>2636    #    size        = $_[2]
</span><span class="inferred0"><a name="line2637"></a>2637    #    checksum1   = $_[3]
</span><span class="inferred1"><a name="line2638"></a>2638    #    checksum2   = $_[4]
</span><span class="inferred0"><a name="line2639"></a>2639    #
</span><span class="inferred1"><a name="line2640"></a>2640    # Write the Escher Blip record that is part of MSODRAWINGGROUP.
</span><span class="inferred0"><a name="line2641"></a>2641    #
</span><span class="marked1"><a name="line2642"></a>2642    def store_mso_blip(image_type, image_data, size, checksum1, checksum2)
</span><span class="uncovered0"><a name="line2643"></a>2643        instance = 0x046A if image_type == 5 # JPG
</span><span class="uncovered1"><a name="line2644"></a>2644        instance = 0x06E0 if image_type == 6 # PNG
</span><span class="uncovered0"><a name="line2645"></a>2645        instance = 0x07A9 if image_type == 7 # BMP
</span><span class="uncovered1"><a name="line2646"></a>2646    
</span><span class="uncovered0"><a name="line2647"></a>2647        # BMPs contain an extra checksum for the stripped data.
</span><span class="uncovered1"><a name="line2648"></a>2648        if image_type == 7
</span><span class="uncovered0"><a name="line2649"></a>2649            checksum1 = checksum2 + checksum1
</span><span class="uncovered1"><a name="line2650"></a>2650        end
</span><span class="uncovered0"><a name="line2651"></a>2651    
</span><span class="uncovered1"><a name="line2652"></a>2652        type        = 0xF018 + image_type
</span><span class="uncovered0"><a name="line2653"></a>2653        version     = 0x0000
</span><span class="uncovered1"><a name="line2654"></a>2654        length      = size +17
</span><span class="uncovered0"><a name="line2655"></a>2655        data        = [checksum1].pack('H*')  +     # Uid checksum
</span><span class="uncovered1"><a name="line2656"></a>2656                      [0xFF].pack('C')        +     # Tag
</span><span class="uncovered0"><a name="line2657"></a>2657                      image_data                   # Image
</span><span class="uncovered1"><a name="line2658"></a>2658    
</span><span class="uncovered0"><a name="line2659"></a>2659        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line2660"></a>2660    end
</span><span class="inferred0"><a name="line2661"></a>2661 
</span><span class="inferred1"><a name="line2662"></a>2662    ###############################################################################
</span><span class="inferred0"><a name="line2663"></a>2663    #
</span><span class="inferred1"><a name="line2664"></a>2664    # _store_mso_opt()
</span><span class="inferred0"><a name="line2665"></a>2665    #
</span><span class="inferred1"><a name="line2666"></a>2666    # Write the Escher Opt record that is part of MSODRAWINGGROUP.
</span><span class="inferred0"><a name="line2667"></a>2667    #
</span><span class="marked1"><a name="line2668"></a>2668    def store_mso_opt
</span><span class="uncovered0"><a name="line2669"></a>2669        type        = 0xF00B
</span><span class="uncovered1"><a name="line2670"></a>2670        version     = 3
</span><span class="uncovered0"><a name="line2671"></a>2671        instance    = 3
</span><span class="uncovered1"><a name="line2672"></a>2672        data        = ''
</span><span class="uncovered0"><a name="line2673"></a>2673        length      = 18
</span><span class="uncovered1"><a name="line2674"></a>2674    
</span><span class="uncovered0"><a name="line2675"></a>2675        data        = ['BF0008000800810109000008C0014000'+'0008'].pack(&quot;H*&quot;) .
</span><span class="uncovered1"><a name="line2676"></a>2676 
</span><span class="uncovered0"><a name="line2677"></a>2677        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line2678"></a>2678    end
</span><span class="inferred0"><a name="line2679"></a>2679 
</span><span class="inferred1"><a name="line2680"></a>2680    ###############################################################################
</span><span class="inferred0"><a name="line2681"></a>2681    #
</span><span class="inferred1"><a name="line2682"></a>2682    # _store_mso_split_menu_colors()
</span><span class="inferred0"><a name="line2683"></a>2683    #
</span><span class="inferred1"><a name="line2684"></a>2684    # Write the Escher SplitMenuColors record that is part of MSODRAWINGGROUP.
</span><span class="inferred0"><a name="line2685"></a>2685    #
</span><span class="marked1"><a name="line2686"></a>2686    def _store_mso_split_menu_colors
</span><span class="uncovered0"><a name="line2687"></a>2687        type        = 0xF11E
</span><span class="uncovered1"><a name="line2688"></a>2688        version     = 0
</span><span class="uncovered0"><a name="line2689"></a>2689        instance    = 4
</span><span class="uncovered1"><a name="line2690"></a>2690        data        = ''
</span><span class="uncovered0"><a name="line2691"></a>2691        length      = 16
</span><span class="uncovered1"><a name="line2692"></a>2692    
</span><span class="uncovered0"><a name="line2693"></a>2693        data        = ['0D0000080C00000817000008F7000010'].pack(&quot;H*&quot;)
</span><span class="uncovered1"><a name="line2694"></a>2694    
</span><span class="uncovered0"><a name="line2695"></a>2695        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line2696"></a>2696    end
</span><span class="uncovered0"><a name="line2697"></a>2697 
</span><span class="uncovered1"><a name="line2698"></a>2698 end
</span><span class="inferred0"><a name="line2699"></a>2699 
</span><span class="inferred1"><a name="line2700"></a>2700 =begin
</span><span class="inferred0"><a name="line2701"></a>2701 = Notes on the difference between Workbook.pm and workbook.rb
</span><span class="inferred1"><a name="line2702"></a>2702 ---deprecated methods
</span><span class="inferred0"><a name="line2703"></a>2703    I generally elminated any deprecated methods.  That means no 'write'
</span><span class="inferred1"><a name="line2704"></a>2704    methods.
</span><span class="inferred0"><a name="line2705"></a>2705 ---date_system
</span><span class="inferred1"><a name="line2706"></a>2706    This is the 1904 attribute.  However, since a number can't be a method,
</span><span class="inferred0"><a name="line2707"></a>2707    this doesn't work very well for attribute_accessor.  Besides, date_system
</span><span class="inferred1"><a name="line2708"></a>2708    is more descriptive.
</span><span class="inferred0"><a name="line2709"></a>2709 =end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
