<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>C:/SVN_work/spreadsheet-writeexcel/lib/spreadsheet/worksheet.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Fri Mar 06 14:35:10 +0900 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='SVN_work-spreadsheet-writeexcel-lib-spreadsheet-worksheet_rb.html'>C:/SVN_work/spreadsheet-writeexcel/lib/spreadsheet/worksheet.rb</a>
        </td>
      <td class='lines_total'><tt>5964</tt>
        </td>
      <td class='lines_code'><tt>2977</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>55.0%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='55'/>
                  <td class='uncovered' width='45'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>37.1%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='37'/>
                  <td class='uncovered' width='63'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked0"><a name="line1"></a>   1 require 'format'
</span><span class="marked1"><a name="line2"></a>   2 require 'formula'
</span><span class="inferred0"><a name="line3"></a>   3 
</span><span class="marked1"><a name="line4"></a>   4 class MaxSizeError &lt; StandardError; end
</span><span class="inferred0"><a name="line5"></a>   5 
</span><span class="marked1"><a name="line6"></a>   6 class Worksheet &lt; BIFFWriter
</span><span class="inferred0"><a name="line7"></a>   7 
</span><span class="marked1"><a name="line8"></a>   8    RowMax = 65536
</span><span class="marked0"><a name="line9"></a>   9    ColMax = 256
</span><span class="marked1"><a name="line10"></a>  10    StrMax = 0
</span><span class="marked0"><a name="line11"></a>  11    Buffer = 4096
</span><span class="inferred1"><a name="line12"></a>  12 
</span><span class="marked0"><a name="line13"></a>  13    attr_reader :name, :encoding, :xf_index, :index, :type, :images_array
</span><span class="marked1"><a name="line14"></a>  14    attr_reader :filter_area, :filter_count
</span><span class="marked0"><a name="line15"></a>  15    attr_reader :title_rowmin, :title_rowmax, :title_colmin, :title_colmax
</span><span class="marked1"><a name="line16"></a>  16    attr_reader :print_rowmin, :print_rowmax, :print_colmin, :print_colmax
</span><span class="marked0"><a name="line17"></a>  17    attr_accessor :index, :colinfo, :selection, :offset, :selected, :hidden, :active
</span><span class="marked1"><a name="line18"></a>  18    attr_accessor :object_ids
</span><span class="inferred0"><a name="line19"></a>  19 
</span><span class="inferred1"><a name="line20"></a>  20    ###############################################################################
</span><span class="inferred0"><a name="line21"></a>  21    #
</span><span class="inferred1"><a name="line22"></a>  22    # new()
</span><span class="inferred0"><a name="line23"></a>  23    #
</span><span class="inferred1"><a name="line24"></a>  24    # Constructor. Creates a new Worksheet object from a BIFFwriter object
</span><span class="inferred0"><a name="line25"></a>  25    #
</span><span class="marked1"><a name="line26"></a>  26    def initialize(*args)
</span><span class="marked0"><a name="line27"></a>  27       super
</span><span class="inferred1"><a name="line28"></a>  28 
</span><span class="marked0"><a name="line29"></a>  29       @name                = args[0]
</span><span class="marked1"><a name="line30"></a>  30       @index               = args[1]
</span><span class="marked0"><a name="line31"></a>  31       @encoding            = args[2]
</span><span class="marked1"><a name="line32"></a>  32       @active_sheet        = args[3]
</span><span class="marked0"><a name="line33"></a>  33       @first_sheet         = args[4]
</span><span class="marked1"><a name="line34"></a>  34       @url_format          = args[5]
</span><span class="marked0"><a name="line35"></a>  35       @parser              = args[6]
</span><span class="marked1"><a name="line36"></a>  36       @tempdir             = args[7]
</span><span class="marked0"><a name="line37"></a>  37       @str_total           = args[8]  || 0
</span><span class="marked1"><a name="line38"></a>  38       @str_unique          = args[9]  || 0
</span><span class="marked0"><a name="line39"></a>  39       @str_table           = args[10] || {}
</span><span class="marked1"><a name="line40"></a>  40       @date_1904           = args[11]
</span><span class="marked0"><a name="line41"></a>  41       @compatibility       = args[12]
</span><span class="inferred1"><a name="line42"></a>  42 
</span><span class="marked0"><a name="line43"></a>  43       @table               = []
</span><span class="marked1"><a name="line44"></a>  44       @row_data            = {}
</span><span class="inferred0"><a name="line45"></a>  45 
</span><span class="marked1"><a name="line46"></a>  46       @type                = 0x0000
</span><span class="marked0"><a name="line47"></a>  47       @ext_sheets          = []
</span><span class="marked1"><a name="line48"></a>  48       @using_tmpfile       = 0    # _initialize not coverted yet.
</span><span class="marked0"><a name="line49"></a>  49       @filehandle          = &quot;&quot;
</span><span class="marked1"><a name="line50"></a>  50       @fileclosed          = 0
</span><span class="marked0"><a name="line51"></a>  51       @offset              = 0
</span><span class="marked1"><a name="line52"></a>  52       @xls_rowmax          = RowMax
</span><span class="marked0"><a name="line53"></a>  53       @xls_colmax          = ColMax
</span><span class="marked1"><a name="line54"></a>  54       @xls_strmax          = StrMax
</span><span class="marked0"><a name="line55"></a>  55       @dim_rowmin          = nil
</span><span class="marked1"><a name="line56"></a>  56       @dim_rowmax          = nil
</span><span class="marked0"><a name="line57"></a>  57       @dim_colmin          = nil
</span><span class="marked1"><a name="line58"></a>  58       @dim_colmax          = nil
</span><span class="marked0"><a name="line59"></a>  59       @colinfo             = []
</span><span class="marked1"><a name="line60"></a>  60       @selection           = [0, 0]
</span><span class="marked0"><a name="line61"></a>  61       @panes               = []
</span><span class="marked1"><a name="line62"></a>  62       @active_pane         = 3
</span><span class="marked0"><a name="line63"></a>  63       @frozen              = 0
</span><span class="marked1"><a name="line64"></a>  64       @frozen_no_split     = 1
</span><span class="marked0"><a name="line65"></a>  65       @selected            = 0
</span><span class="marked1"><a name="line66"></a>  66       @hidden              = 0
</span><span class="marked0"><a name="line67"></a>  67       @active              = 0
</span><span class="marked1"><a name="line68"></a>  68       @tab_color           = 0
</span><span class="inferred0"><a name="line69"></a>  69 
</span><span class="marked1"><a name="line70"></a>  70       @first_row           = 0
</span><span class="marked0"><a name="line71"></a>  71       @first_col           = 0
</span><span class="marked1"><a name="line72"></a>  72       @display_formulas    = 0
</span><span class="marked0"><a name="line73"></a>  73       @display_headers     = 1
</span><span class="marked1"><a name="line74"></a>  74       @display_zeros       = 1
</span><span class="marked0"><a name="line75"></a>  75       @display_arabic      = 0
</span><span class="inferred1"><a name="line76"></a>  76 
</span><span class="marked0"><a name="line77"></a>  77       @paper_size          = 0x0
</span><span class="marked1"><a name="line78"></a>  78       @orientation         = 0x1
</span><span class="marked0"><a name="line79"></a>  79       @header              = ''
</span><span class="marked1"><a name="line80"></a>  80       @footer              = ''
</span><span class="marked0"><a name="line81"></a>  81       @header_encoding     = 0
</span><span class="marked1"><a name="line82"></a>  82       @footer_encoding     = 0
</span><span class="marked0"><a name="line83"></a>  83       @hcenter             = 0
</span><span class="marked1"><a name="line84"></a>  84       @vcenter             = 0
</span><span class="marked0"><a name="line85"></a>  85       @margin_header       = 0.50
</span><span class="marked1"><a name="line86"></a>  86       @margin_footer       = 0.50
</span><span class="marked0"><a name="line87"></a>  87       @margin_left         = 0.75
</span><span class="marked1"><a name="line88"></a>  88       @margin_right        = 0.75
</span><span class="marked0"><a name="line89"></a>  89       @margin_top          = 1.00
</span><span class="marked1"><a name="line90"></a>  90       @margin_bottom       = 1.00
</span><span class="inferred0"><a name="line91"></a>  91 
</span><span class="marked1"><a name="line92"></a>  92       @title_rowmin        = nil
</span><span class="marked0"><a name="line93"></a>  93       @title_rowmax        = nil
</span><span class="marked1"><a name="line94"></a>  94       @title_colmin        = nil
</span><span class="marked0"><a name="line95"></a>  95       @title_colmax        = nil
</span><span class="marked1"><a name="line96"></a>  96       @print_rowmin        = nil
</span><span class="marked0"><a name="line97"></a>  97       @print_rowmax        = nil
</span><span class="marked1"><a name="line98"></a>  98       @print_colmin        = nil
</span><span class="marked0"><a name="line99"></a>  99       @print_colmax        = nil
</span><span class="inferred1"><a name="line100"></a> 100 
</span><span class="marked0"><a name="line101"></a> 101       @print_gridlines     = 1
</span><span class="marked1"><a name="line102"></a> 102       @screen_gridlines    = 1
</span><span class="marked0"><a name="line103"></a> 103       @print_headers       = 0
</span><span class="inferred1"><a name="line104"></a> 104 
</span><span class="marked0"><a name="line105"></a> 105       @page_order          = 0
</span><span class="marked1"><a name="line106"></a> 106       @black_white         = 0
</span><span class="marked0"><a name="line107"></a> 107       @draft_quality       = 0
</span><span class="marked1"><a name="line108"></a> 108       @print_comments      = 0
</span><span class="marked0"><a name="line109"></a> 109       @page_start          = 1
</span><span class="marked1"><a name="line110"></a> 110       @custom_start        = 0
</span><span class="inferred0"><a name="line111"></a> 111 
</span><span class="marked1"><a name="line112"></a> 112       @fit_page            = 0
</span><span class="marked0"><a name="line113"></a> 113       @fit_width           = 0
</span><span class="marked1"><a name="line114"></a> 114       @fit_height          = 0
</span><span class="inferred0"><a name="line115"></a> 115 
</span><span class="marked1"><a name="line116"></a> 116       @hbreaks             = []
</span><span class="marked0"><a name="line117"></a> 117       @vbreaks             = []
</span><span class="inferred1"><a name="line118"></a> 118 
</span><span class="marked0"><a name="line119"></a> 119       @protect             = 0
</span><span class="marked1"><a name="line120"></a> 120       @password            = nil
</span><span class="inferred0"><a name="line121"></a> 121 
</span><span class="marked1"><a name="line122"></a> 122       @col_sizes           = {}
</span><span class="marked0"><a name="line123"></a> 123       @row_sizes           = {}
</span><span class="inferred1"><a name="line124"></a> 124 
</span><span class="marked0"><a name="line125"></a> 125       @col_formats         = {}
</span><span class="marked1"><a name="line126"></a> 126       @row_formats         = {}
</span><span class="inferred0"><a name="line127"></a> 127 
</span><span class="marked1"><a name="line128"></a> 128       @zoom                = 100
</span><span class="marked0"><a name="line129"></a> 129       @print_scale         = 100
</span><span class="marked1"><a name="line130"></a> 130       @page_view           = 0
</span><span class="inferred0"><a name="line131"></a> 131 
</span><span class="marked1"><a name="line132"></a> 132       @leading_zeros       = 0
</span><span class="inferred0"><a name="line133"></a> 133 
</span><span class="marked1"><a name="line134"></a> 134       @outline_row_level   = 0
</span><span class="marked0"><a name="line135"></a> 135       @outline_style       = 0
</span><span class="marked1"><a name="line136"></a> 136       @outline_below       = 1
</span><span class="marked0"><a name="line137"></a> 137       @outline_right       = 1
</span><span class="marked1"><a name="line138"></a> 138       @outline_on          = 1
</span><span class="inferred0"><a name="line139"></a> 139 
</span><span class="marked1"><a name="line140"></a> 140       @write_match         = []
</span><span class="inferred0"><a name="line141"></a> 141 
</span><span class="marked1"><a name="line142"></a> 142       @object_ids          = []
</span><span class="marked0"><a name="line143"></a> 143       @images              = {}
</span><span class="marked1"><a name="line144"></a> 144       @charts              = {}
</span><span class="marked0"><a name="line145"></a> 145       @comments            = {}
</span><span class="marked1"><a name="line146"></a> 146       @comments_author     = ''
</span><span class="marked0"><a name="line147"></a> 147       @comments_author_enc = 0
</span><span class="marked1"><a name="line148"></a> 148       @comments_visible    = 0
</span><span class="inferred0"><a name="line149"></a> 149 
</span><span class="marked1"><a name="line150"></a> 150       @filter_area         = []
</span><span class="marked0"><a name="line151"></a> 151       @filter_count        = 0
</span><span class="marked1"><a name="line152"></a> 152       @filter_on           = 0
</span><span class="marked0"><a name="line153"></a> 153       @filter_cols         = []
</span><span class="inferred1"><a name="line154"></a> 154 
</span><span class="marked0"><a name="line155"></a> 155       @writing_url         = 0
</span><span class="inferred1"><a name="line156"></a> 156 
</span><span class="marked0"><a name="line157"></a> 157       @db_indices          = []
</span><span class="inferred1"><a name="line158"></a> 158 
</span><span class="marked0"><a name="line159"></a> 159       @validations         = []
</span><span class="marked1"><a name="line160"></a> 160       _initialize
</span><span class="inferred0"><a name="line161"></a> 161    end
</span><span class="inferred1"><a name="line162"></a> 162 
</span><span class="marked0"><a name="line163"></a> 163    def _initialize
</span><span class="marked1"><a name="line164"></a> 164       basename = 'spreadsheetwriteexcel'
</span><span class="inferred0"><a name="line165"></a> 165 
</span><span class="marked1"><a name="line166"></a> 166       begin
</span><span class="marked0"><a name="line167"></a> 167          if !@tempdir.nil?
</span><span class="uncovered1"><a name="line168"></a> 168             if @tempdir == ''
</span><span class="uncovered0"><a name="line169"></a> 169                fh = Tempfile.new(basename)
</span><span class="uncovered1"><a name="line170"></a> 170             else
</span><span class="uncovered0"><a name="line171"></a> 171                fh = Tempfile.new(basename, @tempdir)
</span><span class="uncovered1"><a name="line172"></a> 172             end
</span><span class="uncovered0"><a name="line173"></a> 173          end
</span><span class="uncovered1"><a name="line174"></a> 174       # failed. store temporary data in memory.
</span><span class="uncovered0"><a name="line175"></a> 175       rescue
</span><span class="uncovered1"><a name="line176"></a> 176          @using_tmpfile = 0
</span><span class="inferred0"><a name="line177"></a> 177       # if the temp file creation was successful
</span><span class="inferred1"><a name="line178"></a> 178       else
</span><span class="marked0"><a name="line179"></a> 179          @filehandle = fh
</span><span class="inferred1"><a name="line180"></a> 180       end
</span><span class="inferred0"><a name="line181"></a> 181    end
</span><span class="inferred1"><a name="line182"></a> 182    
</span><span class="inferred0"><a name="line183"></a> 183    ###############################################################################
</span><span class="inferred1"><a name="line184"></a> 184    #
</span><span class="inferred0"><a name="line185"></a> 185    # _close()
</span><span class="inferred1"><a name="line186"></a> 186    #
</span><span class="inferred0"><a name="line187"></a> 187    # Add data to the beginning of the workbook (note the reverse order)
</span><span class="inferred1"><a name="line188"></a> 188    # and to the end of the workbook.
</span><span class="inferred0"><a name="line189"></a> 189    #
</span><span class="marked1"><a name="line190"></a> 190    def close(sheetnames)
</span><span class="uncovered0"><a name="line191"></a> 191        num_sheets = sheetnames.size
</span><span class="uncovered1"><a name="line192"></a> 192    
</span><span class="uncovered0"><a name="line193"></a> 193        ################################################
</span><span class="uncovered1"><a name="line194"></a> 194        # Prepend in reverse order!!
</span><span class="uncovered0"><a name="line195"></a> 195        #
</span><span class="uncovered1"><a name="line196"></a> 196    
</span><span class="uncovered0"><a name="line197"></a> 197        # Prepend the sheet dimensions
</span><span class="uncovered1"><a name="line198"></a> 198        store_dimensions
</span><span class="uncovered0"><a name="line199"></a> 199    
</span><span class="uncovered1"><a name="line200"></a> 200        # Prepend the autofilter filters.
</span><span class="uncovered0"><a name="line201"></a> 201        store_autofilters
</span><span class="uncovered1"><a name="line202"></a> 202    
</span><span class="uncovered0"><a name="line203"></a> 203        # Prepend the sheet autofilter info.
</span><span class="uncovered1"><a name="line204"></a> 204        store_autofilterinfo
</span><span class="uncovered0"><a name="line205"></a> 205    
</span><span class="uncovered1"><a name="line206"></a> 206        # Prepend the sheet filtermode record.
</span><span class="uncovered0"><a name="line207"></a> 207        store_filtermode
</span><span class="uncovered1"><a name="line208"></a> 208    
</span><span class="uncovered0"><a name="line209"></a> 209        # Prepend the COLINFO records if they exist
</span><span class="uncovered1"><a name="line210"></a> 210        if @colinfo
</span><span class="uncovered0"><a name="line211"></a> 211            while (@colinfo)
</span><span class="uncovered1"><a name="line212"></a> 212                arrayref = @colinfo.pop
</span><span class="uncovered0"><a name="line213"></a> 213                store_colinfo(arrayref)
</span><span class="uncovered1"><a name="line214"></a> 214            end
</span><span class="uncovered0"><a name="line215"></a> 215        end
</span><span class="uncovered1"><a name="line216"></a> 216    
</span><span class="uncovered0"><a name="line217"></a> 217        # Prepend the DEFCOLWIDTH record
</span><span class="uncovered1"><a name="line218"></a> 218        store_defcol
</span><span class="uncovered0"><a name="line219"></a> 219    
</span><span class="uncovered1"><a name="line220"></a> 220        # Prepend the sheet password
</span><span class="uncovered0"><a name="line221"></a> 221        store_password
</span><span class="uncovered1"><a name="line222"></a> 222    
</span><span class="uncovered0"><a name="line223"></a> 223        # Prepend the sheet protection
</span><span class="uncovered1"><a name="line224"></a> 224        store_protect
</span><span class="uncovered0"><a name="line225"></a> 225        store_obj_protect
</span><span class="uncovered1"><a name="line226"></a> 226    
</span><span class="uncovered0"><a name="line227"></a> 227        # Prepend the page setup
</span><span class="uncovered1"><a name="line228"></a> 228        store_setup
</span><span class="uncovered0"><a name="line229"></a> 229    
</span><span class="uncovered1"><a name="line230"></a> 230        # Prepend the bottom margin
</span><span class="uncovered0"><a name="line231"></a> 231        store_margin_bottom
</span><span class="uncovered1"><a name="line232"></a> 232    
</span><span class="uncovered0"><a name="line233"></a> 233        # Prepend the top margin
</span><span class="uncovered1"><a name="line234"></a> 234        store_margin_top
</span><span class="uncovered0"><a name="line235"></a> 235    
</span><span class="uncovered1"><a name="line236"></a> 236        # Prepend the right margin
</span><span class="uncovered0"><a name="line237"></a> 237        store_margin_right
</span><span class="uncovered1"><a name="line238"></a> 238    
</span><span class="uncovered0"><a name="line239"></a> 239        # Prepend the left margin
</span><span class="uncovered1"><a name="line240"></a> 240        store_margin_left
</span><span class="uncovered0"><a name="line241"></a> 241    
</span><span class="uncovered1"><a name="line242"></a> 242        # Prepend the page vertical centering
</span><span class="uncovered0"><a name="line243"></a> 243        store_vcenter
</span><span class="uncovered1"><a name="line244"></a> 244    
</span><span class="uncovered0"><a name="line245"></a> 245        # Prepend the page horizontal centering
</span><span class="uncovered1"><a name="line246"></a> 246        store_hcenter
</span><span class="uncovered0"><a name="line247"></a> 247    
</span><span class="uncovered1"><a name="line248"></a> 248        # Prepend the page footer
</span><span class="uncovered0"><a name="line249"></a> 249        store_footer
</span><span class="uncovered1"><a name="line250"></a> 250    
</span><span class="uncovered0"><a name="line251"></a> 251        # Prepend the page header
</span><span class="uncovered1"><a name="line252"></a> 252        store_header
</span><span class="uncovered0"><a name="line253"></a> 253    
</span><span class="uncovered1"><a name="line254"></a> 254        # Prepend the vertical page breaks
</span><span class="uncovered0"><a name="line255"></a> 255        store_vbreak
</span><span class="uncovered1"><a name="line256"></a> 256    
</span><span class="uncovered0"><a name="line257"></a> 257        # Prepend the horizontal page breaks
</span><span class="uncovered1"><a name="line258"></a> 258        store_hbreak
</span><span class="uncovered0"><a name="line259"></a> 259    
</span><span class="uncovered1"><a name="line260"></a> 260        # Prepend WSBOOL
</span><span class="uncovered0"><a name="line261"></a> 261        store_wsbool
</span><span class="uncovered1"><a name="line262"></a> 262    
</span><span class="uncovered0"><a name="line263"></a> 263        # Prepend the default row height.
</span><span class="uncovered1"><a name="line264"></a> 264        store_defrow
</span><span class="uncovered0"><a name="line265"></a> 265    
</span><span class="uncovered1"><a name="line266"></a> 266        # Prepend GUTS
</span><span class="uncovered0"><a name="line267"></a> 267        store_guts
</span><span class="uncovered1"><a name="line268"></a> 268    
</span><span class="uncovered0"><a name="line269"></a> 269        # Prepend GRIDSET
</span><span class="uncovered1"><a name="line270"></a> 270        store_gridset
</span><span class="uncovered0"><a name="line271"></a> 271    
</span><span class="uncovered1"><a name="line272"></a> 272        # Prepend PRINTGRIDLINES
</span><span class="uncovered0"><a name="line273"></a> 273        store_print_gridlines
</span><span class="uncovered1"><a name="line274"></a> 274    
</span><span class="uncovered0"><a name="line275"></a> 275        # Prepend PRINTHEADERS
</span><span class="uncovered1"><a name="line276"></a> 276        store_print_headers
</span><span class="uncovered0"><a name="line277"></a> 277    
</span><span class="uncovered1"><a name="line278"></a> 278        #
</span><span class="uncovered0"><a name="line279"></a> 279        # End of prepend. Read upwards from here.
</span><span class="uncovered1"><a name="line280"></a> 280        ################################################
</span><span class="uncovered0"><a name="line281"></a> 281    
</span><span class="uncovered1"><a name="line282"></a> 282        # Append
</span><span class="uncovered0"><a name="line283"></a> 283        store_table
</span><span class="uncovered1"><a name="line284"></a> 284        store_images
</span><span class="uncovered0"><a name="line285"></a> 285        store_charts
</span><span class="uncovered1"><a name="line286"></a> 286        store_filters
</span><span class="uncovered0"><a name="line287"></a> 287        store_comments
</span><span class="uncovered1"><a name="line288"></a> 288        store_window2
</span><span class="uncovered0"><a name="line289"></a> 289        store_page_view
</span><span class="uncovered1"><a name="line290"></a> 290        store_zoom
</span><span class="uncovered0"><a name="line291"></a> 291        store_panes(@panes) if !@panes.nil? &amp;&amp; @panes != 0
</span><span class="uncovered1"><a name="line292"></a> 292        store_selection(@selection)
</span><span class="uncovered0"><a name="line293"></a> 293        store_validation_count
</span><span class="uncovered1"><a name="line294"></a> 294        store_validations
</span><span class="uncovered0"><a name="line295"></a> 295        store_tab_color
</span><span class="uncovered1"><a name="line296"></a> 296        store_eof
</span><span class="uncovered0"><a name="line297"></a> 297    
</span><span class="uncovered1"><a name="line298"></a> 298        # Prepend the BOF and INDEX records
</span><span class="uncovered0"><a name="line299"></a> 299        store_index
</span><span class="uncovered1"><a name="line300"></a> 300        store_bof(0x0010)
</span><span class="uncovered0"><a name="line301"></a> 301    end
</span><span class="inferred1"><a name="line302"></a> 302 
</span><span class="inferred0"><a name="line303"></a> 303    ###############################################################################
</span><span class="inferred1"><a name="line304"></a> 304    #
</span><span class="inferred0"><a name="line305"></a> 305    # _compatibility_mode()
</span><span class="inferred1"><a name="line306"></a> 306    #
</span><span class="inferred0"><a name="line307"></a> 307    # Set the compatibility mode.
</span><span class="inferred1"><a name="line308"></a> 308    #
</span><span class="inferred0"><a name="line309"></a> 309    # See the explanation in Workbook::compatibility_mode(). This private method
</span><span class="inferred1"><a name="line310"></a> 310    # is mainly used for test purposes.
</span><span class="inferred0"><a name="line311"></a> 311    #
</span><span class="marked1"><a name="line312"></a> 312    def compatibility_mode(compatibility = 1)
</span><span class="uncovered0"><a name="line313"></a> 313       @compatibility = compatibility
</span><span class="uncovered1"><a name="line314"></a> 314    end
</span><span class="inferred0"><a name="line315"></a> 315 
</span><span class="inferred1"><a name="line316"></a> 316    ###############################################################################
</span><span class="inferred0"><a name="line317"></a> 317    #
</span><span class="inferred1"><a name="line318"></a> 318    # get_data().
</span><span class="inferred0"><a name="line319"></a> 319    #
</span><span class="inferred1"><a name="line320"></a> 320    # Retrieves data from memory in one chunk, or from disk in $buffer
</span><span class="inferred0"><a name="line321"></a> 321    # sized chunks.
</span><span class="inferred1"><a name="line322"></a> 322    #
</span><span class="marked0"><a name="line323"></a> 323    def get_data
</span><span class="uncovered1"><a name="line324"></a> 324       buffer = 4096
</span><span class="uncovered0"><a name="line325"></a> 325 
</span><span class="uncovered1"><a name="line326"></a> 326       # Return data stored in memory
</span><span class="uncovered0"><a name="line327"></a> 327       unless @data.nil?
</span><span class="uncovered1"><a name="line328"></a> 328          tmp   = @data
</span><span class="uncovered0"><a name="line329"></a> 329          @data = nil
</span><span class="uncovered1"><a name="line330"></a> 330          fh         = @filehandle
</span><span class="uncovered0"><a name="line331"></a> 331          seek(fh, 0, 0) if @using_tmpfile != 0
</span><span class="uncovered1"><a name="line332"></a> 332          return @data
</span><span class="uncovered0"><a name="line333"></a> 333       end
</span><span class="uncovered1"><a name="line334"></a> 334 
</span><span class="uncovered0"><a name="line335"></a> 335       # Return data stored on disk
</span><span class="uncovered1"><a name="line336"></a> 336       if @using_tmpfile != 0
</span><span class="uncovered0"><a name="line337"></a> 337          return tmp if read(@filehandle, tmp, buffer)
</span><span class="uncovered1"><a name="line338"></a> 338       end
</span><span class="uncovered0"><a name="line339"></a> 339 
</span><span class="uncovered1"><a name="line340"></a> 340       # No data to return
</span><span class="uncovered0"><a name="line341"></a> 341       return nil
</span><span class="uncovered1"><a name="line342"></a> 342    end
</span><span class="inferred0"><a name="line343"></a> 343 
</span><span class="inferred1"><a name="line344"></a> 344 
</span><span class="inferred0"><a name="line345"></a> 345    ###############################################################################
</span><span class="inferred1"><a name="line346"></a> 346    #
</span><span class="inferred0"><a name="line347"></a> 347    # select()
</span><span class="inferred1"><a name="line348"></a> 348    #
</span><span class="inferred0"><a name="line349"></a> 349    # Set this worksheet as a selected worksheet, i.e. the worksheet has its tab
</span><span class="inferred1"><a name="line350"></a> 350    # highlighted.
</span><span class="inferred0"><a name="line351"></a> 351    #
</span><span class="marked1"><a name="line352"></a> 352    def select
</span><span class="uncovered0"><a name="line353"></a> 353       @hidden         = 0  # Selected worksheet can't be hidden.
</span><span class="uncovered1"><a name="line354"></a> 354       @selected       = 1
</span><span class="uncovered0"><a name="line355"></a> 355    end
</span><span class="inferred1"><a name="line356"></a> 356 
</span><span class="inferred0"><a name="line357"></a> 357 
</span><span class="inferred1"><a name="line358"></a> 358    ###############################################################################
</span><span class="inferred0"><a name="line359"></a> 359    #
</span><span class="inferred1"><a name="line360"></a> 360    # activate()
</span><span class="inferred0"><a name="line361"></a> 361    #
</span><span class="inferred1"><a name="line362"></a> 362    # Set this worksheet as the active worksheet, i.e. the worksheet that is
</span><span class="inferred0"><a name="line363"></a> 363    # displayed when the workbook is opened. Also set it as selected.
</span><span class="inferred1"><a name="line364"></a> 364    #
</span><span class="marked0"><a name="line365"></a> 365    def activate
</span><span class="uncovered1"><a name="line366"></a> 366       @hidden      = 0  # Active worksheet can't be hidden.
</span><span class="uncovered0"><a name="line367"></a> 367       @selected    = 1
</span><span class="uncovered1"><a name="line368"></a> 368       @activesheet = @index
</span><span class="uncovered0"><a name="line369"></a> 369    end
</span><span class="inferred1"><a name="line370"></a> 370 
</span><span class="inferred0"><a name="line371"></a> 371 
</span><span class="inferred1"><a name="line372"></a> 372    ###############################################################################
</span><span class="inferred0"><a name="line373"></a> 373    #
</span><span class="inferred1"><a name="line374"></a> 374    # hide()
</span><span class="inferred0"><a name="line375"></a> 375    #
</span><span class="inferred1"><a name="line376"></a> 376    # Hide this worksheet.
</span><span class="inferred0"><a name="line377"></a> 377    #
</span><span class="marked1"><a name="line378"></a> 378    def hide
</span><span class="uncovered0"><a name="line379"></a> 379       @hidden         = 1
</span><span class="uncovered1"><a name="line380"></a> 380 
</span><span class="uncovered0"><a name="line381"></a> 381       # A hidden worksheet shouldn't be active or selected.
</span><span class="uncovered1"><a name="line382"></a> 382       @selected       = 0
</span><span class="uncovered0"><a name="line383"></a> 383       @activesheet = 0
</span><span class="uncovered1"><a name="line384"></a> 384       @firstsheet  = 0
</span><span class="uncovered0"><a name="line385"></a> 385    end
</span><span class="inferred1"><a name="line386"></a> 386 
</span><span class="inferred0"><a name="line387"></a> 387 
</span><span class="inferred1"><a name="line388"></a> 388    ###############################################################################
</span><span class="inferred0"><a name="line389"></a> 389    #
</span><span class="inferred1"><a name="line390"></a> 390    # set_first_sheet()
</span><span class="inferred0"><a name="line391"></a> 391    #
</span><span class="inferred1"><a name="line392"></a> 392    # Set this worksheet as the first visible sheet. This is necessary
</span><span class="inferred0"><a name="line393"></a> 393    # when there are a large number of worksheets and the activated
</span><span class="inferred1"><a name="line394"></a> 394    # worksheet is not visible on the screen.
</span><span class="inferred0"><a name="line395"></a> 395    #
</span><span class="marked1"><a name="line396"></a> 396    def set_first_sheet
</span><span class="uncovered0"><a name="line397"></a> 397       @hidden      = 0  # Active worksheet can't be hidden.
</span><span class="uncovered1"><a name="line398"></a> 398       @firstsheet  = @index
</span><span class="uncovered0"><a name="line399"></a> 399    end
</span><span class="inferred1"><a name="line400"></a> 400 
</span><span class="inferred0"><a name="line401"></a> 401 
</span><span class="inferred1"><a name="line402"></a> 402    ###############################################################################
</span><span class="inferred0"><a name="line403"></a> 403    #
</span><span class="inferred1"><a name="line404"></a> 404    # protect($password)
</span><span class="inferred0"><a name="line405"></a> 405    #
</span><span class="inferred1"><a name="line406"></a> 406    # Set the worksheet protection flag to prevent accidental modification and to
</span><span class="inferred0"><a name="line407"></a> 407    # hide formulas if the locked and hidden format properties have been set.
</span><span class="inferred1"><a name="line408"></a> 408    #
</span><span class="marked0"><a name="line409"></a> 409    def protect(password = nil)
</span><span class="uncovered1"><a name="line410"></a> 410       @protect   = 1
</span><span class="uncovered0"><a name="line411"></a> 411       @password  = encode_password(password) unless password.nil?
</span><span class="uncovered1"><a name="line412"></a> 412    end
</span><span class="inferred0"><a name="line413"></a> 413 
</span><span class="inferred1"><a name="line414"></a> 414    ###############################################################################
</span><span class="inferred0"><a name="line415"></a> 415    #
</span><span class="inferred1"><a name="line416"></a> 416    # set_column($firstcol, $lastcol, $width, $format, $hidden, $level)
</span><span class="inferred0"><a name="line417"></a> 417    #
</span><span class="inferred1"><a name="line418"></a> 418    # Set the width of a single column or a range of columns.
</span><span class="inferred0"><a name="line419"></a> 419    # See also: _store_colinfo
</span><span class="inferred1"><a name="line420"></a> 420    #
</span><span class="marked0"><a name="line421"></a> 421    def set_column(*args)
</span><span class="marked1"><a name="line422"></a> 422       data = args
</span><span class="marked0"><a name="line423"></a> 423       cell = data[0]
</span><span class="inferred1"><a name="line424"></a> 424 
</span><span class="inferred0"><a name="line425"></a> 425       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line426"></a> 426       if cell =~ /^\D/
</span><span class="marked0"><a name="line427"></a> 427          data = substitute_cellref(*args)
</span><span class="inferred1"><a name="line428"></a> 428 
</span><span class="inferred0"><a name="line429"></a> 429          # Returned values $row1 and $row2 aren't required here. Remove them.
</span><span class="marked1"><a name="line430"></a> 430          data.shift        # $row1
</span><span class="marked0"><a name="line431"></a> 431          data.delete_at(1) # $row2
</span><span class="inferred1"><a name="line432"></a> 432       end
</span><span class="inferred0"><a name="line433"></a> 433 
</span><span class="marked1"><a name="line434"></a> 434       return if data.size &lt; 3  # Ensure at least $firstcol, $lastcol and $width
</span><span class="marked0"><a name="line435"></a> 435       return if data[0].nil?   # Columns must be defined.
</span><span class="marked1"><a name="line436"></a> 436       return if data[1].nil?
</span><span class="inferred0"><a name="line437"></a> 437 
</span><span class="inferred1"><a name="line438"></a> 438       # Assume second column is the same as first if 0. Avoids KB918419 bug.
</span><span class="marked0"><a name="line439"></a> 439       data[1] = data[0] if data[1] == 0
</span><span class="inferred1"><a name="line440"></a> 440 
</span><span class="inferred0"><a name="line441"></a> 441       # Ensure 2nd col is larger than first. Also for KB918419 bug.
</span><span class="marked1"><a name="line442"></a> 442       data[0], data[1] = data[1], data[0] if data[0] &gt; data[1]
</span><span class="inferred0"><a name="line443"></a> 443 
</span><span class="inferred1"><a name="line444"></a> 444       # Limit columns to Excel max of 255.
</span><span class="marked0"><a name="line445"></a> 445       data[0] = ColMax - 1 if data[0] &gt; ColMax - 1
</span><span class="marked1"><a name="line446"></a> 446       data[1] = ColMax - 1 if data[1] &gt; ColMax - 1
</span><span class="inferred0"><a name="line447"></a> 447 
</span><span class="marked1"><a name="line448"></a> 448       @colinfo.push(data)
</span><span class="inferred0"><a name="line449"></a> 449 
</span><span class="inferred1"><a name="line450"></a> 450       # Store the col sizes for use when calculating image vertices taking
</span><span class="inferred0"><a name="line451"></a> 451       # hidden columns into account. Also store the column formats.
</span><span class="inferred1"><a name="line452"></a> 452       #
</span><span class="marked0"><a name="line453"></a> 453       width  = data[4].nil? || data[4] == 0 ? 0 : data[2]  # Set width to zero if col is hidden
</span><span class="marked1"><a name="line454"></a> 454       width  ||= 0                    # Ensure width isn't undef.
</span><span class="marked0"><a name="line455"></a> 455       format = data[3]
</span><span class="marked1"><a name="line456"></a> 456       firstcol, lastcol = data
</span><span class="inferred0"><a name="line457"></a> 457 
</span><span class="marked1"><a name="line458"></a> 458       (firstcol .. lastcol).each do |col|
</span><span class="marked0"><a name="line459"></a> 459          @col_sizes[col]   = width
</span><span class="marked1"><a name="line460"></a> 460          @col_formats[col] = format unless format.nil?
</span><span class="inferred0"><a name="line461"></a> 461       end
</span><span class="inferred1"><a name="line462"></a> 462    end
</span><span class="inferred0"><a name="line463"></a> 463 
</span><span class="inferred1"><a name="line464"></a> 464    ###############################################################################
</span><span class="inferred0"><a name="line465"></a> 465    #
</span><span class="inferred1"><a name="line466"></a> 466    # set_selection()
</span><span class="inferred0"><a name="line467"></a> 467    #
</span><span class="inferred1"><a name="line468"></a> 468    # Set which cell or cells are selected in a worksheet: see also the
</span><span class="inferred0"><a name="line469"></a> 469    # sub _store_selection
</span><span class="inferred1"><a name="line470"></a> 470    #
</span><span class="marked0"><a name="line471"></a> 471    def set_selection(*args)
</span><span class="uncovered1"><a name="line472"></a> 472       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered0"><a name="line473"></a> 473       if args[0] =~ /^\D/
</span><span class="uncovered1"><a name="line474"></a> 474          args = substitute_cellref(*args)
</span><span class="uncovered0"><a name="line475"></a> 475       end
</span><span class="uncovered1"><a name="line476"></a> 476       @selection = args
</span><span class="uncovered0"><a name="line477"></a> 477    end
</span><span class="inferred1"><a name="line478"></a> 478 
</span><span class="inferred0"><a name="line479"></a> 479 
</span><span class="inferred1"><a name="line480"></a> 480    ###############################################################################
</span><span class="inferred0"><a name="line481"></a> 481    #
</span><span class="inferred1"><a name="line482"></a> 482    # freeze_panes()
</span><span class="inferred0"><a name="line483"></a> 483    #
</span><span class="inferred1"><a name="line484"></a> 484    # Set panes and mark them as frozen. See also _store_panes().
</span><span class="inferred0"><a name="line485"></a> 485    #
</span><span class="marked1"><a name="line486"></a> 486    def freeze_panes(*args)
</span><span class="uncovered0"><a name="line487"></a> 487       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered1"><a name="line488"></a> 488       if args[0] =~ /^\D/
</span><span class="uncovered0"><a name="line489"></a> 489          args = substitute_cellref(*args)
</span><span class="uncovered1"><a name="line490"></a> 490       end
</span><span class="uncovered0"><a name="line491"></a> 491       # Extra flag indicated a split and freeze.
</span><span class="uncovered1"><a name="line492"></a> 492       @frozen_no_split = 0 if args[4]
</span><span class="uncovered0"><a name="line493"></a> 493 
</span><span class="uncovered1"><a name="line494"></a> 494       @frozen = 1
</span><span class="uncovered0"><a name="line495"></a> 495       @panes  = args
</span><span class="uncovered1"><a name="line496"></a> 496    end
</span><span class="inferred0"><a name="line497"></a> 497 
</span><span class="inferred1"><a name="line498"></a> 498 
</span><span class="inferred0"><a name="line499"></a> 499    ###############################################################################
</span><span class="inferred1"><a name="line500"></a> 500    #
</span><span class="inferred0"><a name="line501"></a> 501    # split_panes()
</span><span class="inferred1"><a name="line502"></a> 502    #
</span><span class="inferred0"><a name="line503"></a> 503    # Set panes and mark them as split. See also _store_panes().
</span><span class="inferred1"><a name="line504"></a> 504    #
</span><span class="marked0"><a name="line505"></a> 505    def split_panes(*args)
</span><span class="uncovered1"><a name="line506"></a> 506       @frozen            = 0
</span><span class="uncovered0"><a name="line507"></a> 507       @frozen_no_split   = 0
</span><span class="uncovered1"><a name="line508"></a> 508       @panes             = args
</span><span class="uncovered0"><a name="line509"></a> 509    end
</span><span class="inferred1"><a name="line510"></a> 510 
</span><span class="inferred0"><a name="line511"></a> 511    # Older method name for backwards compatibility.
</span><span class="inferred1"><a name="line512"></a> 512    # *thaw_panes = *split_panes;
</span><span class="inferred0"><a name="line513"></a> 513 
</span><span class="inferred1"><a name="line514"></a> 514    ###############################################################################
</span><span class="inferred0"><a name="line515"></a> 515    #
</span><span class="inferred1"><a name="line516"></a> 516    # set_portrait()
</span><span class="inferred0"><a name="line517"></a> 517    #
</span><span class="inferred1"><a name="line518"></a> 518    # Set the page orientation as portrait.
</span><span class="inferred0"><a name="line519"></a> 519    #
</span><span class="marked1"><a name="line520"></a> 520    def set_portrait
</span><span class="uncovered0"><a name="line521"></a> 521       @orientation = 1
</span><span class="uncovered1"><a name="line522"></a> 522    end
</span><span class="inferred0"><a name="line523"></a> 523 
</span><span class="inferred1"><a name="line524"></a> 524 
</span><span class="inferred0"><a name="line525"></a> 525    ###############################################################################
</span><span class="inferred1"><a name="line526"></a> 526    #
</span><span class="inferred0"><a name="line527"></a> 527    # set_landscape()
</span><span class="inferred1"><a name="line528"></a> 528    #
</span><span class="inferred0"><a name="line529"></a> 529    # Set the page orientation as landscape.
</span><span class="inferred1"><a name="line530"></a> 530    #
</span><span class="marked0"><a name="line531"></a> 531    def set_landscape
</span><span class="uncovered1"><a name="line532"></a> 532       @orientation = 0
</span><span class="uncovered0"><a name="line533"></a> 533    end
</span><span class="inferred1"><a name="line534"></a> 534 
</span><span class="inferred0"><a name="line535"></a> 535 
</span><span class="inferred1"><a name="line536"></a> 536    ###############################################################################
</span><span class="inferred0"><a name="line537"></a> 537    #
</span><span class="inferred1"><a name="line538"></a> 538    # set_page_view()
</span><span class="inferred0"><a name="line539"></a> 539    #
</span><span class="inferred1"><a name="line540"></a> 540    # Set the page view mode for Mac Excel.
</span><span class="inferred0"><a name="line541"></a> 541    #
</span><span class="marked1"><a name="line542"></a> 542    def set_page_view(val = nil)
</span><span class="uncovered0"><a name="line543"></a> 543       @page_view = val.nil? ? 1 : val
</span><span class="uncovered1"><a name="line544"></a> 544    end
</span><span class="inferred0"><a name="line545"></a> 545 
</span><span class="inferred1"><a name="line546"></a> 546 
</span><span class="inferred0"><a name="line547"></a> 547    ###############################################################################
</span><span class="inferred1"><a name="line548"></a> 548    #
</span><span class="inferred0"><a name="line549"></a> 549    # set_tab_color()
</span><span class="inferred1"><a name="line550"></a> 550    #
</span><span class="inferred0"><a name="line551"></a> 551    # Set the colour of the worksheet colour.
</span><span class="inferred1"><a name="line552"></a> 552    #
</span><span class="marked0"><a name="line553"></a> 553    def set_tab_color(colour)
</span><span class="uncovered1"><a name="line554"></a> 554       color = Format._get_color(colour)
</span><span class="uncovered0"><a name="line555"></a> 555       color = 0 if color == 0x7FFF # Default color.
</span><span class="uncovered1"><a name="line556"></a> 556       @tab_color = color
</span><span class="uncovered0"><a name="line557"></a> 557    end
</span><span class="inferred1"><a name="line558"></a> 558 
</span><span class="inferred0"><a name="line559"></a> 559    ###############################################################################
</span><span class="inferred1"><a name="line560"></a> 560    #
</span><span class="inferred0"><a name="line561"></a> 561    # set_paper()
</span><span class="inferred1"><a name="line562"></a> 562    #
</span><span class="inferred0"><a name="line563"></a> 563    # Set the paper type. Ex. 1 = US Letter, 9 = A4
</span><span class="inferred1"><a name="line564"></a> 564    #
</span><span class="marked0"><a name="line565"></a> 565    def set_paper(paper_size = 0)
</span><span class="uncovered1"><a name="line566"></a> 566       @paper_size = paper_size
</span><span class="uncovered0"><a name="line567"></a> 567    end
</span><span class="inferred1"><a name="line568"></a> 568 
</span><span class="inferred0"><a name="line569"></a> 569    ###############################################################################
</span><span class="inferred1"><a name="line570"></a> 570    #
</span><span class="inferred0"><a name="line571"></a> 571    # set_header()
</span><span class="inferred1"><a name="line572"></a> 572    #
</span><span class="inferred0"><a name="line573"></a> 573    # Set the page header caption and optional margin.
</span><span class="inferred1"><a name="line574"></a> 574    #
</span><span class="marked0"><a name="line575"></a> 575    def set_header(string = '', margin = 0.50, encoding = 0)
</span><span class="uncovered1"><a name="line576"></a> 576       limit    = encoding != 0 ? 255 *2 : 255
</span><span class="uncovered0"><a name="line577"></a> 577 
</span><span class="uncovered1"><a name="line578"></a> 578       if string.length &gt;= limit
</span><span class="uncovered0"><a name="line579"></a> 579          #           carp 'Header string must be less than 255 characters';
</span><span class="uncovered1"><a name="line580"></a> 580          return
</span><span class="uncovered0"><a name="line581"></a> 581       end
</span><span class="uncovered1"><a name="line582"></a> 582 
</span><span class="uncovered0"><a name="line583"></a> 583       @header          = string
</span><span class="uncovered1"><a name="line584"></a> 584       @margin_header   = margin
</span><span class="uncovered0"><a name="line585"></a> 585       @header_encoding = encoding
</span><span class="uncovered1"><a name="line586"></a> 586    end
</span><span class="inferred0"><a name="line587"></a> 587 
</span><span class="inferred1"><a name="line588"></a> 588 
</span><span class="inferred0"><a name="line589"></a> 589    ###############################################################################
</span><span class="inferred1"><a name="line590"></a> 590    #
</span><span class="inferred0"><a name="line591"></a> 591    # set_footer()
</span><span class="inferred1"><a name="line592"></a> 592    #
</span><span class="inferred0"><a name="line593"></a> 593    # Set the page footer caption and optional margin.
</span><span class="inferred1"><a name="line594"></a> 594    #
</span><span class="marked0"><a name="line595"></a> 595    def set_footer(string = '', margin = 0.50, encoding = 0)
</span><span class="uncovered1"><a name="line596"></a> 596       limit    = encoding != 0 ? 255 *2 : 255
</span><span class="uncovered0"><a name="line597"></a> 597 
</span><span class="uncovered1"><a name="line598"></a> 598       if string.length &gt;= limit
</span><span class="uncovered0"><a name="line599"></a> 599          #           carp 'Header string must be less than 255 characters';
</span><span class="uncovered1"><a name="line600"></a> 600          return
</span><span class="uncovered0"><a name="line601"></a> 601       end
</span><span class="uncovered1"><a name="line602"></a> 602 
</span><span class="uncovered0"><a name="line603"></a> 603       @footer          = string
</span><span class="uncovered1"><a name="line604"></a> 604       @margin_footer   = margin
</span><span class="uncovered0"><a name="line605"></a> 605       @footer_encoding = encoding
</span><span class="uncovered1"><a name="line606"></a> 606    end
</span><span class="inferred0"><a name="line607"></a> 607 
</span><span class="inferred1"><a name="line608"></a> 608    ###############################################################################
</span><span class="inferred0"><a name="line609"></a> 609    #
</span><span class="inferred1"><a name="line610"></a> 610    # center_horizontally()
</span><span class="inferred0"><a name="line611"></a> 611    #
</span><span class="inferred1"><a name="line612"></a> 612    # Center the page horizontally.
</span><span class="inferred0"><a name="line613"></a> 613    #
</span><span class="marked1"><a name="line614"></a> 614    def center_horizontally(hcenter = nil)
</span><span class="uncovered0"><a name="line615"></a> 615       if hcenter.nil?
</span><span class="uncovered1"><a name="line616"></a> 616          @hcenter = 1
</span><span class="uncovered0"><a name="line617"></a> 617       else
</span><span class="uncovered1"><a name="line618"></a> 618          @hcenter = hcenter
</span><span class="uncovered0"><a name="line619"></a> 619       end
</span><span class="uncovered1"><a name="line620"></a> 620    end
</span><span class="inferred0"><a name="line621"></a> 621 
</span><span class="inferred1"><a name="line622"></a> 622    ###############################################################################
</span><span class="inferred0"><a name="line623"></a> 623    #
</span><span class="inferred1"><a name="line624"></a> 624    # center_vertically()
</span><span class="inferred0"><a name="line625"></a> 625    #
</span><span class="inferred1"><a name="line626"></a> 626    # Center the page horinzontally.
</span><span class="inferred0"><a name="line627"></a> 627    #
</span><span class="marked1"><a name="line628"></a> 628    def center_vertically(vcenter = nil)
</span><span class="uncovered0"><a name="line629"></a> 629       if vcenter.nil?
</span><span class="uncovered1"><a name="line630"></a> 630          @vcenter = 1
</span><span class="uncovered0"><a name="line631"></a> 631       else
</span><span class="uncovered1"><a name="line632"></a> 632          @vcenter = vcenter
</span><span class="uncovered0"><a name="line633"></a> 633       end
</span><span class="uncovered1"><a name="line634"></a> 634    end
</span><span class="inferred0"><a name="line635"></a> 635 
</span><span class="inferred1"><a name="line636"></a> 636    ###############################################################################
</span><span class="inferred0"><a name="line637"></a> 637    #
</span><span class="inferred1"><a name="line638"></a> 638    # set_margins()
</span><span class="inferred0"><a name="line639"></a> 639    #
</span><span class="inferred1"><a name="line640"></a> 640    # Set all the page margins to the same value in inches.
</span><span class="inferred0"><a name="line641"></a> 641    #
</span><span class="marked1"><a name="line642"></a> 642    def set_margins(margin)
</span><span class="uncovered0"><a name="line643"></a> 643       set_margin_left(margin)
</span><span class="uncovered1"><a name="line644"></a> 644       set_margin_right(margin)
</span><span class="uncovered0"><a name="line645"></a> 645       set_margin_top(margin)
</span><span class="uncovered1"><a name="line646"></a> 646       set_margin_bottom(margin)
</span><span class="uncovered0"><a name="line647"></a> 647    end
</span><span class="inferred1"><a name="line648"></a> 648 
</span><span class="inferred0"><a name="line649"></a> 649    ###############################################################################
</span><span class="inferred1"><a name="line650"></a> 650    #
</span><span class="inferred0"><a name="line651"></a> 651    # set_margins_LR()
</span><span class="inferred1"><a name="line652"></a> 652    #
</span><span class="inferred0"><a name="line653"></a> 653    # Set the left and right margins to the same value in inches.
</span><span class="inferred1"><a name="line654"></a> 654    #
</span><span class="marked0"><a name="line655"></a> 655    def set_margins_LR(margin)
</span><span class="uncovered1"><a name="line656"></a> 656       set_margin_left(margin)
</span><span class="uncovered0"><a name="line657"></a> 657       set_margin_right(margin)
</span><span class="uncovered1"><a name="line658"></a> 658    end
</span><span class="inferred0"><a name="line659"></a> 659 
</span><span class="inferred1"><a name="line660"></a> 660    ###############################################################################
</span><span class="inferred0"><a name="line661"></a> 661    #
</span><span class="inferred1"><a name="line662"></a> 662    # set_margins_TB()
</span><span class="inferred0"><a name="line663"></a> 663    #
</span><span class="inferred1"><a name="line664"></a> 664    # Set the top and bottom margins to the same value in inches.
</span><span class="inferred0"><a name="line665"></a> 665    #
</span><span class="marked1"><a name="line666"></a> 666    def set_margins_TB(margin)
</span><span class="uncovered0"><a name="line667"></a> 667       set_margin_top(margin)
</span><span class="uncovered1"><a name="line668"></a> 668       set_margin_bottom(margin)
</span><span class="uncovered0"><a name="line669"></a> 669    end
</span><span class="inferred1"><a name="line670"></a> 670 
</span><span class="inferred0"><a name="line671"></a> 671 
</span><span class="inferred1"><a name="line672"></a> 672    ###############################################################################
</span><span class="inferred0"><a name="line673"></a> 673    #
</span><span class="inferred1"><a name="line674"></a> 674    # set_margin_left()
</span><span class="inferred0"><a name="line675"></a> 675    #
</span><span class="inferred1"><a name="line676"></a> 676    # Set the left margin in inches.
</span><span class="inferred0"><a name="line677"></a> 677    #
</span><span class="marked1"><a name="line678"></a> 678    def set_margin_left(margin = 0.75)
</span><span class="uncovered0"><a name="line679"></a> 679       @margin_left = margin
</span><span class="uncovered1"><a name="line680"></a> 680    end
</span><span class="inferred0"><a name="line681"></a> 681 
</span><span class="inferred1"><a name="line682"></a> 682 
</span><span class="inferred0"><a name="line683"></a> 683    ###############################################################################
</span><span class="inferred1"><a name="line684"></a> 684    #
</span><span class="inferred0"><a name="line685"></a> 685    # set_margin_right()
</span><span class="inferred1"><a name="line686"></a> 686    #
</span><span class="inferred0"><a name="line687"></a> 687    # Set the right margin in inches.
</span><span class="inferred1"><a name="line688"></a> 688    #
</span><span class="marked0"><a name="line689"></a> 689    def set_margin_right(margin = 0.75)
</span><span class="uncovered1"><a name="line690"></a> 690       @margin_right = margin
</span><span class="uncovered0"><a name="line691"></a> 691    end
</span><span class="inferred1"><a name="line692"></a> 692 
</span><span class="inferred0"><a name="line693"></a> 693    ###############################################################################
</span><span class="inferred1"><a name="line694"></a> 694    #
</span><span class="inferred0"><a name="line695"></a> 695    # set_margin_top()
</span><span class="inferred1"><a name="line696"></a> 696    #
</span><span class="inferred0"><a name="line697"></a> 697    # Set the top margin in inches.
</span><span class="inferred1"><a name="line698"></a> 698    #
</span><span class="marked0"><a name="line699"></a> 699    def set_margin_top(margin = 1.00)
</span><span class="uncovered1"><a name="line700"></a> 700       @margin_top = margin
</span><span class="uncovered0"><a name="line701"></a> 701    end
</span><span class="inferred1"><a name="line702"></a> 702 
</span><span class="inferred0"><a name="line703"></a> 703    ###############################################################################
</span><span class="inferred1"><a name="line704"></a> 704    #
</span><span class="inferred0"><a name="line705"></a> 705    # set_margin_bottom()
</span><span class="inferred1"><a name="line706"></a> 706    #
</span><span class="inferred0"><a name="line707"></a> 707    # Set the bottom margin in inches.
</span><span class="inferred1"><a name="line708"></a> 708    #
</span><span class="marked0"><a name="line709"></a> 709    def set_margin_bottom(margin = 1.00)
</span><span class="uncovered1"><a name="line710"></a> 710       @margin_bottom = margin
</span><span class="uncovered0"><a name="line711"></a> 711    end
</span><span class="inferred1"><a name="line712"></a> 712 
</span><span class="inferred0"><a name="line713"></a> 713    ###############################################################################
</span><span class="inferred1"><a name="line714"></a> 714    #
</span><span class="inferred0"><a name="line715"></a> 715    # repeat_rows($first_row, $last_row)
</span><span class="inferred1"><a name="line716"></a> 716    #
</span><span class="inferred0"><a name="line717"></a> 717    # Set the rows to repeat at the top of each printed page. See also the
</span><span class="inferred1"><a name="line718"></a> 718    # _store_name_xxxx() methods in Workbook.pm.
</span><span class="inferred0"><a name="line719"></a> 719    #
</span><span class="marked1"><a name="line720"></a> 720    def repeat_rows(first_row, last_row = nil)
</span><span class="uncovered0"><a name="line721"></a> 721       @title_rowmin  = first_row
</span><span class="uncovered1"><a name="line722"></a> 722       @title_rowmax  = last_row || first_row # Second row is optional
</span><span class="uncovered0"><a name="line723"></a> 723    end
</span><span class="inferred1"><a name="line724"></a> 724 
</span><span class="inferred0"><a name="line725"></a> 725    ###############################################################################
</span><span class="inferred1"><a name="line726"></a> 726    #
</span><span class="inferred0"><a name="line727"></a> 727    # repeat_columns($first_col, $last_col)
</span><span class="inferred1"><a name="line728"></a> 728    #
</span><span class="inferred0"><a name="line729"></a> 729    # Set the columns to repeat at the left hand side of each printed page.
</span><span class="inferred1"><a name="line730"></a> 730    # See also the _store_names() methods in Workbook.pm.
</span><span class="inferred0"><a name="line731"></a> 731    #
</span><span class="marked1"><a name="line732"></a> 732    def repeat_columns(*args)
</span><span class="uncovered0"><a name="line733"></a> 733       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered1"><a name="line734"></a> 734       if args =~ /^\D/
</span><span class="uncovered0"><a name="line735"></a> 735          args = substitute_cellref(*args)
</span><span class="uncovered1"><a name="line736"></a> 736 
</span><span class="uncovered0"><a name="line737"></a> 737          # Returned values $row1 and $row2 aren't required here. Remove them.
</span><span class="uncovered1"><a name="line738"></a> 738          args.shift        # $row1
</span><span class="uncovered0"><a name="line739"></a> 739          args.delete_at(1) # $row2
</span><span class="uncovered1"><a name="line740"></a> 740       end
</span><span class="uncovered0"><a name="line741"></a> 741    
</span><span class="uncovered1"><a name="line742"></a> 742       @title_colmin  = args[0]
</span><span class="uncovered0"><a name="line743"></a> 743       @title_colmax  = args[1] || args[0] # Second col is optional
</span><span class="uncovered1"><a name="line744"></a> 744    end
</span><span class="inferred0"><a name="line745"></a> 745 
</span><span class="inferred1"><a name="line746"></a> 746    ###############################################################################
</span><span class="inferred0"><a name="line747"></a> 747    #
</span><span class="inferred1"><a name="line748"></a> 748    # print_area($first_row, $first_col, $last_row, $last_col)
</span><span class="inferred0"><a name="line749"></a> 749    #
</span><span class="inferred1"><a name="line750"></a> 750    # Set the area of each worksheet that will be printed. See also the
</span><span class="inferred0"><a name="line751"></a> 751    # _store_names() methods in Workbook.pm.
</span><span class="inferred1"><a name="line752"></a> 752    #
</span><span class="marked0"><a name="line753"></a> 753    def print_area(*args)
</span><span class="uncovered1"><a name="line754"></a> 754       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered0"><a name="line755"></a> 755       if args =~ /^\D/
</span><span class="uncovered1"><a name="line756"></a> 756          args = substitute_cellref(*args)
</span><span class="uncovered0"><a name="line757"></a> 757       end
</span><span class="uncovered1"><a name="line758"></a> 758 
</span><span class="uncovered0"><a name="line759"></a> 759       return if args.size != 4 # Require 4 parameters
</span><span class="uncovered1"><a name="line760"></a> 760 
</span><span class="uncovered0"><a name="line761"></a> 761       @print_rowmin, @print_colmin, @print_rowmax, @print_colmax = args
</span><span class="uncovered1"><a name="line762"></a> 762    end
</span><span class="inferred0"><a name="line763"></a> 763 
</span><span class="inferred1"><a name="line764"></a> 764    ###############################################################################
</span><span class="inferred0"><a name="line765"></a> 765    #
</span><span class="inferred1"><a name="line766"></a> 766    # autofilter($first_row, $first_col, $last_row, $last_col)
</span><span class="inferred0"><a name="line767"></a> 767    #
</span><span class="inferred1"><a name="line768"></a> 768    # Set the autofilter area in the worksheet.
</span><span class="inferred0"><a name="line769"></a> 769    #
</span><span class="marked1"><a name="line770"></a> 770    def autofilter(*args)
</span><span class="inferred0"><a name="line771"></a> 771      # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line772"></a> 772      if args[0] =~ /^\D/
</span><span class="inferred0"><a name="line773"></a> 773          args = substitute_cellref(*args)
</span><span class="inferred1"><a name="line774"></a> 774       end
</span><span class="inferred0"><a name="line775"></a> 775 
</span><span class="marked1"><a name="line776"></a> 776      return if args.size != 4 # Require 4 parameters
</span><span class="inferred0"><a name="line777"></a> 777 
</span><span class="marked1"><a name="line778"></a> 778      row1, col1, row2, col2 = args
</span><span class="inferred0"><a name="line779"></a> 779 
</span><span class="inferred1"><a name="line780"></a> 780       # Reverse max and min values if necessary.
</span><span class="marked0"><a name="line781"></a> 781       if row2 &lt; row1
</span><span class="uncovered1"><a name="line782"></a> 782          tmp  = row1
</span><span class="uncovered0"><a name="line783"></a> 783          row1 = row2
</span><span class="uncovered1"><a name="line784"></a> 784          row2 = tmp
</span><span class="uncovered0"><a name="line785"></a> 785       end
</span><span class="marked1"><a name="line786"></a> 786       if col2 &lt; col1
</span><span class="uncovered0"><a name="line787"></a> 787          tmp  = col1
</span><span class="uncovered1"><a name="line788"></a> 788          col1 = col2
</span><span class="uncovered0"><a name="line789"></a> 789          col2 = col1
</span><span class="uncovered1"><a name="line790"></a> 790       end
</span><span class="inferred0"><a name="line791"></a> 791 
</span><span class="inferred1"><a name="line792"></a> 792       # Store the Autofilter information
</span><span class="marked0"><a name="line793"></a> 793       @filter_area = [row1, row2, col1, col2]
</span><span class="marked1"><a name="line794"></a> 794       @filter_count = 1 + col2 -col1
</span><span class="inferred0"><a name="line795"></a> 795    end
</span><span class="inferred1"><a name="line796"></a> 796 
</span><span class="inferred0"><a name="line797"></a> 797    ###############################################################################
</span><span class="inferred1"><a name="line798"></a> 798    #
</span><span class="inferred0"><a name="line799"></a> 799    # filter_column($column, $criteria, ...)
</span><span class="inferred1"><a name="line800"></a> 800    #
</span><span class="inferred0"><a name="line801"></a> 801    # Set the column filter criteria.
</span><span class="inferred1"><a name="line802"></a> 802    #
</span><span class="marked0"><a name="line803"></a> 803    def filter_column(col, expression)
</span><span class="marked1"><a name="line804"></a> 804       raise &quot;Must call autofilter() before filter_column()&quot; if @filter_count == 0
</span><span class="inferred0"><a name="line805"></a> 805 #      raise &quot;Incorrect number of arguments to filter_column()&quot; unless @_ == 2
</span><span class="inferred1"><a name="line806"></a> 806 
</span><span class="inferred0"><a name="line807"></a> 807       # Check for a column reference in A1 notation and substitute.
</span><span class="marked1"><a name="line808"></a> 808       if col =~ /^\D/
</span><span class="inferred0"><a name="line809"></a> 809          # Convert col ref to a cell ref and then to a col number.
</span><span class="inferred1"><a name="line810"></a> 810          no_use, col = substitute_cellref(col + '1')
</span><span class="inferred0"><a name="line811"></a> 811       end
</span><span class="marked1"><a name="line812"></a> 812       col_first = @filter_area[2]
</span><span class="marked0"><a name="line813"></a> 813       col_last  = @filter_area[3]
</span><span class="inferred1"><a name="line814"></a> 814 
</span><span class="inferred0"><a name="line815"></a> 815       # Reject column if it is outside filter range.
</span><span class="marked1"><a name="line816"></a> 816       if (col &lt; col_first or col &gt; col_last)
</span><span class="uncovered0"><a name="line817"></a> 817          raise &quot;Column '#{col}' outside autofilter() column range &quot; +
</span><span class="uncovered1"><a name="line818"></a> 818                &quot;(#{col_first} .. #{col_last})&quot;;
</span><span class="uncovered0"><a name="line819"></a> 819       end
</span><span class="inferred1"><a name="line820"></a> 820 
</span><span class="marked0"><a name="line821"></a> 821       tokens = extract_filter_tokens(expression)
</span><span class="inferred1"><a name="line822"></a> 822 
</span><span class="marked0"><a name="line823"></a> 823       unless (tokens.size == 3 or tokens.size == 7)
</span><span class="uncovered1"><a name="line824"></a> 824          raise &quot;Incorrect number of tokens in expression '#{expression}'&quot;
</span><span class="uncovered0"><a name="line825"></a> 825       end
</span><span class="inferred1"><a name="line826"></a> 826 
</span><span class="inferred0"><a name="line827"></a> 827 
</span><span class="marked1"><a name="line828"></a> 828       tokens = parse_filter_expression(expression, tokens)
</span><span class="inferred0"><a name="line829"></a> 829 
</span><span class="marked1"><a name="line830"></a> 830       @filter_cols[col] = Array.new(tokens)
</span><span class="marked0"><a name="line831"></a> 831       @filter_on        = 1
</span><span class="inferred1"><a name="line832"></a> 832    end
</span><span class="inferred0"><a name="line833"></a> 833 
</span><span class="inferred1"><a name="line834"></a> 834    ###############################################################################
</span><span class="inferred0"><a name="line835"></a> 835    #
</span><span class="inferred1"><a name="line836"></a> 836    # _extract_filter_tokens($expression)
</span><span class="inferred0"><a name="line837"></a> 837    #
</span><span class="inferred1"><a name="line838"></a> 838    # Extract the tokens from the filter expression. The tokens are mainly non-
</span><span class="inferred0"><a name="line839"></a> 839    # whitespace groups. The only tricky part is to extract string tokens that
</span><span class="inferred1"><a name="line840"></a> 840    # contain whitespace and/or quoted double quotes (Excel's escaped quotes).
</span><span class="inferred0"><a name="line841"></a> 841    #
</span><span class="inferred1"><a name="line842"></a> 842    # Examples: 'x &lt;  2000'
</span><span class="inferred0"><a name="line843"></a> 843    #           'x &gt;  2000 and x &lt;  5000'
</span><span class="inferred1"><a name="line844"></a> 844    #           'x = &quot;foo&quot;'
</span><span class="inferred0"><a name="line845"></a> 845    #           'x = &quot;foo bar&quot;'
</span><span class="inferred1"><a name="line846"></a> 846    #           'x = &quot;foo &quot;&quot; bar&quot;'
</span><span class="inferred0"><a name="line847"></a> 847    #
</span><span class="marked1"><a name="line848"></a> 848    def extract_filter_tokens(expression = nil)
</span><span class="marked0"><a name="line849"></a> 849       return unless expression
</span><span class="inferred1"><a name="line850"></a> 850 
</span><span class="inferred0"><a name="line851"></a> 851       #  @tokens = ($expression  =~ /&quot;(?:[^&quot;]|&quot;&quot;)*&quot;|\S+/g); #&quot;
</span><span class="inferred1"><a name="line852"></a> 852 
</span><span class="marked0"><a name="line853"></a> 853       tokens = []
</span><span class="marked1"><a name="line854"></a> 854       str = expression
</span><span class="marked0"><a name="line855"></a> 855       while str =~ /&quot;(?:[^&quot;]|&quot;&quot;)*&quot;|\S+/
</span><span class="marked1"><a name="line856"></a> 856          tokens &lt;&lt; $&amp;
</span><span class="marked0"><a name="line857"></a> 857          str = $~.post_match
</span><span class="inferred1"><a name="line858"></a> 858       end
</span><span class="inferred0"><a name="line859"></a> 859 
</span><span class="inferred1"><a name="line860"></a> 860       # Remove leading and trailing quotes and unescape other quotes
</span><span class="marked0"><a name="line861"></a> 861       tokens.map! do |token|
</span><span class="marked1"><a name="line862"></a> 862          token.sub!(/^&quot;/, '')
</span><span class="marked0"><a name="line863"></a> 863          token.sub!(/&quot;$/, '')
</span><span class="marked1"><a name="line864"></a> 864          token.gsub!(/&quot;&quot;/, '&quot;')
</span><span class="inferred0"><a name="line865"></a> 865       end
</span><span class="inferred1"><a name="line866"></a> 866 
</span><span class="marked0"><a name="line867"></a> 867       return tokens
</span><span class="inferred1"><a name="line868"></a> 868    end
</span><span class="inferred0"><a name="line869"></a> 869 
</span><span class="inferred1"><a name="line870"></a> 870    ###############################################################################
</span><span class="inferred0"><a name="line871"></a> 871    #
</span><span class="inferred1"><a name="line872"></a> 872    # _parse_filter_expression(expression, @token)
</span><span class="inferred0"><a name="line873"></a> 873    #
</span><span class="inferred1"><a name="line874"></a> 874    # Converts the tokens of a possibly conditional expression into 1 or 2
</span><span class="inferred0"><a name="line875"></a> 875    # sub expressions for further parsing.
</span><span class="inferred1"><a name="line876"></a> 876    #
</span><span class="inferred0"><a name="line877"></a> 877    # Examples:
</span><span class="inferred1"><a name="line878"></a> 878    #          ('x', '==', 2000) -&gt; exp1
</span><span class="inferred0"><a name="line879"></a> 879    #          ('x', '&gt;',  2000, 'and', 'x', '&lt;', 5000) -&gt; exp1 and exp2
</span><span class="inferred1"><a name="line880"></a> 880    #
</span><span class="marked0"><a name="line881"></a> 881    def parse_filter_expression(expression, tokens)
</span><span class="inferred1"><a name="line882"></a> 882       # The number of tokens will be either 3 (for 1 expression)
</span><span class="inferred0"><a name="line883"></a> 883       # or 7 (for 2  expressions).
</span><span class="inferred1"><a name="line884"></a> 884       #
</span><span class="marked0"><a name="line885"></a> 885       if (tokens.size == 7)
</span><span class="uncovered1"><a name="line886"></a> 886          conditional = tokens[3]
</span><span class="uncovered0"><a name="line887"></a> 887          if conditional =~ /^(and|&amp;&amp;)$/
</span><span class="uncovered1"><a name="line888"></a> 888             conditional = 0
</span><span class="uncovered0"><a name="line889"></a> 889          elsif conditional =~ /^(or|\|\|)$/
</span><span class="uncovered1"><a name="line890"></a> 890             conditional = 1
</span><span class="uncovered0"><a name="line891"></a> 891          else
</span><span class="uncovered1"><a name="line892"></a> 892             raise &quot;Token '#{conditional}' is not a valid conditional &quot; +
</span><span class="uncovered0"><a name="line893"></a> 893                   &quot;in filter expression '#{expression}'&quot;
</span><span class="uncovered1"><a name="line894"></a> 894          end
</span><span class="uncovered0"><a name="line895"></a> 895          expression_1 = parse_filter_tokens(expression, tokens[0..2])
</span><span class="uncovered1"><a name="line896"></a> 896          expression_2 = parse_filter_tokens(expression, tokens[4..6])
</span><span class="uncovered0"><a name="line897"></a> 897          return [expression_1, conditional, expression_2]
</span><span class="inferred1"><a name="line898"></a> 898       else
</span><span class="marked0"><a name="line899"></a> 899          return parse_filter_tokens(expression, tokens)
</span><span class="inferred1"><a name="line900"></a> 900       end
</span><span class="marked0"><a name="line901"></a> 901    end
</span><span class="inferred1"><a name="line902"></a> 902 
</span><span class="inferred0"><a name="line903"></a> 903    ###############################################################################
</span><span class="inferred1"><a name="line904"></a> 904    #
</span><span class="inferred0"><a name="line905"></a> 905    # _parse_filter_tokens(@token)  # (@expression, @token)
</span><span class="inferred1"><a name="line906"></a> 906    #
</span><span class="inferred0"><a name="line907"></a> 907    # Parse the 3 tokens of a filter expression and return the operator and token.
</span><span class="inferred1"><a name="line908"></a> 908    #
</span><span class="marked0"><a name="line909"></a> 909    def parse_filter_tokens(expression, tokens)
</span><span class="marked1"><a name="line910"></a> 910       operators = {
</span><span class="inferred0"><a name="line911"></a> 911          '==' =&gt; 2,
</span><span class="inferred1"><a name="line912"></a> 912          '='  =&gt; 2,
</span><span class="inferred0"><a name="line913"></a> 913          '=~' =&gt; 2,
</span><span class="inferred1"><a name="line914"></a> 914          'eq' =&gt; 2,
</span><span class="inferred0"><a name="line915"></a> 915 
</span><span class="inferred1"><a name="line916"></a> 916          '!=' =&gt; 5,
</span><span class="inferred0"><a name="line917"></a> 917          '!~' =&gt; 5,
</span><span class="inferred1"><a name="line918"></a> 918          'ne' =&gt; 5,
</span><span class="inferred0"><a name="line919"></a> 919          '&lt;&gt;' =&gt; 5,
</span><span class="inferred1"><a name="line920"></a> 920 
</span><span class="inferred0"><a name="line921"></a> 921          '&lt;'  =&gt; 1,
</span><span class="inferred1"><a name="line922"></a> 922          '&lt;=' =&gt; 3,
</span><span class="inferred0"><a name="line923"></a> 923          '&gt;'  =&gt; 4,
</span><span class="inferred1"><a name="line924"></a> 924          '&gt;=' =&gt; 6,
</span><span class="inferred0"><a name="line925"></a> 925       }
</span><span class="inferred1"><a name="line926"></a> 926 
</span><span class="marked0"><a name="line927"></a> 927       operator = operators[tokens[1]]
</span><span class="marked1"><a name="line928"></a> 928       token    = tokens[2]
</span><span class="inferred0"><a name="line929"></a> 929 
</span><span class="inferred1"><a name="line930"></a> 930       # Special handling of &quot;Top&quot; filter expressions.
</span><span class="marked0"><a name="line931"></a> 931       if tokens[0] =~ /^top|bottom$/i
</span><span class="uncovered1"><a name="line932"></a> 932          value = tokens[1]
</span><span class="uncovered0"><a name="line933"></a> 933          if (value =~ /\D/ or value &lt; 1 or value &gt; 500)
</span><span class="uncovered1"><a name="line934"></a> 934             raise &quot;The value '#{value}' in expression '#{expression}' &quot; +
</span><span class="uncovered0"><a name="line935"></a> 935                   &quot;must be in the range 1 to 500&quot;
</span><span class="uncovered1"><a name="line936"></a> 936          end
</span><span class="uncovered0"><a name="line937"></a> 937          token.downcase!
</span><span class="uncovered1"><a name="line938"></a> 938          if (token != 'items' and token != '%')
</span><span class="uncovered0"><a name="line939"></a> 939             raise &quot;The type '#{token}' in expression '#{expression}' &quot; +
</span><span class="uncovered1"><a name="line940"></a> 940                   &quot;must be either 'items' or '%'&quot;
</span><span class="uncovered0"><a name="line941"></a> 941          end
</span><span class="uncovered1"><a name="line942"></a> 942 
</span><span class="uncovered0"><a name="line943"></a> 943          if (tokens[0] =~ /^top$/i)
</span><span class="uncovered1"><a name="line944"></a> 944             operator = 30
</span><span class="uncovered0"><a name="line945"></a> 945          else
</span><span class="uncovered1"><a name="line946"></a> 946             operator = 32
</span><span class="uncovered0"><a name="line947"></a> 947          end
</span><span class="uncovered1"><a name="line948"></a> 948 
</span><span class="uncovered0"><a name="line949"></a> 949          if (tokens[2] == '%')
</span><span class="uncovered1"><a name="line950"></a> 950             operator = operator + 1
</span><span class="uncovered0"><a name="line951"></a> 951          end
</span><span class="uncovered1"><a name="line952"></a> 952 
</span><span class="uncovered0"><a name="line953"></a> 953          token    = value
</span><span class="uncovered1"><a name="line954"></a> 954       end
</span><span class="inferred0"><a name="line955"></a> 955 
</span><span class="marked1"><a name="line956"></a> 956       if (not operator and tokens[0])
</span><span class="uncovered0"><a name="line957"></a> 957          raise &quot;Token '#{tokens[1]}' is not a valid operator &quot; +
</span><span class="uncovered1"><a name="line958"></a> 958                &quot;in filter expression '#{expression}'&quot;
</span><span class="uncovered0"><a name="line959"></a> 959       end
</span><span class="inferred1"><a name="line960"></a> 960 
</span><span class="inferred0"><a name="line961"></a> 961       # Special handling for Blanks/NonBlanks.
</span><span class="marked1"><a name="line962"></a> 962       if (token =~ /^blanks|nonblanks$/i)
</span><span class="uncovered0"><a name="line963"></a> 963          # Only allow Equals or NotEqual in this context.
</span><span class="uncovered1"><a name="line964"></a> 964          if (operator != 2 and operator != 5)
</span><span class="uncovered0"><a name="line965"></a> 965             raise &quot;The operator '#{tokens[1]}' in expression '#{expression}' &quot; +
</span><span class="uncovered1"><a name="line966"></a> 966                   &quot;is not valid in relation to Blanks/NonBlanks'&quot;
</span><span class="uncovered0"><a name="line967"></a> 967          end
</span><span class="uncovered1"><a name="line968"></a> 968 
</span><span class="uncovered0"><a name="line969"></a> 969          token.downcase!
</span><span class="uncovered1"><a name="line970"></a> 970          
</span><span class="uncovered0"><a name="line971"></a> 971          # The operator should always be 2 (=) to flag a &quot;simple&quot; equality in
</span><span class="uncovered1"><a name="line972"></a> 972          # the binary record. Therefore we convert &lt;&gt; to =.
</span><span class="uncovered0"><a name="line973"></a> 973          if (token == 'blanks')
</span><span class="uncovered1"><a name="line974"></a> 974             if (operator == 5)
</span><span class="uncovered0"><a name="line975"></a> 975                operator = 2
</span><span class="uncovered1"><a name="line976"></a> 976                token    = 'nonblanks'
</span><span class="uncovered0"><a name="line977"></a> 977             end
</span><span class="uncovered1"><a name="line978"></a> 978          else
</span><span class="uncovered0"><a name="line979"></a> 979             if (operator == 5)
</span><span class="uncovered1"><a name="line980"></a> 980                operator = 2
</span><span class="uncovered0"><a name="line981"></a> 981                token    = 'blanks'
</span><span class="uncovered1"><a name="line982"></a> 982             end
</span><span class="uncovered0"><a name="line983"></a> 983          end
</span><span class="uncovered1"><a name="line984"></a> 984       end
</span><span class="inferred0"><a name="line985"></a> 985 
</span><span class="inferred1"><a name="line986"></a> 986       # if the string token contains an Excel match character then change the
</span><span class="inferred0"><a name="line987"></a> 987       # operator type to indicate a non &quot;simple&quot; equality.
</span><span class="marked1"><a name="line988"></a> 988       if (operator == 2 and token =~ /[*?]/)
</span><span class="uncovered0"><a name="line989"></a> 989          operator = 22
</span><span class="uncovered1"><a name="line990"></a> 990       end
</span><span class="inferred0"><a name="line991"></a> 991 
</span><span class="marked1"><a name="line992"></a> 992       return [operator, token]
</span><span class="inferred0"><a name="line993"></a> 993    end
</span><span class="inferred1"><a name="line994"></a> 994 
</span><span class="inferred0"><a name="line995"></a> 995    ###############################################################################
</span><span class="inferred1"><a name="line996"></a> 996    #
</span><span class="inferred0"><a name="line997"></a> 997    # hide_gridlines()
</span><span class="inferred1"><a name="line998"></a> 998    #
</span><span class="inferred0"><a name="line999"></a> 999    # Set the option to hide gridlines on the screen and the printed page.
</span><span class="inferred1"><a name="line1000"></a>1000    # There are two ways of doing this in the Excel BIFF format: The first is by
</span><span class="inferred0"><a name="line1001"></a>1001    # setting the DspGrid field of the WINDOW2 record, this turns off the screen
</span><span class="inferred1"><a name="line1002"></a>1002    # and subsequently the print gridline. The second method is to via the
</span><span class="inferred0"><a name="line1003"></a>1003    # PRINTGRIDLINES and GRIDSET records, this turns off the printed gridlines
</span><span class="inferred1"><a name="line1004"></a>1004    # only. The first method is probably sufficient for most cases. The second
</span><span class="inferred0"><a name="line1005"></a>1005    # method is supported for backwards compatibility. Porters take note.
</span><span class="inferred1"><a name="line1006"></a>1006    #
</span><span class="marked0"><a name="line1007"></a>1007    def hide_gridlines(option = 1)
</span><span class="uncovered1"><a name="line1008"></a>1008       if option == 0
</span><span class="uncovered0"><a name="line1009"></a>1009          @print_gridlines  = 1  # 1 = display, 0 = hide
</span><span class="uncovered1"><a name="line1010"></a>1010          @screen_gridlines = 1
</span><span class="uncovered0"><a name="line1011"></a>1011       elsif option == 1
</span><span class="uncovered1"><a name="line1012"></a>1012          @print_gridlines  = 0
</span><span class="uncovered0"><a name="line1013"></a>1013          @screen_gridlines = 1
</span><span class="uncovered1"><a name="line1014"></a>1014       else
</span><span class="uncovered0"><a name="line1015"></a>1015          @print_gridlines  = 0
</span><span class="uncovered1"><a name="line1016"></a>1016          @screen_gridlines = 0
</span><span class="uncovered0"><a name="line1017"></a>1017       end
</span><span class="uncovered1"><a name="line1018"></a>1018    end
</span><span class="inferred0"><a name="line1019"></a>1019 
</span><span class="inferred1"><a name="line1020"></a>1020    ###############################################################################
</span><span class="inferred0"><a name="line1021"></a>1021    #
</span><span class="inferred1"><a name="line1022"></a>1022    # print_row_col_headers()
</span><span class="inferred0"><a name="line1023"></a>1023    #
</span><span class="inferred1"><a name="line1024"></a>1024    # Set the option to print the row and column headers on the printed page.
</span><span class="inferred0"><a name="line1025"></a>1025    # See also the _store_print_headers() method below.
</span><span class="inferred1"><a name="line1026"></a>1026    #
</span><span class="marked0"><a name="line1027"></a>1027    def print_row_col_headers(option = nil)
</span><span class="uncovered1"><a name="line1028"></a>1028       if option.nil?
</span><span class="uncovered0"><a name="line1029"></a>1029          @print_headers = 1
</span><span class="uncovered1"><a name="line1030"></a>1030       else
</span><span class="uncovered0"><a name="line1031"></a>1031          @print_headers = option
</span><span class="uncovered1"><a name="line1032"></a>1032       end
</span><span class="uncovered0"><a name="line1033"></a>1033    end
</span><span class="inferred1"><a name="line1034"></a>1034 
</span><span class="inferred0"><a name="line1035"></a>1035    ###############################################################################
</span><span class="inferred1"><a name="line1036"></a>1036    #
</span><span class="inferred0"><a name="line1037"></a>1037    # fit_to_pages($width, $height)
</span><span class="inferred1"><a name="line1038"></a>1038    #
</span><span class="inferred0"><a name="line1039"></a>1039    # Store the vertical and horizontal number of pages that will define the
</span><span class="inferred1"><a name="line1040"></a>1040    # maximum area printed. See also _store_setup() and _store_wsbool() below.
</span><span class="inferred0"><a name="line1041"></a>1041    #
</span><span class="marked1"><a name="line1042"></a>1042    def fit_to_pages(width = 0, height = 0)
</span><span class="uncovered0"><a name="line1043"></a>1043       @fit_page      = 1
</span><span class="uncovered1"><a name="line1044"></a>1044       @fit_width     = width
</span><span class="uncovered0"><a name="line1045"></a>1045       @fit_height    = height
</span><span class="uncovered1"><a name="line1046"></a>1046    end
</span><span class="inferred0"><a name="line1047"></a>1047 
</span><span class="inferred1"><a name="line1048"></a>1048    ###############################################################################
</span><span class="inferred0"><a name="line1049"></a>1049    #
</span><span class="inferred1"><a name="line1050"></a>1050    # set_h_pagebreaks(@breaks)
</span><span class="inferred0"><a name="line1051"></a>1051    #
</span><span class="inferred1"><a name="line1052"></a>1052    # Store the horizontal page breaks on a worksheet.
</span><span class="inferred0"><a name="line1053"></a>1053    #
</span><span class="marked1"><a name="line1054"></a>1054    def set_h_pagebreaks(breaks)
</span><span class="uncovered0"><a name="line1055"></a>1055       @hbreaks.push(breaks)
</span><span class="uncovered1"><a name="line1056"></a>1056    end
</span><span class="inferred0"><a name="line1057"></a>1057    
</span><span class="inferred1"><a name="line1058"></a>1058    ###############################################################################
</span><span class="inferred0"><a name="line1059"></a>1059    #
</span><span class="inferred1"><a name="line1060"></a>1060    # set_v_pagebreaks(@breaks)
</span><span class="inferred0"><a name="line1061"></a>1061    #
</span><span class="inferred1"><a name="line1062"></a>1062    # Store the vertical page breaks on a worksheet.
</span><span class="inferred0"><a name="line1063"></a>1063    #
</span><span class="marked1"><a name="line1064"></a>1064    def set_v_pagebreaks(breaks)
</span><span class="uncovered0"><a name="line1065"></a>1065       @vbreaks.push(breaks)
</span><span class="uncovered1"><a name="line1066"></a>1066    end
</span><span class="inferred0"><a name="line1067"></a>1067    
</span><span class="inferred1"><a name="line1068"></a>1068    ###############################################################################
</span><span class="inferred0"><a name="line1069"></a>1069    #
</span><span class="inferred1"><a name="line1070"></a>1070    # set_zoom($scale)
</span><span class="inferred0"><a name="line1071"></a>1071    #
</span><span class="inferred1"><a name="line1072"></a>1072    # Set the worksheet zoom factor.
</span><span class="inferred0"><a name="line1073"></a>1073    #
</span><span class="marked1"><a name="line1074"></a>1074    def set_zoom(scale = 100)
</span><span class="uncovered0"><a name="line1075"></a>1075       # Confine the scale to Excel's range
</span><span class="uncovered1"><a name="line1076"></a>1076       if scale &lt; 10 or scale &gt; 400
</span><span class="uncovered0"><a name="line1077"></a>1077          #           carp &quot;Zoom factor $scale outside range: 10 &lt;= zoom &lt;= 400&quot;;
</span><span class="uncovered1"><a name="line1078"></a>1078          scale = 100
</span><span class="uncovered0"><a name="line1079"></a>1079       end
</span><span class="uncovered1"><a name="line1080"></a>1080 
</span><span class="uncovered0"><a name="line1081"></a>1081       @zoom = scale.to_i
</span><span class="uncovered1"><a name="line1082"></a>1082    end
</span><span class="inferred0"><a name="line1083"></a>1083    
</span><span class="inferred1"><a name="line1084"></a>1084    ###############################################################################
</span><span class="inferred0"><a name="line1085"></a>1085    #
</span><span class="inferred1"><a name="line1086"></a>1086    # set_print_scale($scale)
</span><span class="inferred0"><a name="line1087"></a>1087    #
</span><span class="inferred1"><a name="line1088"></a>1088    # Set the scale factor for the printed page.
</span><span class="inferred0"><a name="line1089"></a>1089    #
</span><span class="marked1"><a name="line1090"></a>1090    def set_print_scale(scale = 100)
</span><span class="uncovered0"><a name="line1091"></a>1091       # Confine the scale to Excel's range
</span><span class="uncovered1"><a name="line1092"></a>1092       if scale &lt; 10 or scale &gt; 400
</span><span class="uncovered0"><a name="line1093"></a>1093          #           carp &quot;Print scale $scale outside range: 10 &lt;= zoom &lt;= 400&quot;;
</span><span class="uncovered1"><a name="line1094"></a>1094          scale = 100
</span><span class="uncovered0"><a name="line1095"></a>1095       end
</span><span class="uncovered1"><a name="line1096"></a>1096 
</span><span class="uncovered0"><a name="line1097"></a>1097       # Turn off &quot;fit to page&quot; option
</span><span class="uncovered1"><a name="line1098"></a>1098       @fit_page    = 0
</span><span class="uncovered0"><a name="line1099"></a>1099    
</span><span class="uncovered1"><a name="line1100"></a>1100       @print_scale = scale.to_i
</span><span class="uncovered0"><a name="line1101"></a>1101    end
</span><span class="inferred1"><a name="line1102"></a>1102    
</span><span class="inferred0"><a name="line1103"></a>1103    ###############################################################################
</span><span class="inferred1"><a name="line1104"></a>1104    #
</span><span class="inferred0"><a name="line1105"></a>1105    # keep_leading_zeros()
</span><span class="inferred1"><a name="line1106"></a>1106    #
</span><span class="inferred0"><a name="line1107"></a>1107    # Causes the write() method to treat integers with a leading zero as a string.
</span><span class="inferred1"><a name="line1108"></a>1108    # This ensures that any leading zeros such, as in zip codes, are maintained.
</span><span class="inferred0"><a name="line1109"></a>1109    #
</span><span class="marked1"><a name="line1110"></a>1110    def keep_leading_zeros(val = nil)
</span><span class="uncovered0"><a name="line1111"></a>1111       if val.nil?
</span><span class="uncovered1"><a name="line1112"></a>1112          @leading_zeros = 1
</span><span class="uncovered0"><a name="line1113"></a>1113       else
</span><span class="uncovered1"><a name="line1114"></a>1114          @leading_zeros = val
</span><span class="uncovered0"><a name="line1115"></a>1115       end
</span><span class="uncovered1"><a name="line1116"></a>1116    end
</span><span class="inferred0"><a name="line1117"></a>1117    
</span><span class="inferred1"><a name="line1118"></a>1118    ###############################################################################
</span><span class="inferred0"><a name="line1119"></a>1119    #
</span><span class="inferred1"><a name="line1120"></a>1120    # show_comments()
</span><span class="inferred0"><a name="line1121"></a>1121    #
</span><span class="inferred1"><a name="line1122"></a>1122    # Make any comments in the worksheet visible.
</span><span class="inferred0"><a name="line1123"></a>1123    #
</span><span class="marked1"><a name="line1124"></a>1124    def show_comments(val = nil)
</span><span class="uncovered0"><a name="line1125"></a>1125       @comments_visible = val.nil? ? 1 : val
</span><span class="uncovered1"><a name="line1126"></a>1126    end
</span><span class="inferred0"><a name="line1127"></a>1127    
</span><span class="inferred1"><a name="line1128"></a>1128    ###############################################################################
</span><span class="inferred0"><a name="line1129"></a>1129    #
</span><span class="inferred1"><a name="line1130"></a>1130    # set_comments_author()
</span><span class="inferred0"><a name="line1131"></a>1131    #
</span><span class="inferred1"><a name="line1132"></a>1132    # Set the default author of the cell comments.
</span><span class="inferred0"><a name="line1133"></a>1133    #
</span><span class="marked1"><a name="line1134"></a>1134    def set_comments_author(author = '', author_enc = 0)
</span><span class="uncovered0"><a name="line1135"></a>1135       @comments_author     = author
</span><span class="uncovered1"><a name="line1136"></a>1136       @comments_author_enc = author_enc
</span><span class="uncovered0"><a name="line1137"></a>1137    end
</span><span class="inferred1"><a name="line1138"></a>1138    
</span><span class="inferred0"><a name="line1139"></a>1139    ###############################################################################
</span><span class="inferred1"><a name="line1140"></a>1140    #
</span><span class="inferred0"><a name="line1141"></a>1141    # right_to_left()
</span><span class="inferred1"><a name="line1142"></a>1142    #
</span><span class="inferred0"><a name="line1143"></a>1143    # Display the worksheet right to left for some eastern versions of Excel.
</span><span class="inferred1"><a name="line1144"></a>1144    #
</span><span class="marked0"><a name="line1145"></a>1145    def right_to_left(val = nil)
</span><span class="uncovered1"><a name="line1146"></a>1146       @display_arabic = val.nil? ? 1 : val
</span><span class="uncovered0"><a name="line1147"></a>1147    end
</span><span class="inferred1"><a name="line1148"></a>1148    
</span><span class="inferred0"><a name="line1149"></a>1149    ###############################################################################
</span><span class="inferred1"><a name="line1150"></a>1150    #
</span><span class="inferred0"><a name="line1151"></a>1151    # hide_zero()
</span><span class="inferred1"><a name="line1152"></a>1152    #
</span><span class="inferred0"><a name="line1153"></a>1153    # Hide cell zero values.
</span><span class="inferred1"><a name="line1154"></a>1154    #
</span><span class="marked0"><a name="line1155"></a>1155    def hide_zero(val = nil)
</span><span class="uncovered1"><a name="line1156"></a>1156       @display_zeros = val.nil? ? 0 : !val
</span><span class="uncovered0"><a name="line1157"></a>1157    end
</span><span class="inferred1"><a name="line1158"></a>1158    
</span><span class="inferred0"><a name="line1159"></a>1159    ###############################################################################
</span><span class="inferred1"><a name="line1160"></a>1160    #
</span><span class="inferred0"><a name="line1161"></a>1161    # print_across()
</span><span class="inferred1"><a name="line1162"></a>1162    #
</span><span class="inferred0"><a name="line1163"></a>1163    # Set the order in which pages are printed.
</span><span class="inferred1"><a name="line1164"></a>1164    #
</span><span class="marked0"><a name="line1165"></a>1165    def print_across(val = nil)
</span><span class="uncovered1"><a name="line1166"></a>1166       @page_order = val.nil? ? 1 : val
</span><span class="uncovered0"><a name="line1167"></a>1167    end
</span><span class="inferred1"><a name="line1168"></a>1168    
</span><span class="inferred0"><a name="line1169"></a>1169    ###############################################################################
</span><span class="inferred1"><a name="line1170"></a>1170    #
</span><span class="inferred0"><a name="line1171"></a>1171    # set_start_page()
</span><span class="inferred1"><a name="line1172"></a>1172    #
</span><span class="inferred0"><a name="line1173"></a>1173    # Set the start page number.
</span><span class="inferred1"><a name="line1174"></a>1174    #
</span><span class="marked0"><a name="line1175"></a>1175    def set_start_page(start_page = nil)
</span><span class="uncovered1"><a name="line1176"></a>1176       return if start_page.nil?
</span><span class="uncovered0"><a name="line1177"></a>1177    
</span><span class="uncovered1"><a name="line1178"></a>1178       @page_start    = start_page
</span><span class="uncovered0"><a name="line1179"></a>1179       @custom_start  = 1
</span><span class="uncovered1"><a name="line1180"></a>1180    end
</span><span class="inferred0"><a name="line1181"></a>1181 
</span><span class="inferred1"><a name="line1182"></a>1182    ###############################################################################
</span><span class="inferred0"><a name="line1183"></a>1183    #
</span><span class="inferred1"><a name="line1184"></a>1184    # set_first_row_column()
</span><span class="inferred0"><a name="line1185"></a>1185    #
</span><span class="inferred1"><a name="line1186"></a>1186    # Set the topmost and leftmost visible row and column.
</span><span class="inferred0"><a name="line1187"></a>1187    # TODO: Document this when tested fully for interaction with panes.
</span><span class="inferred1"><a name="line1188"></a>1188    #
</span><span class="marked0"><a name="line1189"></a>1189    def set_first_row_column(row = 0, col = 0)
</span><span class="uncovered1"><a name="line1190"></a>1190       row = RowMax - 1  if row &gt; RowMax - 1
</span><span class="uncovered0"><a name="line1191"></a>1191       col = ColMax - 1  if col &gt; ColMax - 1
</span><span class="uncovered1"><a name="line1192"></a>1192    
</span><span class="uncovered0"><a name="line1193"></a>1193       @first_row = row
</span><span class="uncovered1"><a name="line1194"></a>1194       @first_col = col
</span><span class="uncovered0"><a name="line1195"></a>1195    end
</span><span class="inferred1"><a name="line1196"></a>1196 
</span><span class="inferred0"><a name="line1197"></a>1197    ###############################################################################
</span><span class="inferred1"><a name="line1198"></a>1198    #
</span><span class="inferred0"><a name="line1199"></a>1199    # add_write_handler($re, $code_ref)
</span><span class="inferred1"><a name="line1200"></a>1200    #
</span><span class="inferred0"><a name="line1201"></a>1201    # Allow the user to add their own matches and handlers to the write() method.
</span><span class="inferred1"><a name="line1202"></a>1202    #
</span><span class="marked0"><a name="line1203"></a>1203    def add_write_handler(regexp, code_ref)
</span><span class="uncovered1"><a name="line1204"></a>1204       #       return unless ref $_[1] eq 'CODE';
</span><span class="uncovered0"><a name="line1205"></a>1205 
</span><span class="uncovered1"><a name="line1206"></a>1206       @write_match.push([regexp, code_ref])
</span><span class="uncovered0"><a name="line1207"></a>1207    end
</span><span class="inferred1"><a name="line1208"></a>1208 
</span><span class="inferred0"><a name="line1209"></a>1209    ###############################################################################
</span><span class="inferred1"><a name="line1210"></a>1210    #
</span><span class="inferred0"><a name="line1211"></a>1211    # write($row, $col, $token, $format)
</span><span class="inferred1"><a name="line1212"></a>1212    #
</span><span class="inferred0"><a name="line1213"></a>1213    # Parse $token and call appropriate write method. $row and $column are zero
</span><span class="inferred1"><a name="line1214"></a>1214    # indexed. $format is optional.
</span><span class="inferred0"><a name="line1215"></a>1215    #
</span><span class="inferred1"><a name="line1216"></a>1216    # The write_url() methods have a flag to prevent recursion when writing a
</span><span class="inferred0"><a name="line1217"></a>1217    # string that looks like a url.
</span><span class="inferred1"><a name="line1218"></a>1218    #
</span><span class="inferred0"><a name="line1219"></a>1219    # Returns: return value of called subroutine
</span><span class="inferred1"><a name="line1220"></a>1220    #
</span><span class="marked0"><a name="line1221"></a>1221    def write(*args)
</span><span class="inferred1"><a name="line1222"></a>1222       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line1223"></a>1223       if args[0] =~ /^\D/
</span><span class="marked1"><a name="line1224"></a>1224          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line1225"></a>1225       end
</span><span class="inferred1"><a name="line1226"></a>1226 
</span><span class="marked0"><a name="line1227"></a>1227       token = args[2]
</span><span class="inferred1"><a name="line1228"></a>1228 
</span><span class="inferred0"><a name="line1229"></a>1229       # Handle undefs as blanks
</span><span class="marked1"><a name="line1230"></a>1230       token = '' if token.nil?
</span><span class="inferred0"><a name="line1231"></a>1231 
</span><span class="inferred1"><a name="line1232"></a>1232       # First try user defined matches.
</span><span class="marked0"><a name="line1233"></a>1233       @write_match.each do |aref|
</span><span class="uncovered1"><a name="line1234"></a>1234          re  = aref[0]
</span><span class="uncovered0"><a name="line1235"></a>1235          sub = aref[1]
</span><span class="uncovered1"><a name="line1236"></a>1236 
</span><span class="uncovered0"><a name="line1237"></a>1237          if token =~ Regexp.new(re)
</span><span class="uncovered1"><a name="line1238"></a>1238             match = eval(&quot;#{sub} self, args&quot;)
</span><span class="uncovered0"><a name="line1239"></a>1239             return match unless match.nil?
</span><span class="uncovered1"><a name="line1240"></a>1240          end
</span><span class="uncovered0"><a name="line1241"></a>1241       end
</span><span class="inferred1"><a name="line1242"></a>1242 
</span><span class="inferred0"><a name="line1243"></a>1243       # Match an array ref.
</span><span class="marked1"><a name="line1244"></a>1244       if token.kind_of?(Array)
</span><span class="uncovered0"><a name="line1245"></a>1245          return write_row(*args)
</span><span class="inferred1"><a name="line1246"></a>1246          # Match integer with leading zero(s)
</span><span class="marked0"><a name="line1247"></a>1247       elsif @leading_zeros != 0 and token =~ /^0\d+$/
</span><span class="inferred1"><a name="line1248"></a>1248          return write_string(*args)
</span><span class="inferred0"><a name="line1249"></a>1249          # Match number
</span><span class="marked1"><a name="line1250"></a>1250       elsif token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/
</span><span class="inferred0"><a name="line1251"></a>1251          return write_number(*args)
</span><span class="inferred1"><a name="line1252"></a>1252          # Match http, https or ftp URL
</span><span class="marked0"><a name="line1253"></a>1253       elsif token =~ %r|^[fh]tt?ps?://|    and @writing_url == 0
</span><span class="uncovered1"><a name="line1254"></a>1254          return write_url(*args)
</span><span class="inferred0"><a name="line1255"></a>1255          # Match mailto:
</span><span class="marked1"><a name="line1256"></a>1256       elsif token =~ %r|^mailto:|          and @writing_url == 0
</span><span class="uncovered0"><a name="line1257"></a>1257          return write_url(*args)
</span><span class="inferred1"><a name="line1258"></a>1258          # Match internal or external sheet link
</span><span class="marked0"><a name="line1259"></a>1259       elsif token =~ %r!^(?:in|ex)ternal:! and @writing_url == 0
</span><span class="uncovered1"><a name="line1260"></a>1260          return write_url(*args)
</span><span class="inferred0"><a name="line1261"></a>1261          # Match formula
</span><span class="marked1"><a name="line1262"></a>1262       elsif token =~ /^=/
</span><span class="inferred0"><a name="line1263"></a>1263          return write_formula(*args)
</span><span class="inferred1"><a name="line1264"></a>1264          # Match blank
</span><span class="marked0"><a name="line1265"></a>1265       elsif token == ''
</span><span class="marked1"><a name="line1266"></a>1266          args.delete_at(2)     # remove the empty string from the parameter list
</span><span class="marked0"><a name="line1267"></a>1267          return write_blank(*args)
</span><span class="inferred1"><a name="line1268"></a>1268       else
</span><span class="marked0"><a name="line1269"></a>1269          return write_string(*args)
</span><span class="inferred1"><a name="line1270"></a>1270       end
</span><span class="inferred0"><a name="line1271"></a>1271    end
</span><span class="inferred1"><a name="line1272"></a>1272 
</span><span class="inferred0"><a name="line1273"></a>1273 
</span><span class="inferred1"><a name="line1274"></a>1274    ###############################################################################
</span><span class="inferred0"><a name="line1275"></a>1275    #
</span><span class="inferred1"><a name="line1276"></a>1276    # write_row($row, $col, $array_ref, $format)
</span><span class="inferred0"><a name="line1277"></a>1277    #
</span><span class="inferred1"><a name="line1278"></a>1278    # Write a row of data starting from ($row, $col). Call write_col() if any of
</span><span class="inferred0"><a name="line1279"></a>1279    # the elements of the array ref are in turn array refs. This allows the writing
</span><span class="inferred1"><a name="line1280"></a>1280    # of 1D or 2D arrays of data in one go.
</span><span class="inferred0"><a name="line1281"></a>1281    #
</span><span class="inferred1"><a name="line1282"></a>1282    # Returns: the first encountered error value or zero for no errors
</span><span class="inferred0"><a name="line1283"></a>1283    #
</span><span class="marked1"><a name="line1284"></a>1284    def write_row(*args)
</span><span class="inferred0"><a name="line1285"></a>1285       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line1286"></a>1286       if args[0] =~ /^\D/
</span><span class="inferred0"><a name="line1287"></a>1287          args = substitute_cellref(*args)
</span><span class="inferred1"><a name="line1288"></a>1288       end
</span><span class="inferred0"><a name="line1289"></a>1289 
</span><span class="inferred1"><a name="line1290"></a>1290       # Catch non array refs passed by user.
</span><span class="marked0"><a name="line1291"></a>1291       unless args[2].kind_of?(Array)
</span><span class="uncovered1"><a name="line1292"></a>1292          raise &quot;Not an array ref in call to write_row() #{$!}&quot;;
</span><span class="uncovered0"><a name="line1293"></a>1293       end
</span><span class="inferred1"><a name="line1294"></a>1294 
</span><span class="marked0"><a name="line1295"></a>1295       row, col, tokens, *options = args
</span><span class="marked1"><a name="line1296"></a>1296       error   = 0
</span><span class="marked0"><a name="line1297"></a>1297       unless tokens.nil?
</span><span class="marked1"><a name="line1298"></a>1298          tokens.each do |token|
</span><span class="inferred0"><a name="line1299"></a>1299             # Check for nested arrays
</span><span class="marked1"><a name="line1300"></a>1300             if token.kind_of?(Array)
</span><span class="uncovered0"><a name="line1301"></a>1301                ret = write_col(row, col, token, options)
</span><span class="inferred1"><a name="line1302"></a>1302             else
</span><span class="marked0"><a name="line1303"></a>1303                ret = write(row, col, token, options)
</span><span class="inferred1"><a name="line1304"></a>1304             end
</span><span class="inferred0"><a name="line1305"></a>1305 
</span><span class="inferred1"><a name="line1306"></a>1306             # Return only the first error encountered, if any.
</span><span class="marked0"><a name="line1307"></a>1307             error ||= ret
</span><span class="marked1"><a name="line1308"></a>1308             col = col + 1
</span><span class="inferred0"><a name="line1309"></a>1309          end
</span><span class="inferred1"><a name="line1310"></a>1310       end
</span><span class="marked0"><a name="line1311"></a>1311       return error
</span><span class="inferred1"><a name="line1312"></a>1312    end
</span><span class="inferred0"><a name="line1313"></a>1313 
</span><span class="inferred1"><a name="line1314"></a>1314 
</span><span class="inferred0"><a name="line1315"></a>1315    ###############################################################################
</span><span class="inferred1"><a name="line1316"></a>1316    #
</span><span class="inferred0"><a name="line1317"></a>1317    # write_col($row, $col, $array_ref, $format)
</span><span class="inferred1"><a name="line1318"></a>1318    #
</span><span class="inferred0"><a name="line1319"></a>1319    # Write a column of data starting from ($row, $col). Call write_row() if any of
</span><span class="inferred1"><a name="line1320"></a>1320    # the elements of the array ref are in turn array refs. This allows the writing
</span><span class="inferred0"><a name="line1321"></a>1321    # of 1D or 2D arrays of data in one go.
</span><span class="inferred1"><a name="line1322"></a>1322    #
</span><span class="inferred0"><a name="line1323"></a>1323    # Returns: the first encountered error value or zero for no errors
</span><span class="inferred1"><a name="line1324"></a>1324    #
</span><span class="marked0"><a name="line1325"></a>1325    def write_col(*args)
</span><span class="inferred1"><a name="line1326"></a>1326       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line1327"></a>1327       if args[0] =~ /^\D/
</span><span class="inferred1"><a name="line1328"></a>1328          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line1329"></a>1329       end
</span><span class="inferred1"><a name="line1330"></a>1330 
</span><span class="inferred0"><a name="line1331"></a>1331       # Catch non array refs passed by user.
</span><span class="marked1"><a name="line1332"></a>1332       unless args[2].kind_of?(Array)
</span><span class="uncovered0"><a name="line1333"></a>1333          raise &quot;Not an array ref in call to write_row()&quot;;
</span><span class="uncovered1"><a name="line1334"></a>1334       end
</span><span class="inferred0"><a name="line1335"></a>1335 
</span><span class="marked1"><a name="line1336"></a>1336       row, col, tokens, *options = args
</span><span class="marked0"><a name="line1337"></a>1337       error   = 0
</span><span class="marked1"><a name="line1338"></a>1338       unless tokens.nil?
</span><span class="marked0"><a name="line1339"></a>1339          tokens.each do |token|
</span><span class="inferred1"><a name="line1340"></a>1340             # write() will deal with any nested arrays
</span><span class="marked0"><a name="line1341"></a>1341             ret = write(row, col, token, options)
</span><span class="inferred1"><a name="line1342"></a>1342 
</span><span class="inferred0"><a name="line1343"></a>1343             # Return only the first error encountered, if any.
</span><span class="marked1"><a name="line1344"></a>1344             error ||= ret
</span><span class="marked0"><a name="line1345"></a>1345             col = col + 1
</span><span class="inferred1"><a name="line1346"></a>1346          end
</span><span class="inferred0"><a name="line1347"></a>1347       end
</span><span class="marked1"><a name="line1348"></a>1348       return error
</span><span class="inferred0"><a name="line1349"></a>1349    end
</span><span class="inferred1"><a name="line1350"></a>1350 
</span><span class="inferred0"><a name="line1351"></a>1351 
</span><span class="inferred1"><a name="line1352"></a>1352    ###############################################################################
</span><span class="inferred0"><a name="line1353"></a>1353    #
</span><span class="inferred1"><a name="line1354"></a>1354    # write_comment($row, $col, $comment)
</span><span class="inferred0"><a name="line1355"></a>1355    #
</span><span class="inferred1"><a name="line1356"></a>1356    # Write a comment to the specified row and column (zero indexed).
</span><span class="inferred0"><a name="line1357"></a>1357    #
</span><span class="inferred1"><a name="line1358"></a>1358    # Returns  0 : normal termination
</span><span class="inferred0"><a name="line1359"></a>1359    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line1360"></a>1360    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line1361"></a>1361    #
</span><span class="marked1"><a name="line1362"></a>1362    def write_comment(*args)
</span><span class="inferred0"><a name="line1363"></a>1363       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line1364"></a>1364       if args[0] =~ /^\D/
</span><span class="inferred0"><a name="line1365"></a>1365          args = substitute_cellref(*args)
</span><span class="inferred1"><a name="line1366"></a>1366       end
</span><span class="inferred0"><a name="line1367"></a>1367 
</span><span class="marked1"><a name="line1368"></a>1368       return -1 if args.size &lt; 3   # Check the number of args
</span><span class="inferred0"><a name="line1369"></a>1369 
</span><span class="inferred1"><a name="line1370"></a>1370 
</span><span class="marked0"><a name="line1371"></a>1371       row = args[0]
</span><span class="marked1"><a name="line1372"></a>1372       col = args[1]
</span><span class="inferred0"><a name="line1373"></a>1373 
</span><span class="inferred1"><a name="line1374"></a>1374       # Check for pairs of optional arguments, i.e. an odd number of args.
</span><span class="marked0"><a name="line1375"></a>1375       raise &quot;Uneven number of additional arguments&quot; if args.size % 2 == 0
</span><span class="inferred1"><a name="line1376"></a>1376 
</span><span class="inferred0"><a name="line1377"></a>1377       # Check that row and col are valid and store max and min values
</span><span class="marked1"><a name="line1378"></a>1378       return -2 if check_dimensions(row, col) != 0
</span><span class="inferred0"><a name="line1379"></a>1379 
</span><span class="inferred1"><a name="line1380"></a>1380       # We have to avoid duplicate comments in cells or else Excel will complain.
</span><span class="marked0"><a name="line1381"></a>1381       @comments[row] = { col =&gt; comment_params(*args) }
</span><span class="inferred1"><a name="line1382"></a>1382    end
</span><span class="inferred0"><a name="line1383"></a>1383 
</span><span class="inferred1"><a name="line1384"></a>1384    ###############################################################################
</span><span class="inferred0"><a name="line1385"></a>1385    #
</span><span class="inferred1"><a name="line1386"></a>1386    # _xf_record_index()
</span><span class="inferred0"><a name="line1387"></a>1387    #
</span><span class="inferred1"><a name="line1388"></a>1388    # Returns an index to the XF record in the workbook.
</span><span class="inferred0"><a name="line1389"></a>1389    #
</span><span class="inferred1"><a name="line1390"></a>1390    # Note: this is a function, not a method.
</span><span class="inferred0"><a name="line1391"></a>1391    #
</span><span class="marked1"><a name="line1392"></a>1392    def xf_record_index(row, col, xf=nil)
</span><span class="marked0"><a name="line1393"></a>1393       if xf.kind_of?(Format)
</span><span class="marked1"><a name="line1394"></a>1394          return xf.xf_index
</span><span class="marked0"><a name="line1395"></a>1395       elsif @row_formats.has_key?(row) 
</span><span class="marked1"><a name="line1396"></a>1396          return @row_formats[row].xf_index
</span><span class="marked0"><a name="line1397"></a>1397       elsif @col_formats.has_key?(col)
</span><span class="marked1"><a name="line1398"></a>1398          return @col_formats[col].xf_index
</span><span class="inferred0"><a name="line1399"></a>1399       else
</span><span class="marked1"><a name="line1400"></a>1400          return 0x0F
</span><span class="inferred0"><a name="line1401"></a>1401       end
</span><span class="marked1"><a name="line1402"></a>1402    end
</span><span class="inferred0"><a name="line1403"></a>1403    
</span><span class="inferred1"><a name="line1404"></a>1404    ###############################################################################
</span><span class="inferred0"><a name="line1405"></a>1405    #
</span><span class="inferred1"><a name="line1406"></a>1406    # _substitute_cellref()
</span><span class="inferred0"><a name="line1407"></a>1407    #
</span><span class="inferred1"><a name="line1408"></a>1408    # Substitute an Excel cell reference in A1 notation for  zero based row and
</span><span class="inferred0"><a name="line1409"></a>1409    # column values in an argument list.
</span><span class="inferred1"><a name="line1410"></a>1410    #
</span><span class="inferred0"><a name="line1411"></a>1411    # Ex: (&quot;A4&quot;, &quot;Hello&quot;) is converted to (3, 0, &quot;Hello&quot;).
</span><span class="inferred1"><a name="line1412"></a>1412    #
</span><span class="marked0"><a name="line1413"></a>1413    def substitute_cellref(cell, *args)
</span><span class="marked1"><a name="line1414"></a>1414       cell.upcase!
</span><span class="inferred0"><a name="line1415"></a>1415 
</span><span class="inferred1"><a name="line1416"></a>1416       # Convert a column range: 'A:A' or 'B:G'.
</span><span class="inferred0"><a name="line1417"></a>1417       # A range such as A:A is equivalent to A1:65536, so add rows as required
</span><span class="marked1"><a name="line1418"></a>1418       if cell =~ /\$?([A-I]?[A-Z]):\$?([A-I]?[A-Z])/
</span><span class="marked0"><a name="line1419"></a>1419          row1, col1 =  cell_to_rowcol($1 +'1')
</span><span class="marked1"><a name="line1420"></a>1420          row2, col2 =  cell_to_rowcol($2 +'65536')
</span><span class="marked0"><a name="line1421"></a>1421          return [row1, col1, row2, col2, *args]
</span><span class="inferred1"><a name="line1422"></a>1422       end
</span><span class="inferred0"><a name="line1423"></a>1423 
</span><span class="inferred1"><a name="line1424"></a>1424       # Convert a cell range: 'A1:B7'
</span><span class="marked0"><a name="line1425"></a>1425       if cell =~ /\$?([A-I]?[A-Z]\$?\d+):\$?([A-I]?[A-Z]\$?\d+)/
</span><span class="marked1"><a name="line1426"></a>1426          row1, col1 =  cell_to_rowcol($1)
</span><span class="marked0"><a name="line1427"></a>1427          row2, col2 =  cell_to_rowcol($2)
</span><span class="marked1"><a name="line1428"></a>1428          return [row1, col1, row2, col2, *args]
</span><span class="inferred0"><a name="line1429"></a>1429       end
</span><span class="inferred1"><a name="line1430"></a>1430 
</span><span class="inferred0"><a name="line1431"></a>1431       # Convert a cell reference: 'A1' or 'AD2000'
</span><span class="marked1"><a name="line1432"></a>1432       if (cell =~ /\$?([A-I]?[A-Z]\$?\d+)/)
</span><span class="marked0"><a name="line1433"></a>1433          row1, col1 =  cell_to_rowcol($1)
</span><span class="marked1"><a name="line1434"></a>1434          return [row1, col1, *args]
</span><span class="inferred0"><a name="line1435"></a>1435 
</span><span class="inferred1"><a name="line1436"></a>1436       end
</span><span class="uncovered0"><a name="line1437"></a>1437 
</span><span class="uncovered1"><a name="line1438"></a>1438       raise(&quot;Unknown cell reference #{cell}&quot;)
</span><span class="uncovered0"><a name="line1439"></a>1439    end
</span><span class="inferred1"><a name="line1440"></a>1440 
</span><span class="inferred0"><a name="line1441"></a>1441    ###############################################################################
</span><span class="inferred1"><a name="line1442"></a>1442    #
</span><span class="inferred0"><a name="line1443"></a>1443    # _cell_to_rowcol($cell_ref)
</span><span class="inferred1"><a name="line1444"></a>1444    #
</span><span class="inferred0"><a name="line1445"></a>1445    # Convert an Excel cell reference in A1 notation to a zero based row and column
</span><span class="inferred1"><a name="line1446"></a>1446    # reference; converts C1 to (0, 2).
</span><span class="inferred0"><a name="line1447"></a>1447    #
</span><span class="inferred1"><a name="line1448"></a>1448    # Returns: row, column
</span><span class="inferred0"><a name="line1449"></a>1449    #
</span><span class="marked1"><a name="line1450"></a>1450    def cell_to_rowcol(cell)
</span><span class="marked0"><a name="line1451"></a>1451       cell =~ /\$?([A-I]?[A-Z])\$?(\d+)/
</span><span class="marked1"><a name="line1452"></a>1452       col     = $1
</span><span class="marked0"><a name="line1453"></a>1453       row     = $2.to_i
</span><span class="inferred1"><a name="line1454"></a>1454 
</span><span class="inferred0"><a name="line1455"></a>1455       # Convert base26 column string to number
</span><span class="inferred1"><a name="line1456"></a>1456       # All your Base are belong to us.
</span><span class="marked0"><a name="line1457"></a>1457       chars = col.split(//)
</span><span class="marked1"><a name="line1458"></a>1458       expn  = 0
</span><span class="marked0"><a name="line1459"></a>1459       col   = 0
</span><span class="inferred1"><a name="line1460"></a>1460 
</span><span class="marked0"><a name="line1461"></a>1461       while (!chars.empty?)
</span><span class="marked1"><a name="line1462"></a>1462          char = chars.pop   # LS char first
</span><span class="marked0"><a name="line1463"></a>1463          col = col + (char[0] - 65 +1) * (26**expn)
</span><span class="inferred1"><a name="line1464"></a>1464              #####  ord(char) - ord('A')  in perl  ####
</span><span class="marked0"><a name="line1465"></a>1465          expn = expn + 1
</span><span class="inferred1"><a name="line1466"></a>1466       end
</span><span class="inferred0"><a name="line1467"></a>1467 
</span><span class="inferred1"><a name="line1468"></a>1468       # Convert 1-index to zero-index
</span><span class="marked0"><a name="line1469"></a>1469       row -= 1
</span><span class="marked1"><a name="line1470"></a>1470       col -= 1
</span><span class="inferred0"><a name="line1471"></a>1471 
</span><span class="marked1"><a name="line1472"></a>1472       return [row, col]
</span><span class="inferred0"><a name="line1473"></a>1473    end
</span><span class="inferred1"><a name="line1474"></a>1474 
</span><span class="inferred0"><a name="line1475"></a>1475    ###############################################################################
</span><span class="inferred1"><a name="line1476"></a>1476    #
</span><span class="inferred0"><a name="line1477"></a>1477    # write_number($row, $col, $num, $format)
</span><span class="inferred1"><a name="line1478"></a>1478    #
</span><span class="inferred0"><a name="line1479"></a>1479    # Write a double to the specified row and column (zero indexed).
</span><span class="inferred1"><a name="line1480"></a>1480    # An integer can be written as a double. Excel will display an
</span><span class="inferred0"><a name="line1481"></a>1481    # integer. $format is optional.
</span><span class="inferred1"><a name="line1482"></a>1482    #
</span><span class="inferred0"><a name="line1483"></a>1483    # Returns  0 : normal termination
</span><span class="inferred1"><a name="line1484"></a>1484    #         -1 : insufficient number of arguments
</span><span class="inferred0"><a name="line1485"></a>1485    #         -2 : row or column out of range
</span><span class="inferred1"><a name="line1486"></a>1486    #
</span><span class="marked0"><a name="line1487"></a>1487    def write_number(*args)
</span><span class="inferred1"><a name="line1488"></a>1488       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line1489"></a>1489       if args[0] =~ /^\D/
</span><span class="inferred1"><a name="line1490"></a>1490          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line1491"></a>1491       end
</span><span class="inferred1"><a name="line1492"></a>1492 
</span><span class="marked0"><a name="line1493"></a>1493       return -1 if (args.size &lt; 3)                # Check the number of args
</span><span class="inferred1"><a name="line1494"></a>1494 
</span><span class="marked0"><a name="line1495"></a>1495        record  = 0x0203                        # Record identifier
</span><span class="marked1"><a name="line1496"></a>1496        length  = 0x000E                        # Number of bytes to follow
</span><span class="inferred0"><a name="line1497"></a>1497    
</span><span class="marked1"><a name="line1498"></a>1498        row     = args[0]                         # Zero indexed row
</span><span class="marked0"><a name="line1499"></a>1499        col     = args[1]                         # Zero indexed column
</span><span class="marked1"><a name="line1500"></a>1500        num     = args[2]
</span><span class="marked0"><a name="line1501"></a>1501        xf      = xf_record_index(row, col, args[3]) # The cell format
</span><span class="inferred1"><a name="line1502"></a>1502    
</span><span class="inferred0"><a name="line1503"></a>1503        # Check that row and col are valid and store max and min values
</span><span class="marked1"><a name="line1504"></a>1504        return -2 if check_dimensions(row, col) != 0
</span><span class="inferred0"><a name="line1505"></a>1505    
</span><span class="marked1"><a name="line1506"></a>1506        header = [record, length].pack('vv')
</span><span class="marked0"><a name="line1507"></a>1507        data   = [row, col, xf].pack('vvv')
</span><span class="marked1"><a name="line1508"></a>1508        xl_double = [num].pack(&quot;d&quot;)
</span><span class="inferred0"><a name="line1509"></a>1509    
</span><span class="marked1"><a name="line1510"></a>1510        xl_double.reverse! if @byte_order != 0
</span><span class="inferred0"><a name="line1511"></a>1511    
</span><span class="inferred1"><a name="line1512"></a>1512        # Store the data or write immediately depending on the compatibility mode.
</span><span class="marked0"><a name="line1513"></a>1513        if @compatibility != 0
</span><span class="uncovered1"><a name="line1514"></a>1514           tmp = []
</span><span class="uncovered0"><a name="line1515"></a>1515           tmp[col] = header + data + xl_double
</span><span class="uncovered1"><a name="line1516"></a>1516           @table[row] = tmp
</span><span class="inferred0"><a name="line1517"></a>1517        else
</span><span class="marked1"><a name="line1518"></a>1518            append(header, data, xl_double)
</span><span class="inferred0"><a name="line1519"></a>1519        end
</span><span class="inferred1"><a name="line1520"></a>1520    
</span><span class="marked0"><a name="line1521"></a>1521        return 0
</span><span class="inferred1"><a name="line1522"></a>1522    end
</span><span class="inferred0"><a name="line1523"></a>1523 
</span><span class="inferred1"><a name="line1524"></a>1524    ###############################################################################
</span><span class="inferred0"><a name="line1525"></a>1525    #
</span><span class="inferred1"><a name="line1526"></a>1526    # write_string ($row, $col, $string, $format)
</span><span class="inferred0"><a name="line1527"></a>1527    #
</span><span class="inferred1"><a name="line1528"></a>1528    # Write a string to the specified row and column (zero indexed).
</span><span class="inferred0"><a name="line1529"></a>1529    # NOTE: there is an Excel 5 defined limit of 255 characters.
</span><span class="inferred1"><a name="line1530"></a>1530    # $format is optional.
</span><span class="inferred0"><a name="line1531"></a>1531    # Returns  0 : normal termination
</span><span class="inferred1"><a name="line1532"></a>1532    #         -1 : insufficient number of arguments
</span><span class="inferred0"><a name="line1533"></a>1533    #         -2 : row or column out of range
</span><span class="inferred1"><a name="line1534"></a>1534    #         -3 : long string truncated to 255 chars
</span><span class="inferred0"><a name="line1535"></a>1535    #
</span><span class="marked1"><a name="line1536"></a>1536    def write_string(*args)
</span><span class="inferred0"><a name="line1537"></a>1537       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line1538"></a>1538       if args[0] =~ /^\D/
</span><span class="inferred0"><a name="line1539"></a>1539          args = substitute_cellref(*args)
</span><span class="inferred1"><a name="line1540"></a>1540       end
</span><span class="inferred0"><a name="line1541"></a>1541 
</span><span class="marked1"><a name="line1542"></a>1542       return -1 if (args.size &lt; 3)                # Check the number of args
</span><span class="inferred0"><a name="line1543"></a>1543 
</span><span class="marked1"><a name="line1544"></a>1544       record      = 0x00FD                        # Record identifier
</span><span class="marked0"><a name="line1545"></a>1545       length      = 0x000A                        # Bytes to follow
</span><span class="inferred1"><a name="line1546"></a>1546 
</span><span class="marked0"><a name="line1547"></a>1547       row         = args[0]                       # Zero indexed row
</span><span class="marked1"><a name="line1548"></a>1548       col         = args[1]                       # Zero indexed column
</span><span class="marked0"><a name="line1549"></a>1549       str         = args[2].to_s
</span><span class="marked1"><a name="line1550"></a>1550       strlen      = str.length
</span><span class="marked0"><a name="line1551"></a>1551       xf          = xf_record_index(row, col, args[3])   # The cell format
</span><span class="marked1"><a name="line1552"></a>1552       encoding    = 0x0
</span><span class="marked0"><a name="line1553"></a>1553       str_error   = 0
</span><span class="inferred1"><a name="line1554"></a>1554 
</span><span class="inferred0"><a name="line1555"></a>1555       # Check that row and col are valid and store max and min values
</span><span class="marked1"><a name="line1556"></a>1556       return -2 if check_dimensions(row, col) != 0
</span><span class="inferred0"><a name="line1557"></a>1557 
</span><span class="inferred1"><a name="line1558"></a>1558       # Limit the string to the max number of chars.
</span><span class="marked0"><a name="line1559"></a>1559       if (strlen &gt; 32767)
</span><span class="uncovered1"><a name="line1560"></a>1560          str       = substr(str, 0, 32767)
</span><span class="uncovered0"><a name="line1561"></a>1561          str_error = -3
</span><span class="uncovered1"><a name="line1562"></a>1562       end
</span><span class="inferred0"><a name="line1563"></a>1563 
</span><span class="inferred1"><a name="line1564"></a>1564       # Prepend the string with the type.
</span><span class="marked0"><a name="line1565"></a>1565       str_header  = [str.length, encoding].pack('vC')
</span><span class="marked1"><a name="line1566"></a>1566       str         = str_header + str
</span><span class="inferred0"><a name="line1567"></a>1567 
</span><span class="marked1"><a name="line1568"></a>1568       if @str_table[str].nil?
</span><span class="marked0"><a name="line1569"></a>1569          @str_table[str] = @str_unique
</span><span class="marked1"><a name="line1570"></a>1570          @str_unique += 1
</span><span class="inferred0"><a name="line1571"></a>1571       end
</span><span class="inferred1"><a name="line1572"></a>1572 
</span><span class="marked0"><a name="line1573"></a>1573       @str_total += 1
</span><span class="inferred1"><a name="line1574"></a>1574 
</span><span class="marked0"><a name="line1575"></a>1575       header = [record, length].pack('vv')
</span><span class="marked1"><a name="line1576"></a>1576       data   = [row, col, xf, @str_table[str]].pack('vvvV')
</span><span class="inferred0"><a name="line1577"></a>1577 
</span><span class="inferred1"><a name="line1578"></a>1578       # Store the data or write immediately depending on the compatibility mode.
</span><span class="marked0"><a name="line1579"></a>1579       if @compatibility != 0
</span><span class="marked1"><a name="line1580"></a>1580          tmp = []
</span><span class="marked0"><a name="line1581"></a>1581          tmp[col] = header + data
</span><span class="marked1"><a name="line1582"></a>1582          @table[row] = tmp
</span><span class="inferred0"><a name="line1583"></a>1583       else
</span><span class="marked1"><a name="line1584"></a>1584          append(header, data)
</span><span class="inferred0"><a name="line1585"></a>1585       end
</span><span class="inferred1"><a name="line1586"></a>1586 
</span><span class="marked0"><a name="line1587"></a>1587       return str_error
</span><span class="inferred1"><a name="line1588"></a>1588    end
</span><span class="inferred0"><a name="line1589"></a>1589 
</span><span class="inferred1"><a name="line1590"></a>1590    ###############################################################################
</span><span class="inferred0"><a name="line1591"></a>1591    #
</span><span class="inferred1"><a name="line1592"></a>1592    # write_blank($row, $col, $format)
</span><span class="inferred0"><a name="line1593"></a>1593    #
</span><span class="inferred1"><a name="line1594"></a>1594    # Write a blank cell to the specified row and column (zero indexed).
</span><span class="inferred0"><a name="line1595"></a>1595    # A blank cell is used to specify formatting without adding a string
</span><span class="inferred1"><a name="line1596"></a>1596    # or a number.
</span><span class="inferred0"><a name="line1597"></a>1597    #
</span><span class="inferred1"><a name="line1598"></a>1598    # A blank cell without a format serves no purpose. Therefore, we don't write
</span><span class="inferred0"><a name="line1599"></a>1599    # a BLANK record unless a format is specified. This is mainly an optimisation
</span><span class="inferred1"><a name="line1600"></a>1600    # for the write_row() and write_col() methods.
</span><span class="inferred0"><a name="line1601"></a>1601    #
</span><span class="inferred1"><a name="line1602"></a>1602    # Returns  0 : normal termination (including no format)
</span><span class="inferred0"><a name="line1603"></a>1603    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line1604"></a>1604    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line1605"></a>1605    #
</span><span class="marked1"><a name="line1606"></a>1606    def write_blank(*args)
</span><span class="inferred0"><a name="line1607"></a>1607       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line1608"></a>1608       if args[0] =~ /^\D/
</span><span class="inferred0"><a name="line1609"></a>1609          args = substitute_cellref(*args)
</span><span class="inferred1"><a name="line1610"></a>1610       end
</span><span class="inferred0"><a name="line1611"></a>1611 
</span><span class="inferred1"><a name="line1612"></a>1612       # Check the number of args
</span><span class="marked0"><a name="line1613"></a>1613       return -1 if args.size &lt; 2
</span><span class="inferred1"><a name="line1614"></a>1614 
</span><span class="inferred0"><a name="line1615"></a>1615       # Don't write a blank cell unless it has a format
</span><span class="marked1"><a name="line1616"></a>1616       return 0 if args[2].nil?
</span><span class="inferred0"><a name="line1617"></a>1617 
</span><span class="marked1"><a name="line1618"></a>1618       record  = 0x0201                        # Record identifier
</span><span class="marked0"><a name="line1619"></a>1619       length  = 0x0006                        # Number of bytes to follow
</span><span class="inferred1"><a name="line1620"></a>1620 
</span><span class="marked0"><a name="line1621"></a>1621       row     = args[0]                       # Zero indexed row
</span><span class="marked1"><a name="line1622"></a>1622       col     = args[1]                       # Zero indexed column
</span><span class="marked0"><a name="line1623"></a>1623       xf      = xf_record_index(row, col, args[2])   # The cell format
</span><span class="inferred1"><a name="line1624"></a>1624 
</span><span class="inferred0"><a name="line1625"></a>1625       # Check that row and col are valid and store max and min values
</span><span class="marked1"><a name="line1626"></a>1626       return -2 if check_dimensions(row, col) != 0
</span><span class="inferred0"><a name="line1627"></a>1627 
</span><span class="marked1"><a name="line1628"></a>1628       header    = [record, length].pack('vv')
</span><span class="marked0"><a name="line1629"></a>1629       data      = [row, col, xf].pack('vvv')
</span><span class="inferred1"><a name="line1630"></a>1630        
</span><span class="inferred0"><a name="line1631"></a>1631       # Store the data or write immediately depending    on the compatibility mode.
</span><span class="marked1"><a name="line1632"></a>1632       if @compatibility != 0
</span><span class="uncovered0"><a name="line1633"></a>1633          tmp = []
</span><span class="uncovered1"><a name="line1634"></a>1634          tmp[col] = header + data
</span><span class="uncovered0"><a name="line1635"></a>1635          @table[row] = tmp
</span><span class="inferred1"><a name="line1636"></a>1636       else
</span><span class="marked0"><a name="line1637"></a>1637          append(header, data)
</span><span class="inferred1"><a name="line1638"></a>1638       end
</span><span class="inferred0"><a name="line1639"></a>1639 
</span><span class="marked1"><a name="line1640"></a>1640       return 0
</span><span class="inferred0"><a name="line1641"></a>1641    end
</span><span class="inferred1"><a name="line1642"></a>1642 
</span><span class="inferred0"><a name="line1643"></a>1643    ###############################################################################
</span><span class="inferred1"><a name="line1644"></a>1644    #
</span><span class="inferred0"><a name="line1645"></a>1645    # write_formula($row, $col, $formula, $format, $value)
</span><span class="inferred1"><a name="line1646"></a>1646    #
</span><span class="inferred0"><a name="line1647"></a>1647    # Write a formula to the specified row and column (zero indexed).
</span><span class="inferred1"><a name="line1648"></a>1648    # The textual representation of the formula is passed to the parser in
</span><span class="inferred0"><a name="line1649"></a>1649    # Formula.pm which returns a packed binary string.
</span><span class="inferred1"><a name="line1650"></a>1650    #
</span><span class="inferred0"><a name="line1651"></a>1651    # $format is optional.
</span><span class="inferred1"><a name="line1652"></a>1652    #
</span><span class="inferred0"><a name="line1653"></a>1653    # $value is an optional result of the formula that can be supplied by the user.
</span><span class="inferred1"><a name="line1654"></a>1654    #
</span><span class="inferred0"><a name="line1655"></a>1655    # Returns  0 : normal termination
</span><span class="inferred1"><a name="line1656"></a>1656    #         -1 : insufficient number of arguments
</span><span class="inferred0"><a name="line1657"></a>1657    #         -2 : row or column out of range
</span><span class="inferred1"><a name="line1658"></a>1658    #
</span><span class="marked0"><a name="line1659"></a>1659    def write_formula(*args)
</span><span class="inferred1"><a name="line1660"></a>1660        # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line1661"></a>1661        if (args[0] =~ /^\D/)
</span><span class="uncovered1"><a name="line1662"></a>1662            args = substitute_cellref(args)
</span><span class="uncovered0"><a name="line1663"></a>1663        end
</span><span class="inferred1"><a name="line1664"></a>1664    
</span><span class="marked0"><a name="line1665"></a>1665        return -1 if args.size &lt; 3   # Check the number of args
</span><span class="inferred1"><a name="line1666"></a>1666    
</span><span class="marked0"><a name="line1667"></a>1667        record    = 0x0006     # Record identifier
</span><span class="inferred1"><a name="line1668"></a>1668        # length               # Bytes to follow
</span><span class="inferred0"><a name="line1669"></a>1669    
</span><span class="marked1"><a name="line1670"></a>1670        row       = args[0]      # Zero indexed row
</span><span class="marked0"><a name="line1671"></a>1671        col       = args[1]      # Zero indexed column
</span><span class="marked1"><a name="line1672"></a>1672        formula   = args[2]      # The formula text string
</span><span class="marked0"><a name="line1673"></a>1673        value     = args[4]      # The formula text string
</span><span class="inferred1"><a name="line1674"></a>1674    
</span><span class="inferred0"><a name="line1675"></a>1675    
</span><span class="marked1"><a name="line1676"></a>1676        xf        = xf_record_index(row, col, args[3])  # The cell format
</span><span class="marked0"><a name="line1677"></a>1677        chn       = 0x0000                         # Must be zero
</span><span class="marked1"><a name="line1678"></a>1678        is_string = 0                              # Formula evaluates to str
</span><span class="inferred0"><a name="line1679"></a>1679        # num                                      # Current value of formula
</span><span class="inferred1"><a name="line1680"></a>1680        # grbi                                     # Option flags
</span><span class="inferred0"><a name="line1681"></a>1681 
</span><span class="inferred1"><a name="line1682"></a>1682        # Excel normally stores the last calculated value of the formula in $num.
</span><span class="inferred0"><a name="line1683"></a>1683        # Clearly we are not in a position to calculate this &quot;a priori&quot;. Instead
</span><span class="inferred1"><a name="line1684"></a>1684        # we set $num to zero and set the option flags in $grbit to ensure
</span><span class="inferred0"><a name="line1685"></a>1685        # automatic calculation of the formula when the file is opened.
</span><span class="inferred1"><a name="line1686"></a>1686        # As a workaround for some non-Excel apps we also allow the user to
</span><span class="inferred0"><a name="line1687"></a>1687        # specify the result of the formula.
</span><span class="inferred1"><a name="line1688"></a>1688        #
</span><span class="marked0"><a name="line1689"></a>1689        num, grbit, is_string = encode_formula_result(value)
</span><span class="inferred1"><a name="line1690"></a>1690 
</span><span class="inferred0"><a name="line1691"></a>1691        # Check that row and col are valid and store max and min values
</span><span class="marked1"><a name="line1692"></a>1692        return -2 if check_dimensions(row, col) != 0
</span><span class="inferred0"><a name="line1693"></a>1693    
</span><span class="inferred1"><a name="line1694"></a>1694        # Strip the = sign at the beginning of the formula string
</span><span class="marked0"><a name="line1695"></a>1695        formula.sub!(/^=/, '')
</span><span class="inferred1"><a name="line1696"></a>1696    
</span><span class="marked0"><a name="line1697"></a>1697        tmp     = formula
</span><span class="inferred1"><a name="line1698"></a>1698    
</span><span class="inferred0"><a name="line1699"></a>1699        # Parse the formula using the parser in Formula.pm
</span><span class="inferred1"><a name="line1700"></a>1700        # nakamura add:  to get byte_stream, set second arg TRUE
</span><span class="inferred0"><a name="line1701"></a>1701        # because ruby doesn't have Perl's &quot;wantarray&quot;
</span><span class="marked1"><a name="line1702"></a>1702        formula = @parser.parse_formula(formula, true)
</span><span class="inferred0"><a name="line1703"></a>1703    
</span><span class="inferred1"><a name="line1704"></a>1704 #       if ($@) {
</span><span class="inferred0"><a name="line1705"></a>1705 #           $@ =~ s/\n$//  # Strip the \n used in the Formula.pm die()
</span><span class="inferred1"><a name="line1706"></a>1706 #           croak $@       # Re-raise the error
</span><span class="inferred0"><a name="line1707"></a>1707 #       }
</span><span class="inferred1"><a name="line1708"></a>1708 
</span><span class="marked0"><a name="line1709"></a>1709        formlen = formula.length     # Length of the binary string
</span><span class="marked1"><a name="line1710"></a>1710        length  = 0x16 + formlen     # Length of the record data
</span><span class="inferred0"><a name="line1711"></a>1711 
</span><span class="marked1"><a name="line1712"></a>1712        header  = [record, length].pack(&quot;vv&quot;)
</span><span class="marked0"><a name="line1713"></a>1713        data    = [row, col, xf].pack(&quot;vvv&quot;) +
</span><span class="inferred1"><a name="line1714"></a>1714                   num +
</span><span class="inferred0"><a name="line1715"></a>1715                  [grbit, chn, formlen].pack('vVv')
</span><span class="inferred1"><a name="line1716"></a>1716    
</span><span class="inferred0"><a name="line1717"></a>1717        # The STRING record if the formula evaluates to a string.
</span><span class="marked1"><a name="line1718"></a>1718        string  = ''
</span><span class="marked0"><a name="line1719"></a>1719        string  = get_formula_string(value) if is_string != 0
</span><span class="inferred1"><a name="line1720"></a>1720 
</span><span class="inferred0"><a name="line1721"></a>1721        # Store the data or write immediately depending on the compatibility mode.
</span><span class="marked1"><a name="line1722"></a>1722        if @compatibility != 0
</span><span class="uncovered0"><a name="line1723"></a>1723          tmp = []
</span><span class="uncovered1"><a name="line1724"></a>1724          tmp[col] = header + data + formula + string
</span><span class="uncovered0"><a name="line1725"></a>1725          @table[row] = tmp
</span><span class="inferred1"><a name="line1726"></a>1726        else
</span><span class="marked0"><a name="line1727"></a>1727            append(header, data, formula, string)
</span><span class="inferred1"><a name="line1728"></a>1728        end
</span><span class="inferred0"><a name="line1729"></a>1729    
</span><span class="marked1"><a name="line1730"></a>1730        return 0
</span><span class="inferred0"><a name="line1731"></a>1731    end
</span><span class="inferred1"><a name="line1732"></a>1732 
</span><span class="inferred0"><a name="line1733"></a>1733    ###############################################################################
</span><span class="inferred1"><a name="line1734"></a>1734    #
</span><span class="inferred0"><a name="line1735"></a>1735    # _encode_formula_result()
</span><span class="inferred1"><a name="line1736"></a>1736    #     my $value     = $_[0];      # Result to be encoded.
</span><span class="inferred0"><a name="line1737"></a>1737    #
</span><span class="inferred1"><a name="line1738"></a>1738    # Encode the user supplied result for a formula.
</span><span class="inferred0"><a name="line1739"></a>1739    #
</span><span class="marked1"><a name="line1740"></a>1740    def encode_formula_result(value = nil)
</span><span class="marked0"><a name="line1741"></a>1741        is_string = 0;          # Formula evaluates to str.
</span><span class="inferred1"><a name="line1742"></a>1742        # my $num;                    # Current value of formula.
</span><span class="inferred0"><a name="line1743"></a>1743        # my $grbit;                  # Option flags.
</span><span class="inferred1"><a name="line1744"></a>1744    
</span><span class="marked0"><a name="line1745"></a>1745        unless value
</span><span class="marked1"><a name="line1746"></a>1746            grbit  = 0x03
</span><span class="marked0"><a name="line1747"></a>1747            num    = [0].pack(&quot;d&quot;)
</span><span class="uncovered1"><a name="line1748"></a>1748        else
</span><span class="uncovered0"><a name="line1749"></a>1749            # The user specified the result of the formula. We turn off the recalc
</span><span class="uncovered1"><a name="line1750"></a>1750            # flag and check the result type.
</span><span class="uncovered0"><a name="line1751"></a>1751            grbit  = 0x00
</span><span class="uncovered1"><a name="line1752"></a>1752    
</span><span class="uncovered0"><a name="line1753"></a>1753            if value =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/
</span><span class="uncovered1"><a name="line1754"></a>1754                # Value is a number.
</span><span class="uncovered0"><a name="line1755"></a>1755                num = [value].pack(&quot;d&quot;)
</span><span class="uncovered1"><a name="line1756"></a>1756            else
</span><span class="uncovered0"><a name="line1757"></a>1757                bools = {
</span><span class="uncovered1"><a name="line1758"></a>1758                                'TRUE'    =&gt; [1,  1],
</span><span class="uncovered0"><a name="line1759"></a>1759                                'FALSE'   =&gt; [1,  0],
</span><span class="uncovered1"><a name="line1760"></a>1760                                '#NULL!'  =&gt; [2,  0],
</span><span class="uncovered0"><a name="line1761"></a>1761                                '#DIV/0!' =&gt; [2,  7],
</span><span class="uncovered1"><a name="line1762"></a>1762                                '#VALUE!' =&gt; [2, 15],
</span><span class="uncovered0"><a name="line1763"></a>1763                                '#REF!'   =&gt; [2, 23],
</span><span class="uncovered1"><a name="line1764"></a>1764                                '#NAME?'  =&gt; [2, 29],
</span><span class="uncovered0"><a name="line1765"></a>1765                                '#NUM!'   =&gt; [2, 36],
</span><span class="uncovered1"><a name="line1766"></a>1766                                '#N/A'    =&gt; [2, 42]
</span><span class="uncovered0"><a name="line1767"></a>1767                        }
</span><span class="uncovered1"><a name="line1768"></a>1768    
</span><span class="uncovered0"><a name="line1769"></a>1769                if bools[value]
</span><span class="uncovered1"><a name="line1770"></a>1770                    # Value is a boolean.
</span><span class="uncovered0"><a name="line1771"></a>1771                    num = [bools[value][0], bools[value][1], 0, 0xFFFF].pack(&quot;vvvv&quot;)
</span><span class="uncovered1"><a name="line1772"></a>1772                else
</span><span class="uncovered0"><a name="line1773"></a>1773                    # Value is a string.
</span><span class="uncovered1"><a name="line1774"></a>1774                    num = [0, 0, 0, 0xFFFF].pack(&quot;vvvv&quot;)
</span><span class="uncovered0"><a name="line1775"></a>1775                    is_string = 1
</span><span class="uncovered1"><a name="line1776"></a>1776                end
</span><span class="uncovered0"><a name="line1777"></a>1777            end
</span><span class="uncovered1"><a name="line1778"></a>1778        end
</span><span class="inferred0"><a name="line1779"></a>1779    
</span><span class="marked1"><a name="line1780"></a>1780        return [num, grbit, is_string]
</span><span class="inferred0"><a name="line1781"></a>1781    end
</span><span class="inferred1"><a name="line1782"></a>1782 
</span><span class="inferred0"><a name="line1783"></a>1783    ###############################################################################
</span><span class="inferred1"><a name="line1784"></a>1784    #
</span><span class="inferred0"><a name="line1785"></a>1785    # store_formula($formula)
</span><span class="inferred1"><a name="line1786"></a>1786    #       my $formula = $_[0];      # The formula text string
</span><span class="inferred0"><a name="line1787"></a>1787    #
</span><span class="inferred1"><a name="line1788"></a>1788    # Pre-parse a formula. This is used in conjunction with repeat_formula()
</span><span class="inferred0"><a name="line1789"></a>1789    # to repetitively rewrite a formula without re-parsing it.
</span><span class="inferred1"><a name="line1790"></a>1790    #
</span><span class="marked0"><a name="line1791"></a>1791    def store_formula(formula)
</span><span class="inferred1"><a name="line1792"></a>1792        # Strip the = sign at the beginning of the formula string
</span><span class="marked0"><a name="line1793"></a>1793        formula.sub!(/^=/, '')
</span><span class="inferred1"><a name="line1794"></a>1794 
</span><span class="inferred0"><a name="line1795"></a>1795        # In order to raise formula errors from the point of view of the calling
</span><span class="inferred1"><a name="line1796"></a>1796        # program we use an eval block and re-raise the error from here.
</span><span class="inferred0"><a name="line1797"></a>1797        #
</span><span class="marked1"><a name="line1798"></a>1798        tokens = @parser.parse_formula(formula)
</span><span class="inferred0"><a name="line1799"></a>1799    
</span><span class="inferred1"><a name="line1800"></a>1800 #       if ($@) {
</span><span class="inferred0"><a name="line1801"></a>1801 #           $@ =~ s/\n$//  # Strip the \n used in the Formula.pm die()
</span><span class="inferred1"><a name="line1802"></a>1802 #           croak $@       # Re-raise the error
</span><span class="inferred0"><a name="line1803"></a>1803 #       }
</span><span class="inferred1"><a name="line1804"></a>1804 
</span><span class="inferred0"><a name="line1805"></a>1805        # Return the parsed tokens in an anonymous array
</span><span class="marked1"><a name="line1806"></a>1806        return [*tokens]
</span><span class="inferred0"><a name="line1807"></a>1807    end
</span><span class="inferred1"><a name="line1808"></a>1808 
</span><span class="inferred0"><a name="line1809"></a>1809    ###############################################################################
</span><span class="inferred1"><a name="line1810"></a>1810    #
</span><span class="inferred0"><a name="line1811"></a>1811    # repeat_formula($row, $col, $formula, $format, ($pattern =&gt; $replacement,...))
</span><span class="inferred1"><a name="line1812"></a>1812    #
</span><span class="inferred0"><a name="line1813"></a>1813    # Write a formula to the specified row and column (zero indexed) by
</span><span class="inferred1"><a name="line1814"></a>1814    # substituting $pattern $replacement pairs in the $formula created via
</span><span class="inferred0"><a name="line1815"></a>1815    # store_formula(). This allows the user to repetitively rewrite a formula
</span><span class="inferred1"><a name="line1816"></a>1816    # without the significant overhead of parsing.
</span><span class="inferred0"><a name="line1817"></a>1817    #
</span><span class="inferred1"><a name="line1818"></a>1818    # Returns  0 : normal termination
</span><span class="inferred0"><a name="line1819"></a>1819    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line1820"></a>1820    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line1821"></a>1821    #
</span><span class="marked1"><a name="line1822"></a>1822    def repeat_formula(*args)
</span><span class="inferred0"><a name="line1823"></a>1823        # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line1824"></a>1824        if args[0] =~ /^\D/
</span><span class="inferred0"><a name="line1825"></a>1825            args = substitute_cellref(args)
</span><span class="inferred1"><a name="line1826"></a>1826        end
</span><span class="inferred0"><a name="line1827"></a>1827    
</span><span class="marked1"><a name="line1828"></a>1828        return -1 if (args.size &lt; 2)   # Check the number of args
</span><span class="inferred0"><a name="line1829"></a>1829    
</span><span class="marked1"><a name="line1830"></a>1830        record      = 0x0006   # Record identifier
</span><span class="inferred0"><a name="line1831"></a>1831        # length                 # Bytes to follow
</span><span class="inferred1"><a name="line1832"></a>1832    
</span><span class="marked0"><a name="line1833"></a>1833        row         = args.shift    # Zero indexed row
</span><span class="marked1"><a name="line1834"></a>1834        col         = args.shift    # Zero indexed column
</span><span class="marked0"><a name="line1835"></a>1835        formula_ref = args.shift    # Array ref with formula tokens
</span><span class="marked1"><a name="line1836"></a>1836        format      = args.shift    # XF format
</span><span class="marked0"><a name="line1837"></a>1837        pairs       = args          # Pattern/replacement pairs
</span><span class="inferred1"><a name="line1838"></a>1838 
</span><span class="inferred0"><a name="line1839"></a>1839        # Enforce an even number of arguments in the pattern/replacement list
</span><span class="marked1"><a name="line1840"></a>1840        raise &quot;Odd number of elements in pattern/replacement list&quot; if pairs.size % 2 != 0
</span><span class="inferred0"><a name="line1841"></a>1841    
</span><span class="inferred1"><a name="line1842"></a>1842        # Check that formula is an array ref
</span><span class="marked0"><a name="line1843"></a>1843        raise &quot;Not a valid formula&quot; unless formula_ref.kind_of?(Array)
</span><span class="inferred1"><a name="line1844"></a>1844 
</span><span class="marked0"><a name="line1845"></a>1845        tokens  = formula_ref.dup
</span><span class="inferred1"><a name="line1846"></a>1846    
</span><span class="inferred0"><a name="line1847"></a>1847        # Ensure that there are tokens to substitute
</span><span class="marked1"><a name="line1848"></a>1848        raise &quot;No tokens in formula&quot; if tokens.empty?
</span><span class="inferred0"><a name="line1849"></a>1849    
</span><span class="inferred1"><a name="line1850"></a>1850    
</span><span class="inferred0"><a name="line1851"></a>1851        # As a temporary and undocumented measure we allow the user to specify the
</span><span class="inferred1"><a name="line1852"></a>1852        # result of the formula by appending a result =&gt; $value pair to the end
</span><span class="inferred0"><a name="line1853"></a>1853        # of the arguments.
</span><span class="marked1"><a name="line1854"></a>1854        value = nil
</span><span class="marked0"><a name="line1855"></a>1855        if pairs[-2] == 'result'
</span><span class="uncovered1"><a name="line1856"></a>1856            value = pairs.pop
</span><span class="uncovered0"><a name="line1857"></a>1857                    pairs.pop
</span><span class="uncovered1"><a name="line1858"></a>1858        end
</span><span class="inferred0"><a name="line1859"></a>1859 
</span><span class="marked1"><a name="line1860"></a>1860        while (!pairs.empty?)
</span><span class="marked0"><a name="line1861"></a>1861            pattern = pairs.shift
</span><span class="marked1"><a name="line1862"></a>1862            replace = pairs.shift
</span><span class="inferred0"><a name="line1863"></a>1863    
</span><span class="marked1"><a name="line1864"></a>1864            tokens.each do |token|
</span><span class="marked0"><a name="line1865"></a>1865                break if token.sub!(/pattern/, replace)   
</span><span class="inferred1"><a name="line1866"></a>1866            end
</span><span class="inferred0"><a name="line1867"></a>1867        end
</span><span class="inferred1"><a name="line1868"></a>1868 
</span><span class="inferred0"><a name="line1869"></a>1869        # Change the parameters in the formula cached by the Formula.pm object
</span><span class="marked1"><a name="line1870"></a>1870        formula   = @parser.parse_tokens(tokens)
</span><span class="inferred0"><a name="line1871"></a>1871    
</span><span class="marked1"><a name="line1872"></a>1872        raise &quot;Unrecognised token in formula&quot; unless formula
</span><span class="inferred0"><a name="line1873"></a>1873 
</span><span class="marked1"><a name="line1874"></a>1874        xf        = xf_record_index(row, col, format) # The cell format
</span><span class="marked0"><a name="line1875"></a>1875        chn       = 0x0000                          # Must be zero
</span><span class="marked1"><a name="line1876"></a>1876        is_string = 0                               # Formula evaluates to str
</span><span class="inferred0"><a name="line1877"></a>1877        #  num                                      # Current value of formula
</span><span class="inferred1"><a name="line1878"></a>1878        #  grbit                                    # Option flags
</span><span class="inferred0"><a name="line1879"></a>1879    
</span><span class="inferred1"><a name="line1880"></a>1880        # Excel normally stores the last calculated value of the formula in $num.
</span><span class="inferred0"><a name="line1881"></a>1881        # Clearly we are not in a position to calculate this &quot;a priori&quot;. Instead
</span><span class="inferred1"><a name="line1882"></a>1882        # we set $num to zero and set the option flags in $grbit to ensure
</span><span class="inferred0"><a name="line1883"></a>1883        # automatic calculation of the formula when the file is opened.
</span><span class="inferred1"><a name="line1884"></a>1884        # As a workaround for some non-Excel apps we also allow the user to
</span><span class="inferred0"><a name="line1885"></a>1885        # specify the result of the formula.
</span><span class="inferred1"><a name="line1886"></a>1886        #
</span><span class="marked0"><a name="line1887"></a>1887        num, grbit, is_string = encode_formula_result(value)
</span><span class="inferred1"><a name="line1888"></a>1888    
</span><span class="inferred0"><a name="line1889"></a>1889        # Check that row and col are valid and store max and min values
</span><span class="marked1"><a name="line1890"></a>1890        return -2 if check_dimensions(row, col) != 0
</span><span class="inferred0"><a name="line1891"></a>1891    
</span><span class="inferred1"><a name="line1892"></a>1892    
</span><span class="marked0"><a name="line1893"></a>1893        formlen   = formula.length     # Length of the binary string
</span><span class="marked1"><a name="line1894"></a>1894        length    = 0x16 + formlen     # Length of the record data
</span><span class="inferred0"><a name="line1895"></a>1895    
</span><span class="marked1"><a name="line1896"></a>1896        header    = [record, length].pack(&quot;vv&quot;)
</span><span class="marked0"><a name="line1897"></a>1897        data      = [row, col, xf].pack(&quot;vvv&quot;) +
</span><span class="inferred1"><a name="line1898"></a>1898                    num                        +
</span><span class="inferred0"><a name="line1899"></a>1899                    [grbit, chn, formlen].pack('vVv')
</span><span class="inferred1"><a name="line1900"></a>1900 
</span><span class="inferred0"><a name="line1901"></a>1901        # The STRING record if the formula evaluates to a string.
</span><span class="marked1"><a name="line1902"></a>1902        string  = ''
</span><span class="marked0"><a name="line1903"></a>1903        string  = encode_formula_result(value) if is_string != 0
</span><span class="inferred1"><a name="line1904"></a>1904    
</span><span class="inferred0"><a name="line1905"></a>1905    
</span><span class="inferred1"><a name="line1906"></a>1906        # Store the data or write immediately depending on the compatibility mode.
</span><span class="marked0"><a name="line1907"></a>1907        if @compatibility != 0
</span><span class="uncovered1"><a name="line1908"></a>1908            string = ''
</span><span class="uncovered0"><a name="line1909"></a>1909            string = get_formula_string(value) if is_string != 0
</span><span class="uncovered1"><a name="line1910"></a>1910           tmp = []
</span><span class="uncovered0"><a name="line1911"></a>1911           tmp[col] = header + data + formula + string
</span><span class="uncovered1"><a name="line1912"></a>1912           @table[row] = tmp
</span><span class="inferred0"><a name="line1913"></a>1913        else
</span><span class="marked1"><a name="line1914"></a>1914            append(header, data, formula, string)
</span><span class="inferred0"><a name="line1915"></a>1915        end
</span><span class="inferred1"><a name="line1916"></a>1916    
</span><span class="marked0"><a name="line1917"></a>1917        return 0
</span><span class="inferred1"><a name="line1918"></a>1918    end
</span><span class="inferred0"><a name="line1919"></a>1919 
</span><span class="inferred1"><a name="line1920"></a>1920    ###############################################################################
</span><span class="inferred0"><a name="line1921"></a>1921    #
</span><span class="inferred1"><a name="line1922"></a>1922    # write_url($row, $col, $url, $string, $format)
</span><span class="inferred0"><a name="line1923"></a>1923    #
</span><span class="inferred1"><a name="line1924"></a>1924    # Write a hyperlink. This is comprised of two elements: the visible label and
</span><span class="inferred0"><a name="line1925"></a>1925    # the invisible link. The visible label is the same as the link unless an
</span><span class="inferred1"><a name="line1926"></a>1926    # alternative string is specified.
</span><span class="inferred0"><a name="line1927"></a>1927    #
</span><span class="inferred1"><a name="line1928"></a>1928    # The parameters $string and $format are optional and their order is
</span><span class="inferred0"><a name="line1929"></a>1929    # interchangeable for backward compatibility reasons.
</span><span class="inferred1"><a name="line1930"></a>1930    #
</span><span class="inferred0"><a name="line1931"></a>1931    # The hyperlink can be to a http, ftp, mail, internal sheet, or external
</span><span class="inferred1"><a name="line1932"></a>1932    # directory url.
</span><span class="inferred0"><a name="line1933"></a>1933    #
</span><span class="inferred1"><a name="line1934"></a>1934    # Returns  0 : normal termination
</span><span class="inferred0"><a name="line1935"></a>1935    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line1936"></a>1936    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line1937"></a>1937    #         -3 : long string truncated to 255 chars
</span><span class="inferred1"><a name="line1938"></a>1938    #
</span><span class="marked0"><a name="line1939"></a>1939    def write_url(*args)
</span><span class="inferred1"><a name="line1940"></a>1940       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line1941"></a>1941       if args[0] =~ /^\D/
</span><span class="inferred1"><a name="line1942"></a>1942          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line1943"></a>1943       end
</span><span class="inferred1"><a name="line1944"></a>1944 
</span><span class="inferred0"><a name="line1945"></a>1945       # Check the number of args
</span><span class="marked1"><a name="line1946"></a>1946       return -1 if args.size &lt; 3
</span><span class="inferred0"><a name="line1947"></a>1947 
</span><span class="inferred1"><a name="line1948"></a>1948       # Add start row and col to arg list
</span><span class="marked0"><a name="line1949"></a>1949       return write_url_range(args[0], args[1], *args)
</span><span class="inferred1"><a name="line1950"></a>1950    end
</span><span class="inferred0"><a name="line1951"></a>1951 
</span><span class="inferred1"><a name="line1952"></a>1952    ###############################################################################
</span><span class="inferred0"><a name="line1953"></a>1953    #
</span><span class="inferred1"><a name="line1954"></a>1954    # write_url_range($row1, $col1, $row2, $col2, $url, $string, $format)
</span><span class="inferred0"><a name="line1955"></a>1955    #
</span><span class="inferred1"><a name="line1956"></a>1956    # This is the more general form of write_url(). It allows a hyperlink to be
</span><span class="inferred0"><a name="line1957"></a>1957    # written to a range of cells. This function also decides the type of hyperlink
</span><span class="inferred1"><a name="line1958"></a>1958    # to be written. These are either, Web (http, ftp, mailto), Internal
</span><span class="inferred0"><a name="line1959"></a>1959    # (Sheet1!A1) or external ('c:\temp\foo.xls#Sheet1!A1').
</span><span class="inferred1"><a name="line1960"></a>1960    #
</span><span class="inferred0"><a name="line1961"></a>1961    # See also write_url() above for a general description and return values.
</span><span class="inferred1"><a name="line1962"></a>1962    #
</span><span class="marked0"><a name="line1963"></a>1963    def write_url_range(*args)
</span><span class="inferred1"><a name="line1964"></a>1964       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line1965"></a>1965       if args[0] =~ /^\D/
</span><span class="inferred1"><a name="line1966"></a>1966          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line1967"></a>1967       end
</span><span class="inferred1"><a name="line1968"></a>1968 
</span><span class="inferred0"><a name="line1969"></a>1969       # Check the number of args
</span><span class="marked1"><a name="line1970"></a>1970       return -1 if args.size &lt; 5
</span><span class="inferred0"><a name="line1971"></a>1971 
</span><span class="inferred1"><a name="line1972"></a>1972       # Reverse the order of $string and $format if necessary. We work on a copy
</span><span class="inferred0"><a name="line1973"></a>1973       # in order to protect the callers args. We don't use &quot;local @_&quot; in case of
</span><span class="inferred1"><a name="line1974"></a>1974       # perl50005 threads.
</span><span class="inferred0"><a name="line1975"></a>1975       #
</span><span class="marked1"><a name="line1976"></a>1976       args[5], args[6] = [ args[6], args[5] ]
</span><span class="inferred0"><a name="line1977"></a>1977       
</span><span class="marked1"><a name="line1978"></a>1978       url = args[4]
</span><span class="inferred0"><a name="line1979"></a>1979 
</span><span class="inferred1"><a name="line1980"></a>1980       # Check for internal/external sheet links or default to web link
</span><span class="marked0"><a name="line1981"></a>1981       return write_url_internal(*args) if url =~ /^internal:/
</span><span class="marked1"><a name="line1982"></a>1982       return write_url_external(*args) if url =~ /^external:/
</span><span class="marked0"><a name="line1983"></a>1983       return write_url_web(*args)
</span><span class="inferred1"><a name="line1984"></a>1984    end
</span><span class="inferred0"><a name="line1985"></a>1985 
</span><span class="inferred1"><a name="line1986"></a>1986    ###############################################################################
</span><span class="inferred0"><a name="line1987"></a>1987    #
</span><span class="inferred1"><a name="line1988"></a>1988    # _write_url_web($row1, $col1, $row2, $col2, $url, $string, $format)
</span><span class="inferred0"><a name="line1989"></a>1989    #    row1        = $_[0];                        # Start row
</span><span class="inferred1"><a name="line1990"></a>1990    #    col1        = $_[1];                        # Start column
</span><span class="inferred0"><a name="line1991"></a>1991    #    row2        = $_[2];                        # End row
</span><span class="inferred1"><a name="line1992"></a>1992    #    col2        = $_[3];                        # End column
</span><span class="inferred0"><a name="line1993"></a>1993    #    url         = $_[4];                        # URL string
</span><span class="inferred1"><a name="line1994"></a>1994    #    str         = $_[5];                        # Alternative label
</span><span class="inferred0"><a name="line1995"></a>1995    #
</span><span class="inferred1"><a name="line1996"></a>1996    # Used to write http, ftp and mailto hyperlinks.
</span><span class="inferred0"><a name="line1997"></a>1997    # The link type ($options) is 0x03 is the same as absolute dir ref without
</span><span class="inferred1"><a name="line1998"></a>1998    # sheet. However it is differentiated by the $unknown2 data stream.
</span><span class="inferred0"><a name="line1999"></a>1999    #
</span><span class="inferred1"><a name="line2000"></a>2000    # See also write_url() above for a general description and return values.
</span><span class="inferred0"><a name="line2001"></a>2001    #
</span><span class="marked1"><a name="line2002"></a>2002    def write_url_web(row1, col1, row2, col2, url, str = nil, format = nil)
</span><span class="marked0"><a name="line2003"></a>2003       record = 0x01B8                       # Record identifier
</span><span class="marked1"><a name="line2004"></a>2004       length = 0x00000                      # Bytes to follow
</span><span class="inferred0"><a name="line2005"></a>2005 
</span><span class="marked1"><a name="line2006"></a>2006       xf     = format || @url_format        # The cell format
</span><span class="inferred0"><a name="line2007"></a>2007 
</span><span class="inferred1"><a name="line2008"></a>2008       # Write the visible label but protect against url recursion in write().
</span><span class="marked0"><a name="line2009"></a>2009       str          = url if str.nil?
</span><span class="marked1"><a name="line2010"></a>2010       @writing_url = 1
</span><span class="marked0"><a name="line2011"></a>2011       error        = write(row1, col1, str, xf)
</span><span class="marked1"><a name="line2012"></a>2012       @writing_url = 0
</span><span class="marked0"><a name="line2013"></a>2013       return error if error == -2
</span><span class="inferred1"><a name="line2014"></a>2014 
</span><span class="inferred0"><a name="line2015"></a>2015       # Pack the undocumented parts of the hyperlink stream
</span><span class="marked1"><a name="line2016"></a>2016       unknown1    = [&quot;D0C9EA79F9BACE118C8200AA004BA90B02000000&quot;].pack(&quot;H*&quot;)
</span><span class="marked0"><a name="line2017"></a>2017       unknown2    = [&quot;E0C9EA79F9BACE118C8200AA004BA90B&quot;].pack(&quot;H*&quot;)
</span><span class="inferred1"><a name="line2018"></a>2018 
</span><span class="inferred0"><a name="line2019"></a>2019       # Pack the option flags
</span><span class="marked1"><a name="line2020"></a>2020       options     = [0x03].pack(&quot;V&quot;)
</span><span class="inferred0"><a name="line2021"></a>2021 
</span><span class="inferred1"><a name="line2022"></a>2022       # Convert URL to a null terminated wchar string
</span><span class="marked0"><a name="line2023"></a>2023       url         = url.split('').join(&quot;\0&quot;)
</span><span class="marked1"><a name="line2024"></a>2024       url         = url + &quot;\0\0\0&quot;
</span><span class="inferred0"><a name="line2025"></a>2025 
</span><span class="inferred1"><a name="line2026"></a>2026       # Pack the length of the URL
</span><span class="marked0"><a name="line2027"></a>2027       url_len     = [url.length].pack(&quot;V&quot;)
</span><span class="inferred1"><a name="line2028"></a>2028 
</span><span class="inferred0"><a name="line2029"></a>2029       # Calculate the data length
</span><span class="marked1"><a name="line2030"></a>2030       length         = 0x34 + url.length
</span><span class="inferred0"><a name="line2031"></a>2031 
</span><span class="inferred1"><a name="line2032"></a>2032       # Pack the header data
</span><span class="marked0"><a name="line2033"></a>2033       header      = [record, length].pack(&quot;vv&quot;)
</span><span class="marked1"><a name="line2034"></a>2034       data        = [row1, row2, col1, col2].pack(&quot;vvvv&quot;)
</span><span class="inferred0"><a name="line2035"></a>2035 
</span><span class="inferred1"><a name="line2036"></a>2036       # Write the packed data
</span><span class="marked0"><a name="line2037"></a>2037       append( header, data,unknown1,options,unknown2,url_len,url)
</span><span class="inferred1"><a name="line2038"></a>2038 
</span><span class="marked0"><a name="line2039"></a>2039       return error
</span><span class="inferred1"><a name="line2040"></a>2040    end
</span><span class="inferred0"><a name="line2041"></a>2041 
</span><span class="inferred1"><a name="line2042"></a>2042 
</span><span class="inferred0"><a name="line2043"></a>2043    ###############################################################################
</span><span class="inferred1"><a name="line2044"></a>2044    #
</span><span class="inferred0"><a name="line2045"></a>2045    # _write_url_internal($row1, $col1, $row2, $col2, $url, $string, $format)
</span><span class="inferred1"><a name="line2046"></a>2046    #    row1        = $_[0];                        # Start row
</span><span class="inferred0"><a name="line2047"></a>2047    #    col1        = $_[1];                        # Start column
</span><span class="inferred1"><a name="line2048"></a>2048    #    row2        = $_[2];                        # End row
</span><span class="inferred0"><a name="line2049"></a>2049    #    col2        = $_[3];                        # End column
</span><span class="inferred1"><a name="line2050"></a>2050    #    url         = $_[4];                        # URL string
</span><span class="inferred0"><a name="line2051"></a>2051    #    str         = $_[5];                        # Alternative label
</span><span class="inferred1"><a name="line2052"></a>2052    #
</span><span class="inferred0"><a name="line2053"></a>2053    # Used to write internal reference hyperlinks such as &quot;Sheet1!A1&quot;.
</span><span class="inferred1"><a name="line2054"></a>2054    #
</span><span class="inferred0"><a name="line2055"></a>2055    # See also write_url() above for a general description and return values.
</span><span class="inferred1"><a name="line2056"></a>2056    #
</span><span class="marked0"><a name="line2057"></a>2057    def write_url_internal(row1, col1, row2, col2, url, str = nil, format = nil)
</span><span class="uncovered1"><a name="line2058"></a>2058       record = 0x01B8                       # Record identifier
</span><span class="uncovered0"><a name="line2059"></a>2059       length = 0x00000                      # Bytes to follow
</span><span class="uncovered1"><a name="line2060"></a>2060 
</span><span class="uncovered0"><a name="line2061"></a>2061       xf     = format || @url_format        # The cell format
</span><span class="uncovered1"><a name="line2062"></a>2062 
</span><span class="uncovered0"><a name="line2063"></a>2063       # Strip URL type
</span><span class="uncovered1"><a name="line2064"></a>2064       url.sub!(/^internal:/, '')
</span><span class="uncovered0"><a name="line2065"></a>2065 
</span><span class="uncovered1"><a name="line2066"></a>2066       # Write the visible label but protect against url recursion in write().
</span><span class="uncovered0"><a name="line2067"></a>2067       str          = url if str.nil?
</span><span class="uncovered1"><a name="line2068"></a>2068       @writing_url = 1
</span><span class="uncovered0"><a name="line2069"></a>2069       error        = write(row1, col1, str, xf)
</span><span class="uncovered1"><a name="line2070"></a>2070       @writing_url = 0
</span><span class="uncovered0"><a name="line2071"></a>2071       return error if error == -2
</span><span class="uncovered1"><a name="line2072"></a>2072 
</span><span class="uncovered0"><a name="line2073"></a>2073       # Pack the undocumented parts of the hyperlink stream
</span><span class="uncovered1"><a name="line2074"></a>2074       unknown1    = [&quot;D0C9EA79F9BACE118C8200AA004BA90B02000000&quot;].pack(&quot;H*&quot;)
</span><span class="uncovered0"><a name="line2075"></a>2075 
</span><span class="uncovered1"><a name="line2076"></a>2076       # Pack the option flags
</span><span class="uncovered0"><a name="line2077"></a>2077       options     = [0x08].pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2078"></a>2078 
</span><span class="uncovered0"><a name="line2079"></a>2079       # URL encoding.
</span><span class="uncovered1"><a name="line2080"></a>2080       encoding    = 0
</span><span class="uncovered0"><a name="line2081"></a>2081 
</span><span class="uncovered1"><a name="line2082"></a>2082       # Convert an Ascii URL type and to a null terminated wchar string.
</span><span class="uncovered0"><a name="line2083"></a>2083       if encoding == 0
</span><span class="uncovered1"><a name="line2084"></a>2084          url = url + &quot;\0&quot;
</span><span class="uncovered0"><a name="line2085"></a>2085          url = url.unpack('c*').pack('v*')
</span><span class="uncovered1"><a name="line2086"></a>2086       end
</span><span class="uncovered0"><a name="line2087"></a>2087 
</span><span class="uncovered1"><a name="line2088"></a>2088       # Pack the length of the URL as chars (not wchars)
</span><span class="uncovered0"><a name="line2089"></a>2089       url_len     = [(url.length/2).to_i].pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2090"></a>2090 
</span><span class="uncovered0"><a name="line2091"></a>2091       # Calculate the data length
</span><span class="uncovered1"><a name="line2092"></a>2092       length         = 0x24 + url.length
</span><span class="uncovered0"><a name="line2093"></a>2093 
</span><span class="uncovered1"><a name="line2094"></a>2094       # Pack the header data
</span><span class="uncovered0"><a name="line2095"></a>2095       header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2096"></a>2096       data        = [row1, row2, col1, col2].pack(&quot;vvvv&quot;)
</span><span class="uncovered0"><a name="line2097"></a>2097 
</span><span class="uncovered1"><a name="line2098"></a>2098       # Write the packed data
</span><span class="uncovered0"><a name="line2099"></a>2099       append( header, data, unknown1, options, url_len, url)
</span><span class="uncovered1"><a name="line2100"></a>2100 
</span><span class="uncovered0"><a name="line2101"></a>2101       return error
</span><span class="uncovered1"><a name="line2102"></a>2102    end
</span><span class="inferred0"><a name="line2103"></a>2103 
</span><span class="inferred1"><a name="line2104"></a>2104    ###############################################################################
</span><span class="inferred0"><a name="line2105"></a>2105    #
</span><span class="inferred1"><a name="line2106"></a>2106    # _write_url_external($row1, $col1, $row2, $col2, $url, $string, $format)
</span><span class="inferred0"><a name="line2107"></a>2107    #
</span><span class="inferred1"><a name="line2108"></a>2108    # Write links to external directory names such as 'c:\foo.xls',
</span><span class="inferred0"><a name="line2109"></a>2109    # c:\foo.xls#Sheet1!A1', '../../foo.xls'. and '../../foo.xls#Sheet1!A1'.
</span><span class="inferred1"><a name="line2110"></a>2110    #
</span><span class="inferred0"><a name="line2111"></a>2111    # Note: Excel writes some relative links with the $dir_long string. We ignore
</span><span class="inferred1"><a name="line2112"></a>2112    # these cases for the sake of simpler code.
</span><span class="inferred0"><a name="line2113"></a>2113    #
</span><span class="inferred1"><a name="line2114"></a>2114    # See also write_url() above for a general description and return values.
</span><span class="inferred0"><a name="line2115"></a>2115    #
</span><span class="marked1"><a name="line2116"></a>2116    def write_url_external(row1, col1, row2, col2, url, str = nil, format = nil)
</span><span class="uncovered0"><a name="line2117"></a>2117       # Network drives are different. We will handle them separately
</span><span class="uncovered1"><a name="line2118"></a>2118       # MS/Novell network drives and shares start with \\
</span><span class="uncovered0"><a name="line2119"></a>2119       if url =~ /^external:\\\\/
</span><span class="uncovered1"><a name="line2120"></a>2120          return write_url_external_net(row1, col1, row2, col2, url, str, format)
</span><span class="uncovered0"><a name="line2121"></a>2121       end
</span><span class="uncovered1"><a name="line2122"></a>2122 
</span><span class="uncovered0"><a name="line2123"></a>2123       record      = 0x01B8                       # Record identifier
</span><span class="uncovered1"><a name="line2124"></a>2124       length      = 0x00000                      # Bytes to follow
</span><span class="uncovered0"><a name="line2125"></a>2125 
</span><span class="uncovered1"><a name="line2126"></a>2126       xf     = format || @url_format        # The cell format
</span><span class="uncovered0"><a name="line2127"></a>2127 
</span><span class="uncovered1"><a name="line2128"></a>2128       # Strip URL type and change Unix dir separator to Dos style (if needed)
</span><span class="uncovered0"><a name="line2129"></a>2129       #
</span><span class="uncovered1"><a name="line2130"></a>2130       url.sub!(/^external:/, '')
</span><span class="uncovered0"><a name="line2131"></a>2131       url.gsub!(%r|/|, '\\')
</span><span class="uncovered1"><a name="line2132"></a>2132 
</span><span class="uncovered0"><a name="line2133"></a>2133 
</span><span class="uncovered1"><a name="line2134"></a>2134       # Write the visible label but protect against url recursion in write().
</span><span class="uncovered0"><a name="line2135"></a>2135       str = url.sub!(/\#/, ' - ') if str.nil?
</span><span class="uncovered1"><a name="line2136"></a>2136       @writing_url = 1
</span><span class="uncovered0"><a name="line2137"></a>2137       error        = write(row1, col1, str, xf)
</span><span class="uncovered1"><a name="line2138"></a>2138       @writing_url = 0
</span><span class="uncovered0"><a name="line2139"></a>2139       return error if error == -2
</span><span class="uncovered1"><a name="line2140"></a>2140 
</span><span class="uncovered0"><a name="line2141"></a>2141       # Determine if the link is relative or absolute:
</span><span class="uncovered1"><a name="line2142"></a>2142       # Absolute if link starts with DOS drive specifier like C:
</span><span class="uncovered0"><a name="line2143"></a>2143       # Otherwise default to 0x00 for relative link.
</span><span class="uncovered1"><a name="line2144"></a>2144       #
</span><span class="uncovered0"><a name="line2145"></a>2145       absolute    = 0x00
</span><span class="uncovered1"><a name="line2146"></a>2146       absolute    = 0x02  if url =~ /^[A-Za-z]:/
</span><span class="uncovered0"><a name="line2147"></a>2147 
</span><span class="uncovered1"><a name="line2148"></a>2148       # Determine if the link contains a sheet reference and change some of the
</span><span class="uncovered0"><a name="line2149"></a>2149       # parameters accordingly.
</span><span class="uncovered1"><a name="line2150"></a>2150       # Split the dir name and sheet name (if it exists)
</span><span class="uncovered0"><a name="line2151"></a>2151       #
</span><span class="uncovered1"><a name="line2152"></a>2152       dir_long , sheet = url.split(/\#/)
</span><span class="uncovered0"><a name="line2153"></a>2153       link_type        = 0x01 | absolute
</span><span class="uncovered1"><a name="line2154"></a>2154 
</span><span class="uncovered0"><a name="line2155"></a>2155       unless sheet.nil?
</span><span class="uncovered1"><a name="line2156"></a>2156          link_type |= 0x08
</span><span class="uncovered0"><a name="line2157"></a>2157          sheet_len  = [sheet.length + 0x01].pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2158"></a>2158          sheet      = sheet.split('').join(&quot;\0&quot;) + &quot;\0\0\0&quot;
</span><span class="uncovered0"><a name="line2159"></a>2159       else
</span><span class="uncovered1"><a name="line2160"></a>2160          sheet_len   = ''
</span><span class="uncovered0"><a name="line2161"></a>2161          sheet       = ''
</span><span class="uncovered1"><a name="line2162"></a>2162       end
</span><span class="uncovered0"><a name="line2163"></a>2163 
</span><span class="uncovered1"><a name="line2164"></a>2164       # Pack the link type
</span><span class="uncovered0"><a name="line2165"></a>2165       link_type      = link_type.pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2166"></a>2166 
</span><span class="uncovered0"><a name="line2167"></a>2167       # Calculate the up-level dir count e.g. (..\..\..\ == 3)
</span><span class="uncovered1"><a name="line2168"></a>2168       up_count    = 0
</span><span class="uncovered0"><a name="line2169"></a>2169       while dir_long.sub!(/^\.\.\\/, '')
</span><span class="uncovered1"><a name="line2170"></a>2170          up_count = up_count + 1
</span><span class="uncovered0"><a name="line2171"></a>2171       end
</span><span class="uncovered1"><a name="line2172"></a>2172       up_count    = [up_count].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line2173"></a>2173 
</span><span class="uncovered1"><a name="line2174"></a>2174       # Store the short dos dir name (null terminated)
</span><span class="uncovered0"><a name="line2175"></a>2175       dir_short   = dir_long + &quot;\0&quot;
</span><span class="uncovered1"><a name="line2176"></a>2176 
</span><span class="uncovered0"><a name="line2177"></a>2177       # Store the long dir name as a wchar string (non-null terminated)
</span><span class="uncovered1"><a name="line2178"></a>2178       dir_long = dir_long.split('').join(&quot;\0&quot;) + &quot;\0&quot;
</span><span class="uncovered0"><a name="line2179"></a>2179 
</span><span class="uncovered1"><a name="line2180"></a>2180       # Pack the lengths of the dir strings
</span><span class="uncovered0"><a name="line2181"></a>2181       dir_short_len = [dir_short.length].pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2182"></a>2182       dir_long_len  = [dir_long.length].pack(&quot;V&quot;)
</span><span class="uncovered0"><a name="line2183"></a>2183       stream_len    = [dir_long.length + 0x06].pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2184"></a>2184 
</span><span class="uncovered0"><a name="line2185"></a>2185       # Pack the undocumented parts of the hyperlink stream
</span><span class="uncovered1"><a name="line2186"></a>2186       unknown1 = ['D0C9EA79F9BACE118C8200AA004BA90B02000000'].pack(&quot;H*&quot;)
</span><span class="uncovered0"><a name="line2187"></a>2187       unknown2 = ['0303000000000000C000000000000046'].pack(&quot;H*&quot;)
</span><span class="uncovered1"><a name="line2188"></a>2188       unknown3 = ['FFFFADDE000000000000000000000000000000000000000'].pack(&quot;H*&quot;)
</span><span class="uncovered0"><a name="line2189"></a>2189       unknown4 = [0x03].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line2190"></a>2190 
</span><span class="uncovered0"><a name="line2191"></a>2191       # Pack the main data stream
</span><span class="uncovered1"><a name="line2192"></a>2192       data        = [row1, row2, col1, col2].pack(&quot;vvvv&quot;) +
</span><span class="uncovered0"><a name="line2193"></a>2193         unknown1     +
</span><span class="uncovered1"><a name="line2194"></a>2194         link_type    +
</span><span class="uncovered0"><a name="line2195"></a>2195         unknown2     +
</span><span class="uncovered1"><a name="line2196"></a>2196         up_count     +
</span><span class="uncovered0"><a name="line2197"></a>2197         dir_short_len+
</span><span class="uncovered1"><a name="line2198"></a>2198         dir_short    +
</span><span class="uncovered0"><a name="line2199"></a>2199         unknown3     +
</span><span class="uncovered1"><a name="line2200"></a>2200         stream_len   +
</span><span class="uncovered0"><a name="line2201"></a>2201         dir_long_len +
</span><span class="uncovered1"><a name="line2202"></a>2202         unknown4     +
</span><span class="uncovered0"><a name="line2203"></a>2203         dir_long     +
</span><span class="uncovered1"><a name="line2204"></a>2204         sheet_len    +
</span><span class="uncovered0"><a name="line2205"></a>2205         sheet
</span><span class="uncovered1"><a name="line2206"></a>2206 
</span><span class="uncovered0"><a name="line2207"></a>2207       # Pack the header data
</span><span class="uncovered1"><a name="line2208"></a>2208       length      = data.length
</span><span class="uncovered0"><a name="line2209"></a>2209       header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2210"></a>2210 
</span><span class="uncovered0"><a name="line2211"></a>2211       # Write the packed data
</span><span class="uncovered1"><a name="line2212"></a>2212       append(header, data)
</span><span class="uncovered0"><a name="line2213"></a>2213 
</span><span class="uncovered1"><a name="line2214"></a>2214       return error
</span><span class="uncovered0"><a name="line2215"></a>2215    end
</span><span class="inferred1"><a name="line2216"></a>2216 
</span><span class="inferred0"><a name="line2217"></a>2217    ###############################################################################
</span><span class="inferred1"><a name="line2218"></a>2218    #
</span><span class="inferred0"><a name="line2219"></a>2219    # _write_url_external_net($row1, $col1, $row2, $col2, $url, $string, $format)
</span><span class="inferred1"><a name="line2220"></a>2220    #
</span><span class="inferred0"><a name="line2221"></a>2221    # Write links to external MS/Novell network drives and shares such as
</span><span class="inferred1"><a name="line2222"></a>2222    # '//NETWORK/share/foo.xls' and '//NETWORK/share/foo.xls#Sheet1!A1'.
</span><span class="inferred0"><a name="line2223"></a>2223    #
</span><span class="inferred1"><a name="line2224"></a>2224    # See also write_url() above for a general description and return values.
</span><span class="inferred0"><a name="line2225"></a>2225    #
</span><span class="marked1"><a name="line2226"></a>2226    def write_url_external_net(row1, col1, row2, col2, url, str, format)
</span><span class="uncovered0"><a name="line2227"></a>2227       record      = 0x01B8                       # Record identifier
</span><span class="uncovered1"><a name="line2228"></a>2228       length      = 0x00000                      # Bytes to follow
</span><span class="uncovered0"><a name="line2229"></a>2229 
</span><span class="uncovered1"><a name="line2230"></a>2230       xf          = format || @url_format  # The cell format
</span><span class="uncovered0"><a name="line2231"></a>2231 
</span><span class="uncovered1"><a name="line2232"></a>2232       # Strip URL type and change Unix dir separator to Dos style (if needed)
</span><span class="uncovered0"><a name="line2233"></a>2233       #
</span><span class="uncovered1"><a name="line2234"></a>2234       url.sub!(/^external:/, '')
</span><span class="uncovered0"><a name="line2235"></a>2235       url.gsub!(%r|/|, '\\')
</span><span class="uncovered1"><a name="line2236"></a>2236 
</span><span class="uncovered0"><a name="line2237"></a>2237       # Write the visible label but protect against url recursion in write().
</span><span class="uncovered1"><a name="line2238"></a>2238       str = url.sub!(/\#/, ' - ') if str.nil?
</span><span class="uncovered0"><a name="line2239"></a>2239       @writing_url = 1
</span><span class="uncovered1"><a name="line2240"></a>2240       error        = write(row1, col1, str, xf)
</span><span class="uncovered0"><a name="line2241"></a>2241       @writing_url = 0
</span><span class="uncovered1"><a name="line2242"></a>2242       return error if error == -2
</span><span class="uncovered0"><a name="line2243"></a>2243 
</span><span class="uncovered1"><a name="line2244"></a>2244       # Determine if the link contains a sheet reference and change some of the
</span><span class="uncovered0"><a name="line2245"></a>2245       # parameters accordingly.
</span><span class="uncovered1"><a name="line2246"></a>2246       # Split the dir name and sheet name (if it exists)
</span><span class="uncovered0"><a name="line2247"></a>2247       #
</span><span class="uncovered1"><a name="line2248"></a>2248       dir_long , sheet = url.split(/\#/)
</span><span class="uncovered0"><a name="line2249"></a>2249       link_type        = 0x0103  # Always absolute
</span><span class="uncovered1"><a name="line2250"></a>2250 
</span><span class="uncovered0"><a name="line2251"></a>2251       unless sheet.nil?
</span><span class="uncovered1"><a name="line2252"></a>2252          link_type |= 0x08
</span><span class="uncovered0"><a name="line2253"></a>2253          sheet_len  = [sheet.length + 0x01].pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2254"></a>2254          sheet      = sheet.split('').join(&quot;\0&quot;) + &quot;\0\0\0&quot;
</span><span class="uncovered0"><a name="line2255"></a>2255       else
</span><span class="uncovered1"><a name="line2256"></a>2256          sheet_len   = ''
</span><span class="uncovered0"><a name="line2257"></a>2257          sheet       = ''
</span><span class="uncovered1"><a name="line2258"></a>2258       end
</span><span class="uncovered0"><a name="line2259"></a>2259 
</span><span class="uncovered1"><a name="line2260"></a>2260       # Pack the link type
</span><span class="uncovered0"><a name="line2261"></a>2261       link_type      = [link_type].pack(&quot;V&quot;)
</span><span class="uncovered1"><a name="line2262"></a>2262 
</span><span class="uncovered0"><a name="line2263"></a>2263 
</span><span class="uncovered1"><a name="line2264"></a>2264       # Make the string null terminated
</span><span class="uncovered0"><a name="line2265"></a>2265       dir_long       = dir_long + &quot;\0&quot;
</span><span class="uncovered1"><a name="line2266"></a>2266 
</span><span class="uncovered0"><a name="line2267"></a>2267       # Pack the lengths of the dir string
</span><span class="uncovered1"><a name="line2268"></a>2268       dir_long_len  = [dir_long.length].pack(&quot;V&quot;)
</span><span class="uncovered0"><a name="line2269"></a>2269 
</span><span class="uncovered1"><a name="line2270"></a>2270       # Store the long dir name as a wchar string (non-null terminated)
</span><span class="uncovered0"><a name="line2271"></a>2271       dir_long = dir_long.split('').join(&quot;\0&quot;) + &quot;\0&quot;
</span><span class="uncovered1"><a name="line2272"></a>2272 
</span><span class="uncovered0"><a name="line2273"></a>2273       # Pack the undocumented part of the hyperlink stream
</span><span class="uncovered1"><a name="line2274"></a>2274       unknown1    = ['D0C9EA79F9BACE118C8200AA004BA90B02000000'].pack(&quot;H*&quot;)
</span><span class="uncovered0"><a name="line2275"></a>2275 
</span><span class="uncovered1"><a name="line2276"></a>2276       # Pack the main data stream
</span><span class="uncovered0"><a name="line2277"></a>2277         data         = [row1, row2, col1, col2].pack(&quot;vvvv&quot;) +
</span><span class="uncovered1"><a name="line2278"></a>2278         unknown1     +
</span><span class="uncovered0"><a name="line2279"></a>2279         link_type    +
</span><span class="uncovered1"><a name="line2280"></a>2280         dir_long_len +
</span><span class="uncovered0"><a name="line2281"></a>2281         dir_long     +
</span><span class="uncovered1"><a name="line2282"></a>2282         sheet_len    +
</span><span class="uncovered0"><a name="line2283"></a>2283         sheet
</span><span class="uncovered1"><a name="line2284"></a>2284 
</span><span class="uncovered0"><a name="line2285"></a>2285       # Pack the header data
</span><span class="uncovered1"><a name="line2286"></a>2286       length      = data.length
</span><span class="uncovered0"><a name="line2287"></a>2287       header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2288"></a>2288 
</span><span class="uncovered0"><a name="line2289"></a>2289       # Write the packed data
</span><span class="uncovered1"><a name="line2290"></a>2290       append(header, data)
</span><span class="uncovered0"><a name="line2291"></a>2291 
</span><span class="uncovered1"><a name="line2292"></a>2292       return error
</span><span class="uncovered0"><a name="line2293"></a>2293    end
</span><span class="inferred1"><a name="line2294"></a>2294 
</span><span class="inferred0"><a name="line2295"></a>2295    ###############################################################################
</span><span class="inferred1"><a name="line2296"></a>2296    #
</span><span class="inferred0"><a name="line2297"></a>2297    # write_date_time ($row, $col, $string, $format)
</span><span class="inferred1"><a name="line2298"></a>2298    #
</span><span class="inferred0"><a name="line2299"></a>2299    # Write a datetime string in ISO8601 &quot;yyyy-mm-ddThh:mm:ss.ss&quot; format as a
</span><span class="inferred1"><a name="line2300"></a>2300    # number representing an Excel date. $format is optional.
</span><span class="inferred0"><a name="line2301"></a>2301    #
</span><span class="inferred1"><a name="line2302"></a>2302    # Returns  0 : normal termination
</span><span class="inferred0"><a name="line2303"></a>2303    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line2304"></a>2304    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line2305"></a>2305    #         -3 : Invalid date_time, written as string
</span><span class="inferred1"><a name="line2306"></a>2306    #
</span><span class="marked0"><a name="line2307"></a>2307    def write_date_time(*args)
</span><span class="uncovered1"><a name="line2308"></a>2308       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered0"><a name="line2309"></a>2309       if args[0] =~ /^\D/
</span><span class="uncovered1"><a name="line2310"></a>2310          args = substitute_cellref(*args)
</span><span class="uncovered0"><a name="line2311"></a>2311       end
</span><span class="uncovered1"><a name="line2312"></a>2312    
</span><span class="uncovered0"><a name="line2313"></a>2313       return -1 if (args.size &lt; 3)                 # Check the number of args
</span><span class="uncovered1"><a name="line2314"></a>2314    
</span><span class="uncovered0"><a name="line2315"></a>2315       row       = args[0]                           # Zero indexed row
</span><span class="uncovered1"><a name="line2316"></a>2316       col       = args[1]                           # Zero indexed column
</span><span class="uncovered0"><a name="line2317"></a>2317       str       = args[2]
</span><span class="uncovered1"><a name="line2318"></a>2318    
</span><span class="uncovered0"><a name="line2319"></a>2319       # Check that row and col are valid and store max and min values
</span><span class="uncovered1"><a name="line2320"></a>2320       return -2 if check_dimensions(row, col) != 0
</span><span class="uncovered0"><a name="line2321"></a>2321    
</span><span class="uncovered1"><a name="line2322"></a>2322       error     = 0
</span><span class="uncovered0"><a name="line2323"></a>2323       date_time = convert_date_time(str)
</span><span class="uncovered1"><a name="line2324"></a>2324    
</span><span class="uncovered0"><a name="line2325"></a>2325       unless date_time.nil?
</span><span class="uncovered1"><a name="line2326"></a>2326          error = write_number(row, col, date_time, args[3])
</span><span class="uncovered0"><a name="line2327"></a>2327       else
</span><span class="uncovered1"><a name="line2328"></a>2328          # The date isn't valid so write it as a string.
</span><span class="uncovered0"><a name="line2329"></a>2329          write_string(row, col, str, args[3])
</span><span class="uncovered1"><a name="line2330"></a>2330          error = -3
</span><span class="uncovered0"><a name="line2331"></a>2331       end
</span><span class="uncovered1"><a name="line2332"></a>2332       return error
</span><span class="uncovered0"><a name="line2333"></a>2333    end
</span><span class="inferred1"><a name="line2334"></a>2334    
</span><span class="inferred0"><a name="line2335"></a>2335    ###############################################################################
</span><span class="inferred1"><a name="line2336"></a>2336    #
</span><span class="inferred0"><a name="line2337"></a>2337    # convert_date_time($date_time_string)
</span><span class="inferred1"><a name="line2338"></a>2338    #
</span><span class="inferred0"><a name="line2339"></a>2339    # The function takes a date and time in ISO8601 &quot;yyyy-mm-ddThh:mm:ss.ss&quot; format
</span><span class="inferred1"><a name="line2340"></a>2340    # and converts it to a decimal number representing a valid Excel date.
</span><span class="inferred0"><a name="line2341"></a>2341    #
</span><span class="inferred1"><a name="line2342"></a>2342    # Dates and times in Excel are represented by real numbers. The integer part of
</span><span class="inferred0"><a name="line2343"></a>2343    # the number stores the number of days since the epoch and the fractional part
</span><span class="inferred1"><a name="line2344"></a>2344    # stores the percentage of the day in seconds. The epoch can be either 1900 or
</span><span class="inferred0"><a name="line2345"></a>2345    # 1904.
</span><span class="inferred1"><a name="line2346"></a>2346    #
</span><span class="inferred0"><a name="line2347"></a>2347    # Parameter: Date and time string in one of the following formats:
</span><span class="inferred1"><a name="line2348"></a>2348    #               yyyy-mm-ddThh:mm:ss.ss  # Standard
</span><span class="inferred0"><a name="line2349"></a>2349    #               yyyy-mm-ddT             # Date only
</span><span class="inferred1"><a name="line2350"></a>2350    #                         Thh:mm:ss.ss  # Time only
</span><span class="inferred0"><a name="line2351"></a>2351    #
</span><span class="inferred1"><a name="line2352"></a>2352    # Returns:
</span><span class="inferred0"><a name="line2353"></a>2353    #            A decimal number representing a valid Excel date, or
</span><span class="inferred1"><a name="line2354"></a>2354    #            undef if the date is invalid.
</span><span class="inferred0"><a name="line2355"></a>2355    #
</span><span class="marked1"><a name="line2356"></a>2356    def convert_date_time(date_time_string)
</span><span class="marked0"><a name="line2357"></a>2357       date_time = date_time_string
</span><span class="inferred1"><a name="line2358"></a>2358    
</span><span class="marked0"><a name="line2359"></a>2359       days      = 0 # Number of days since epoch
</span><span class="marked1"><a name="line2360"></a>2360       seconds   = 0 # Time expressed as fraction of 24h hours in seconds
</span><span class="inferred0"><a name="line2361"></a>2361    
</span><span class="inferred1"><a name="line2362"></a>2362       # Strip leading and trailing whitespace.
</span><span class="marked0"><a name="line2363"></a>2363       date_time.sub!(/^\s+/, '')
</span><span class="marked1"><a name="line2364"></a>2364       date_time.sub!(/\s+$/, '')
</span><span class="inferred0"><a name="line2365"></a>2365    
</span><span class="inferred1"><a name="line2366"></a>2366       # Check for invalid date char.
</span><span class="marked0"><a name="line2367"></a>2367       return nil if date_time =~ /[^0-9T:\-\.Z]/
</span><span class="inferred1"><a name="line2368"></a>2368    
</span><span class="inferred0"><a name="line2369"></a>2369       # Check for &quot;T&quot; after date or before time.
</span><span class="marked1"><a name="line2370"></a>2370       return nil unless date_time =~ /\dT|T\d/
</span><span class="inferred0"><a name="line2371"></a>2371    
</span><span class="inferred1"><a name="line2372"></a>2372       # Strip trailing Z in ISO8601 date.
</span><span class="marked0"><a name="line2373"></a>2373       date_time.sub!(/Z$/, '')
</span><span class="inferred1"><a name="line2374"></a>2374    
</span><span class="inferred0"><a name="line2375"></a>2375       # Split into date and time.
</span><span class="marked1"><a name="line2376"></a>2376       date, time = date_time.split(/T/)
</span><span class="inferred0"><a name="line2377"></a>2377    
</span><span class="inferred1"><a name="line2378"></a>2378       # We allow the time portion of the input DateTime to be optional.
</span><span class="marked0"><a name="line2379"></a>2379       unless time.nil?
</span><span class="inferred1"><a name="line2380"></a>2380          # Match hh:mm:ss.sss+ where the seconds are optional
</span><span class="marked0"><a name="line2381"></a>2381          if time =~ /^(\d\d):(\d\d)(:(\d\d(\.\d+)?))?/
</span><span class="marked1"><a name="line2382"></a>2382             hour   = $1.to_i
</span><span class="marked0"><a name="line2383"></a>2383             min    = $2.to_i
</span><span class="marked1"><a name="line2384"></a>2384             sec    = $4.to_f || 0
</span><span class="uncovered0"><a name="line2385"></a>2385          else
</span><span class="uncovered1"><a name="line2386"></a>2386             return nil # Not a valid time format.
</span><span class="uncovered0"><a name="line2387"></a>2387          end
</span><span class="inferred1"><a name="line2388"></a>2388    
</span><span class="inferred0"><a name="line2389"></a>2389          # Some boundary checks
</span><span class="marked1"><a name="line2390"></a>2390          return nil if hour &gt;= 24
</span><span class="marked0"><a name="line2391"></a>2391          return nil if min  &gt;= 60
</span><span class="marked1"><a name="line2392"></a>2392          return nil if sec  &gt;= 60
</span><span class="inferred0"><a name="line2393"></a>2393    
</span><span class="inferred1"><a name="line2394"></a>2394          # Excel expresses seconds as a fraction of the number in 24 hours.
</span><span class="marked0"><a name="line2395"></a>2395          seconds = (hour * 60* 60 + min * 60 + sec) / (24.0 * 60 * 60)
</span><span class="inferred1"><a name="line2396"></a>2396       end
</span><span class="inferred0"><a name="line2397"></a>2397    
</span><span class="inferred1"><a name="line2398"></a>2398       # We allow the date portion of the input DateTime to be optional.
</span><span class="marked0"><a name="line2399"></a>2399       return seconds if date == ''
</span><span class="inferred1"><a name="line2400"></a>2400    
</span><span class="inferred0"><a name="line2401"></a>2401       # Match date as yyyy-mm-dd.
</span><span class="marked1"><a name="line2402"></a>2402       if date =~ /^(\d\d\d\d)-(\d\d)-(\d\d)$/
</span><span class="marked0"><a name="line2403"></a>2403          year   = $1.to_i
</span><span class="marked1"><a name="line2404"></a>2404          month  = $2.to_i
</span><span class="marked0"><a name="line2405"></a>2405          day    = $3.to_i
</span><span class="uncovered1"><a name="line2406"></a>2406       else
</span><span class="uncovered0"><a name="line2407"></a>2407          return nil  # Not a valid date format.
</span><span class="uncovered1"><a name="line2408"></a>2408       end
</span><span class="inferred0"><a name="line2409"></a>2409    
</span><span class="inferred1"><a name="line2410"></a>2410       # Set the epoch as 1900 or 1904. Defaults to 1900.
</span><span class="inferred0"><a name="line2411"></a>2411       # Special cases for Excel.
</span><span class="marked1"><a name="line2412"></a>2412       if !@date_1904.nil? &amp;&amp; @date_1904 == 0
</span><span class="marked0"><a name="line2413"></a>2413          return      seconds if date == '1899-12-31' # Excel 1900 epoch
</span><span class="marked1"><a name="line2414"></a>2414          return      seconds if date == '1900-01-00' # Excel 1900 epoch
</span><span class="marked0"><a name="line2415"></a>2415          return 60 + seconds if date == '1900-02-29' # Excel false leapday
</span><span class="inferred1"><a name="line2416"></a>2416       end
</span><span class="inferred0"><a name="line2417"></a>2417    
</span><span class="inferred1"><a name="line2418"></a>2418    
</span><span class="inferred0"><a name="line2419"></a>2419       # We calculate the date by calculating the number of days since the epoch
</span><span class="inferred1"><a name="line2420"></a>2420       # and adjust for the number of leap days. We calculate the number of leap
</span><span class="inferred0"><a name="line2421"></a>2421       # days by normalising the year in relation to the epoch. Thus the year 2000
</span><span class="inferred1"><a name="line2422"></a>2422       # becomes 100 for 4 and 100 year leapdays and 400 for 400 year leapdays.
</span><span class="inferred0"><a name="line2423"></a>2423       #
</span><span class="marked1"><a name="line2424"></a>2424       epoch   = !@date_1904.nil? &amp;&amp; @date_1904 != 0 ? 1904 : 1900
</span><span class="marked0"><a name="line2425"></a>2425       offset  = !@date_1904.nil? &amp;&amp; @date_1904 != 0 ?    4 :    0
</span><span class="marked1"><a name="line2426"></a>2426       norm    = 300
</span><span class="marked0"><a name="line2427"></a>2427       range   = year -epoch
</span><span class="inferred1"><a name="line2428"></a>2428    
</span><span class="inferred0"><a name="line2429"></a>2429       # Set month days and check for leap year.
</span><span class="marked1"><a name="line2430"></a>2430       mdays   = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
</span><span class="marked0"><a name="line2431"></a>2431       leap    = 0
</span><span class="marked1"><a name="line2432"></a>2432       leap    = 1  if year % 4 == 0 || year % 100 == 0 || year % 400 == 0
</span><span class="marked0"><a name="line2433"></a>2433       mdays[1]   = 29 if leap != 0
</span><span class="inferred1"><a name="line2434"></a>2434    
</span><span class="inferred0"><a name="line2435"></a>2435       # Some boundary checks
</span><span class="marked1"><a name="line2436"></a>2436       return nil if year  &lt; epoch or year  &gt; 9999
</span><span class="marked0"><a name="line2437"></a>2437       return nil if month &lt; 1     or month &gt; 12
</span><span class="marked1"><a name="line2438"></a>2438       return nil if day   &lt; 1     or day   &gt; mdays[month -1]
</span><span class="inferred0"><a name="line2439"></a>2439    
</span><span class="inferred1"><a name="line2440"></a>2440       # Accumulate the number of days since the epoch.
</span><span class="marked0"><a name="line2441"></a>2441       days = day                               # Add days for current month
</span><span class="marked1"><a name="line2442"></a>2442       (0 .. month-2).each do |m|
</span><span class="marked0"><a name="line2443"></a>2443          days += mdays[m]                      # Add days for past months
</span><span class="inferred1"><a name="line2444"></a>2444       end
</span><span class="marked0"><a name="line2445"></a>2445       days += range *365                       # Add days for past years
</span><span class="marked1"><a name="line2446"></a>2446       days += ((range)                /  4)    # Add leapdays
</span><span class="marked0"><a name="line2447"></a>2447       days -= ((range + offset)       /100)    # Subtract 100 year leapdays
</span><span class="marked1"><a name="line2448"></a>2448       days += ((range + offset + norm)/400)    # Add 400 year leapdays
</span><span class="marked0"><a name="line2449"></a>2449       days -= leap                             # Already counted above
</span><span class="inferred1"><a name="line2450"></a>2450    
</span><span class="inferred0"><a name="line2451"></a>2451       # Adjust for Excel erroneously treating 1900 as a leap year.
</span><span class="marked1"><a name="line2452"></a>2452       days = days + 1 if @date_1904 == 0 and days &gt; 59
</span><span class="inferred0"><a name="line2453"></a>2453    
</span><span class="marked1"><a name="line2454"></a>2454       return days + seconds
</span><span class="inferred0"><a name="line2455"></a>2455    end
</span><span class="inferred1"><a name="line2456"></a>2456 
</span><span class="inferred0"><a name="line2457"></a>2457    ###############################################################################
</span><span class="inferred1"><a name="line2458"></a>2458    #
</span><span class="inferred0"><a name="line2459"></a>2459    # set_row($row, $height, $format, $hidden, $level, collapsed)
</span><span class="inferred1"><a name="line2460"></a>2460    #          row       : Row Number
</span><span class="inferred0"><a name="line2461"></a>2461    #          height    : Format object
</span><span class="inferred1"><a name="line2462"></a>2462    #          format    : Format object
</span><span class="inferred0"><a name="line2463"></a>2463    #          hidden    : Hidden flag
</span><span class="inferred1"><a name="line2464"></a>2464    #          level     : Outline level
</span><span class="inferred0"><a name="line2465"></a>2465    #          collapsed : Collapsed row
</span><span class="inferred1"><a name="line2466"></a>2466    # This method is used to set the height and XF format for a row.
</span><span class="inferred0"><a name="line2467"></a>2467    # Writes the  BIFF record ROW.
</span><span class="inferred1"><a name="line2468"></a>2468    #
</span><span class="marked0"><a name="line2469"></a>2469    def set_row(row, height = nil, format = nil, hidden = 0, level = 0, collapsed = 0)
</span><span class="marked1"><a name="line2470"></a>2470       record      = 0x0208               # Record identifier
</span><span class="marked0"><a name="line2471"></a>2471       length      = 0x0010               # Number of bytes to follow
</span><span class="inferred1"><a name="line2472"></a>2472 
</span><span class="marked0"><a name="line2473"></a>2473       colMic      = 0x0000               # First defined column
</span><span class="marked1"><a name="line2474"></a>2474       colMac      = 0x0000               # Last defined column
</span><span class="inferred0"><a name="line2475"></a>2475       # miyRw;                           # Row height
</span><span class="marked1"><a name="line2476"></a>2476       irwMac      = 0x0000               # Used by Excel to optimise loading
</span><span class="marked0"><a name="line2477"></a>2477       reserved    = 0x0000               # Reserved
</span><span class="marked1"><a name="line2478"></a>2478       grbit       = 0x0000               # Option flags
</span><span class="inferred0"><a name="line2479"></a>2479       # ixfe;                            # XF index
</span><span class="inferred1"><a name="line2480"></a>2480 
</span><span class="marked0"><a name="line2481"></a>2481       return if row.nil?
</span><span class="inferred1"><a name="line2482"></a>2482 
</span><span class="inferred0"><a name="line2483"></a>2483       # Check that row and col are valid and store max and min values
</span><span class="marked1"><a name="line2484"></a>2484       return -2 if check_dimensions(row, 0, 0, 1) != 0
</span><span class="inferred0"><a name="line2485"></a>2485    
</span><span class="inferred1"><a name="line2486"></a>2486       # Check for a format object
</span><span class="marked0"><a name="line2487"></a>2487       if format.kind_of?(Format)
</span><span class="marked1"><a name="line2488"></a>2488          ixfe = format.get_xf_index
</span><span class="inferred0"><a name="line2489"></a>2489       else
</span><span class="marked1"><a name="line2490"></a>2490          ixfe = 0x0F
</span><span class="inferred0"><a name="line2491"></a>2491       end
</span><span class="inferred1"><a name="line2492"></a>2492    
</span><span class="inferred0"><a name="line2493"></a>2493       # Set the row height in units of 1/20 of a point. Note, some heights may
</span><span class="inferred1"><a name="line2494"></a>2494       # not be obtained exactly due to rounding in Excel.
</span><span class="inferred0"><a name="line2495"></a>2495       #
</span><span class="marked1"><a name="line2496"></a>2496       unless height.nil?
</span><span class="marked0"><a name="line2497"></a>2497          miyRw = height *20
</span><span class="inferred1"><a name="line2498"></a>2498       else
</span><span class="marked0"><a name="line2499"></a>2499          miyRw = 0xff # The default row height
</span><span class="marked1"><a name="line2500"></a>2500          height = 0
</span><span class="inferred0"><a name="line2501"></a>2501       end
</span><span class="inferred1"><a name="line2502"></a>2502 
</span><span class="inferred0"><a name="line2503"></a>2503       # Set the limits for the outline levels (0 &lt;= x &lt;= 7).
</span><span class="marked1"><a name="line2504"></a>2504       level = 0 if level &lt; 0
</span><span class="marked0"><a name="line2505"></a>2505       level = 7 if level &gt; 7
</span><span class="inferred1"><a name="line2506"></a>2506    
</span><span class="marked0"><a name="line2507"></a>2507       @outline_row_level = level if level &gt; @outline_row_level
</span><span class="inferred1"><a name="line2508"></a>2508    
</span><span class="inferred0"><a name="line2509"></a>2509       # Set the options flags.
</span><span class="inferred1"><a name="line2510"></a>2510       # 0x10: The fCollapsed flag indicates that the row contains the &quot;+&quot;
</span><span class="inferred0"><a name="line2511"></a>2511       #       when an outline group is collapsed.
</span><span class="inferred1"><a name="line2512"></a>2512       # 0x20: The fDyZero height flag indicates a collapsed or hidden row.
</span><span class="inferred0"><a name="line2513"></a>2513       # 0x40: The fUnsynced flag is used to show that the font and row heights
</span><span class="inferred1"><a name="line2514"></a>2514       #       are not compatible. This is usually the case for WriteExcel.
</span><span class="inferred0"><a name="line2515"></a>2515       # 0x80: The fGhostDirty flag indicates that the row has been formatted.
</span><span class="inferred1"><a name="line2516"></a>2516       #
</span><span class="marked0"><a name="line2517"></a>2517       grbit |= level
</span><span class="marked1"><a name="line2518"></a>2518       grbit |= 0x0010 if collapsed != 0
</span><span class="marked0"><a name="line2519"></a>2519       grbit |= 0x0020 if hidden    != 0
</span><span class="marked1"><a name="line2520"></a>2520       grbit |= 0x0040
</span><span class="marked0"><a name="line2521"></a>2521       grbit |= 0x0080 unless format.nil?
</span><span class="marked1"><a name="line2522"></a>2522       grbit |= 0x0100
</span><span class="inferred0"><a name="line2523"></a>2523    
</span><span class="marked1"><a name="line2524"></a>2524       header = [record, length].pack(&quot;vv&quot;)
</span><span class="marked0"><a name="line2525"></a>2525       data   = [row, colMic, colMac, miyRw, irwMac, reserved, grbit, ixfe].pack(&quot;vvvvvvvv&quot;)
</span><span class="inferred1"><a name="line2526"></a>2526 
</span><span class="inferred0"><a name="line2527"></a>2527       # Store the data or write immediately depending on the compatibility mode.
</span><span class="marked1"><a name="line2528"></a>2528       if @compatibility != 0
</span><span class="uncovered0"><a name="line2529"></a>2529          @row_data[row] = header + data
</span><span class="inferred1"><a name="line2530"></a>2530       else
</span><span class="marked0"><a name="line2531"></a>2531          append(header, data)
</span><span class="inferred1"><a name="line2532"></a>2532       end
</span><span class="inferred0"><a name="line2533"></a>2533 
</span><span class="inferred1"><a name="line2534"></a>2534       # Store the row sizes for use when calculating image vertices.
</span><span class="inferred0"><a name="line2535"></a>2535       # Also store the column formats.
</span><span class="marked1"><a name="line2536"></a>2536       @row_sizes[row]   = height
</span><span class="marked0"><a name="line2537"></a>2537       @row_formats[row] = format unless format.nil?
</span><span class="inferred1"><a name="line2538"></a>2538    end
</span><span class="inferred0"><a name="line2539"></a>2539 
</span><span class="inferred1"><a name="line2540"></a>2540    ###############################################################################
</span><span class="inferred0"><a name="line2541"></a>2541    #
</span><span class="inferred1"><a name="line2542"></a>2542    # _write_row_default()
</span><span class="inferred0"><a name="line2543"></a>2543    #        row    : Row Number
</span><span class="inferred1"><a name="line2544"></a>2544    #        colMic : First defined column
</span><span class="inferred0"><a name="line2545"></a>2545    #        colMac : Last defined column
</span><span class="inferred1"><a name="line2546"></a>2546    #
</span><span class="inferred0"><a name="line2547"></a>2547    # Write a default row record, in compatibility mode, for rows that don't have
</span><span class="inferred1"><a name="line2548"></a>2548    # user specified values..
</span><span class="inferred0"><a name="line2549"></a>2549    #
</span><span class="marked1"><a name="line2550"></a>2550    def _write_row_default(row, colMic, colMac)
</span><span class="uncovered0"><a name="line2551"></a>2551 
</span><span class="uncovered1"><a name="line2552"></a>2552       record      = 0x0208               # Record identifier
</span><span class="uncovered0"><a name="line2553"></a>2553       length      = 0x0010               # Number of bytes to follow
</span><span class="uncovered1"><a name="line2554"></a>2554 
</span><span class="uncovered0"><a name="line2555"></a>2555       miyRw       = 0xFF                 # Row height
</span><span class="uncovered1"><a name="line2556"></a>2556       irwMac      = 0x0000               # Used by Excel to optimise loading
</span><span class="uncovered0"><a name="line2557"></a>2557       reserved    = 0x0000               # Reserved
</span><span class="uncovered1"><a name="line2558"></a>2558       grbit       = 0x0100               # Option flags
</span><span class="uncovered0"><a name="line2559"></a>2559       ixfe        = 0x0F                 # XF index
</span><span class="uncovered1"><a name="line2560"></a>2560 
</span><span class="uncovered0"><a name="line2561"></a>2561       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2562"></a>2562       data   = [row, colMic, colMac, miyRw, irwMac, reserved, grbit, ixfe].pack(&quot;vvvvvvvv&quot;)
</span><span class="uncovered0"><a name="line2563"></a>2563 
</span><span class="uncovered1"><a name="line2564"></a>2564       append(header, data)
</span><span class="uncovered0"><a name="line2565"></a>2565    end
</span><span class="inferred1"><a name="line2566"></a>2566 
</span><span class="inferred0"><a name="line2567"></a>2567    ###############################################################################
</span><span class="inferred1"><a name="line2568"></a>2568    #
</span><span class="inferred0"><a name="line2569"></a>2569    # _check_dimensions($row, $col, $ignore_row, $ignore_col)
</span><span class="inferred1"><a name="line2570"></a>2570    #
</span><span class="inferred0"><a name="line2571"></a>2571    # Check that $row and $col are valid and store max and min values for use in
</span><span class="inferred1"><a name="line2572"></a>2572    # DIMENSIONS record. See, _store_dimensions().
</span><span class="inferred0"><a name="line2573"></a>2573    #
</span><span class="inferred1"><a name="line2574"></a>2574    # The $ignore_row/$ignore_col flags is used to indicate that we wish to
</span><span class="inferred0"><a name="line2575"></a>2575    # perform the dimension check without storing the value.
</span><span class="inferred1"><a name="line2576"></a>2576    #
</span><span class="inferred0"><a name="line2577"></a>2577    # The ignore flags are use by set_row() and data_validate.
</span><span class="inferred1"><a name="line2578"></a>2578    #
</span><span class="marked0"><a name="line2579"></a>2579    def check_dimensions(row, col, ignore_row = 0, ignore_col = 0)
</span><span class="marked1"><a name="line2580"></a>2580       return -2 if row.nil?
</span><span class="marked0"><a name="line2581"></a>2581       return -2 if row &gt;= @xls_rowmax
</span><span class="inferred1"><a name="line2582"></a>2582 
</span><span class="marked0"><a name="line2583"></a>2583       return -2 if col.nil?
</span><span class="marked1"><a name="line2584"></a>2584       return -2 if col &gt;= @xls_colmax
</span><span class="inferred0"><a name="line2585"></a>2585 
</span><span class="marked1"><a name="line2586"></a>2586       if ignore_row == 0
</span><span class="marked0"><a name="line2587"></a>2587          if @dim_rowmin.nil? or row &lt; @dim_rowmin
</span><span class="marked1"><a name="line2588"></a>2588             @dim_rowmin = row
</span><span class="inferred0"><a name="line2589"></a>2589          end
</span><span class="inferred1"><a name="line2590"></a>2590 
</span><span class="marked0"><a name="line2591"></a>2591          if @dim_rowmax.nil? or row &gt; @dim_rowmax
</span><span class="marked1"><a name="line2592"></a>2592             @dim_rowmax = row
</span><span class="inferred0"><a name="line2593"></a>2593          end
</span><span class="inferred1"><a name="line2594"></a>2594       end
</span><span class="inferred0"><a name="line2595"></a>2595 
</span><span class="marked1"><a name="line2596"></a>2596       if ignore_col == 0
</span><span class="marked0"><a name="line2597"></a>2597          if @dim_colmin.nil? or col &lt; @dim_colmin
</span><span class="marked1"><a name="line2598"></a>2598             @dim_colmin = col
</span><span class="inferred0"><a name="line2599"></a>2599          end
</span><span class="inferred1"><a name="line2600"></a>2600 
</span><span class="marked0"><a name="line2601"></a>2601          if @dim_colmax.nil? or col &gt; @dim_colmax
</span><span class="marked1"><a name="line2602"></a>2602             @dim_colmax =col
</span><span class="inferred0"><a name="line2603"></a>2603          end
</span><span class="inferred1"><a name="line2604"></a>2604       end
</span><span class="inferred0"><a name="line2605"></a>2605 
</span><span class="marked1"><a name="line2606"></a>2606       return 0
</span><span class="inferred0"><a name="line2607"></a>2607    end
</span><span class="inferred1"><a name="line2608"></a>2608 
</span><span class="inferred0"><a name="line2609"></a>2609    ###############################################################################
</span><span class="inferred1"><a name="line2610"></a>2610    #
</span><span class="inferred0"><a name="line2611"></a>2611    # _store_dimensions()
</span><span class="inferred1"><a name="line2612"></a>2612    #
</span><span class="inferred0"><a name="line2613"></a>2613    # Writes Excel DIMENSIONS to define the area in which there is cell data.
</span><span class="inferred1"><a name="line2614"></a>2614    #
</span><span class="inferred0"><a name="line2615"></a>2615    # Notes:
</span><span class="inferred1"><a name="line2616"></a>2616    #   Excel stores the max row/col as row/col +1.
</span><span class="inferred0"><a name="line2617"></a>2617    #   Max and min values of 0 are used to indicate that no cell data.
</span><span class="inferred1"><a name="line2618"></a>2618    #   We set the undef member data to 0 since it is used by _store_table().
</span><span class="inferred0"><a name="line2619"></a>2619    #   Inserting images or charts doesn't change the DIMENSION data.
</span><span class="inferred1"><a name="line2620"></a>2620    #
</span><span class="marked0"><a name="line2621"></a>2621    def store_dimensions
</span><span class="marked1"><a name="line2622"></a>2622       record    = 0x0200         # Record identifier
</span><span class="marked0"><a name="line2623"></a>2623       length    = 0x000E         # Number of bytes to follow
</span><span class="marked1"><a name="line2624"></a>2624       reserved  = 0x0000         # Reserved by Excel
</span><span class="inferred0"><a name="line2625"></a>2625 
</span><span class="marked1"><a name="line2626"></a>2626       row_min = @dim_rowmin.nil? ? 0 : @dim_rowmin
</span><span class="marked0"><a name="line2627"></a>2627       row_max = @dim_rowmax.nil? ? 0 : @dim_rowmax + 1
</span><span class="marked1"><a name="line2628"></a>2628       col_min = @dim_colmin.nil? ? 0 : @dim_colmin
</span><span class="marked0"><a name="line2629"></a>2629       col_max = @dim_colmax.nil? ? 0 : @dim_colmax + 1
</span><span class="inferred1"><a name="line2630"></a>2630 
</span><span class="inferred0"><a name="line2631"></a>2631       # Set member data to the new max/min value for use by _store_table().
</span><span class="marked1"><a name="line2632"></a>2632       @dim_rowmin = row_min
</span><span class="marked0"><a name="line2633"></a>2633       @dim_rowmax = row_max
</span><span class="marked1"><a name="line2634"></a>2634       @dim_colmin = col_min
</span><span class="marked0"><a name="line2635"></a>2635       @dim_colmax = col_max
</span><span class="inferred1"><a name="line2636"></a>2636   
</span><span class="marked0"><a name="line2637"></a>2637       header = [record, length].pack(&quot;vv&quot;)
</span><span class="marked1"><a name="line2638"></a>2638       fields = [row_min, row_max, col_min, col_max, reserved]
</span><span class="marked0"><a name="line2639"></a>2639       data   = fields.pack(&quot;VVvvv&quot;)
</span><span class="inferred1"><a name="line2640"></a>2640      
</span><span class="marked0"><a name="line2641"></a>2641       return prepend(header, data)
</span><span class="inferred1"><a name="line2642"></a>2642    end
</span><span class="inferred0"><a name="line2643"></a>2643 
</span><span class="inferred1"><a name="line2644"></a>2644    ###############################################################################
</span><span class="inferred0"><a name="line2645"></a>2645    #
</span><span class="inferred1"><a name="line2646"></a>2646    # _store_window2()
</span><span class="inferred0"><a name="line2647"></a>2647    #
</span><span class="inferred1"><a name="line2648"></a>2648    # Write BIFF record Window2.
</span><span class="inferred0"><a name="line2649"></a>2649    #
</span><span class="marked1"><a name="line2650"></a>2650    def _store_window2
</span><span class="uncovered0"><a name="line2651"></a>2651       record         = 0x023E     # Record identifier
</span><span class="uncovered1"><a name="line2652"></a>2652       length         = 0x0012     # Number of bytes to follow
</span><span class="uncovered0"><a name="line2653"></a>2653 
</span><span class="uncovered1"><a name="line2654"></a>2654       grbit          = 0x00B6     # Option flags
</span><span class="uncovered0"><a name="line2655"></a>2655       rwTop          = @first_row   # Top visible row
</span><span class="uncovered1"><a name="line2656"></a>2656       colLeft        = @first_col   # Leftmost visible column
</span><span class="uncovered0"><a name="line2657"></a>2657       rgbHdr         = 0x00000040            # Row/col heading, grid color
</span><span class="uncovered1"><a name="line2658"></a>2658 
</span><span class="uncovered0"><a name="line2659"></a>2659       wScaleSLV      = 0x0000                # Zoom in page break preview
</span><span class="uncovered1"><a name="line2660"></a>2660       wScaleNormal   = 0x0000                # Zoom in normal view
</span><span class="uncovered0"><a name="line2661"></a>2661       reserved       = 0x00000000
</span><span class="uncovered1"><a name="line2662"></a>2662 
</span><span class="uncovered0"><a name="line2663"></a>2663 
</span><span class="uncovered1"><a name="line2664"></a>2664       # The options flags that comprise $grbit
</span><span class="uncovered0"><a name="line2665"></a>2665       fDspFmla       = @display_formulas # 0 - bit
</span><span class="uncovered1"><a name="line2666"></a>2666       fDspGrid       = @screen_gridlines # 1
</span><span class="uncovered0"><a name="line2667"></a>2667       fDspRwCol      = @display_headers  # 2
</span><span class="uncovered1"><a name="line2668"></a>2668       fFrozen        = @frozen           # 3
</span><span class="uncovered0"><a name="line2669"></a>2669       fDspZeros      = @display_zeros    # 4
</span><span class="uncovered1"><a name="line2670"></a>2670       fDefaultHdr    = 1                 # 5
</span><span class="uncovered0"><a name="line2671"></a>2671       fArabic        = @display_arabic   # 6
</span><span class="uncovered1"><a name="line2672"></a>2672       fDspGuts       = @outline_on       # 7
</span><span class="uncovered0"><a name="line2673"></a>2673       fFrozenNoSplit = @frozen_no_split  # 0 - bit
</span><span class="uncovered1"><a name="line2674"></a>2674       fSelected      = @selected         # 1
</span><span class="uncovered0"><a name="line2675"></a>2675       fPaged         = @active           # 2
</span><span class="uncovered1"><a name="line2676"></a>2676       fBreakPreview  = 0                # 3
</span><span class="uncovered0"><a name="line2677"></a>2677 
</span><span class="uncovered1"><a name="line2678"></a>2678       grbit             = fDspFmla
</span><span class="uncovered0"><a name="line2679"></a>2679       grbit            |= fDspGrid       &lt;&lt; 1
</span><span class="uncovered1"><a name="line2680"></a>2680       grbit            |= fDspRwCol      &lt;&lt; 2
</span><span class="uncovered0"><a name="line2681"></a>2681       grbit            |= fFrozen        &lt;&lt; 3
</span><span class="uncovered1"><a name="line2682"></a>2682       grbit            |= fDspZeros      &lt;&lt; 4
</span><span class="uncovered0"><a name="line2683"></a>2683       grbit            |= fDefaultHdr    &lt;&lt; 5
</span><span class="uncovered1"><a name="line2684"></a>2684       grbit            |= fArabic        &lt;&lt; 6
</span><span class="uncovered0"><a name="line2685"></a>2685       grbit            |= fDspGuts       &lt;&lt; 7
</span><span class="uncovered1"><a name="line2686"></a>2686       grbit            |= fFrozenNoSplit &lt;&lt; 8
</span><span class="uncovered0"><a name="line2687"></a>2687       grbit            |= fSelected      &lt;&lt; 9
</span><span class="uncovered1"><a name="line2688"></a>2688       grbit            |= fPaged         &lt;&lt; 10
</span><span class="uncovered0"><a name="line2689"></a>2689       grbit            |= fBreakPreview  &lt;&lt; 11
</span><span class="uncovered1"><a name="line2690"></a>2690 
</span><span class="uncovered0"><a name="line2691"></a>2691       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2692"></a>2692       data    =[grbit, rwTop, colLeft, rgbHdr, wScaleSLV, wScaleNormal, reserved].pack(&quot;vvvVvvV&quot;)
</span><span class="uncovered0"><a name="line2693"></a>2693 
</span><span class="uncovered1"><a name="line2694"></a>2694       append(header, data)
</span><span class="uncovered0"><a name="line2695"></a>2695    end
</span><span class="inferred1"><a name="line2696"></a>2696 
</span><span class="inferred0"><a name="line2697"></a>2697    ###############################################################################
</span><span class="inferred1"><a name="line2698"></a>2698    #
</span><span class="inferred0"><a name="line2699"></a>2699    # _store_page_view()
</span><span class="inferred1"><a name="line2700"></a>2700    #
</span><span class="inferred0"><a name="line2701"></a>2701    # Set page view mode. Only applicable to Mac Excel.
</span><span class="inferred1"><a name="line2702"></a>2702    #
</span><span class="marked0"><a name="line2703"></a>2703    def store_page_view
</span><span class="uncovered1"><a name="line2704"></a>2704       return if @page_view == 0
</span><span class="uncovered0"><a name="line2705"></a>2705       data    = ['C8081100C808000000000040000000000900000000'].pack(&quot;H*&quot;)
</span><span class="uncovered1"><a name="line2706"></a>2706       append(data)
</span><span class="uncovered0"><a name="line2707"></a>2707    end
</span><span class="inferred1"><a name="line2708"></a>2708    
</span><span class="inferred0"><a name="line2709"></a>2709    ###############################################################################
</span><span class="inferred1"><a name="line2710"></a>2710    #
</span><span class="inferred0"><a name="line2711"></a>2711    # _store_tab_color()
</span><span class="inferred1"><a name="line2712"></a>2712    #
</span><span class="inferred0"><a name="line2713"></a>2713    # Write the Tab Color BIFF record.
</span><span class="inferred1"><a name="line2714"></a>2714    #
</span><span class="marked0"><a name="line2715"></a>2715    def store_tab_color
</span><span class="inferred1"><a name="line2716"></a>2716       color   = @tab_color
</span><span class="inferred0"><a name="line2717"></a>2717    
</span><span class="inferred1"><a name="line2718"></a>2718       return if color == 0
</span><span class="uncovered0"><a name="line2719"></a>2719    
</span><span class="uncovered1"><a name="line2720"></a>2720       record  = 0x0862      # Record identifier
</span><span class="uncovered0"><a name="line2721"></a>2721       length  = 0x0014      # Number of bytes to follow
</span><span class="uncovered1"><a name="line2722"></a>2722    
</span><span class="uncovered0"><a name="line2723"></a>2723       zero    = 0x0000
</span><span class="uncovered1"><a name="line2724"></a>2724       unknown = 0x0014
</span><span class="uncovered0"><a name="line2725"></a>2725    
</span><span class="uncovered1"><a name="line2726"></a>2726       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line2727"></a>2727       data   = [record, zero, zero, zero, zero,
</span><span class="uncovered1"><a name="line2728"></a>2728          zero, unknown, zero, color, zero].pack(&quot;vvvvvvvvvv&quot;)
</span><span class="uncovered0"><a name="line2729"></a>2729    
</span><span class="uncovered1"><a name="line2730"></a>2730       append(header, data)
</span><span class="uncovered0"><a name="line2731"></a>2731    end
</span><span class="inferred1"><a name="line2732"></a>2732    
</span><span class="inferred0"><a name="line2733"></a>2733    ###############################################################################
</span><span class="inferred1"><a name="line2734"></a>2734    #
</span><span class="inferred0"><a name="line2735"></a>2735    # _store_defrow()
</span><span class="inferred1"><a name="line2736"></a>2736    #
</span><span class="inferred0"><a name="line2737"></a>2737    # Write BIFF record DEFROWHEIGHT.
</span><span class="inferred1"><a name="line2738"></a>2738    #
</span><span class="marked0"><a name="line2739"></a>2739    def store_defrow
</span><span class="uncovered1"><a name="line2740"></a>2740       record   = 0x0225      # Record identifier
</span><span class="uncovered0"><a name="line2741"></a>2741       length   = 0x0004      # Number of bytes to follow
</span><span class="uncovered1"><a name="line2742"></a>2742    
</span><span class="uncovered0"><a name="line2743"></a>2743       grbit    = 0x0000      # Options.
</span><span class="uncovered1"><a name="line2744"></a>2744       height   = 0x00FF      # Default row height
</span><span class="uncovered0"><a name="line2745"></a>2745    
</span><span class="uncovered1"><a name="line2746"></a>2746       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line2747"></a>2747       data   = [grbit,  height].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line2748"></a>2748    
</span><span class="uncovered0"><a name="line2749"></a>2749       prepend(header, data)
</span><span class="uncovered1"><a name="line2750"></a>2750    end
</span><span class="inferred0"><a name="line2751"></a>2751    
</span><span class="inferred1"><a name="line2752"></a>2752    ###############################################################################
</span><span class="inferred0"><a name="line2753"></a>2753    #
</span><span class="inferred1"><a name="line2754"></a>2754    # _store_defcol()
</span><span class="inferred0"><a name="line2755"></a>2755    #
</span><span class="inferred1"><a name="line2756"></a>2756    # Write BIFF record DEFCOLWIDTH.
</span><span class="inferred0"><a name="line2757"></a>2757    #
</span><span class="marked1"><a name="line2758"></a>2758    def store_defcol
</span><span class="uncovered0"><a name="line2759"></a>2759       record   = 0x0055      # Record identifier
</span><span class="uncovered1"><a name="line2760"></a>2760       length   = 0x0002      # Number of bytes to follow
</span><span class="uncovered0"><a name="line2761"></a>2761    
</span><span class="uncovered1"><a name="line2762"></a>2762       colwidth = 0x0008      # Default column width
</span><span class="uncovered0"><a name="line2763"></a>2763    
</span><span class="uncovered1"><a name="line2764"></a>2764       header   = pack(&quot;vv&quot;, record, length)
</span><span class="uncovered0"><a name="line2765"></a>2765       data     = pack(&quot;v&quot;,  colwidth)
</span><span class="uncovered1"><a name="line2766"></a>2766    
</span><span class="uncovered0"><a name="line2767"></a>2767       prepend(header, data)
</span><span class="uncovered1"><a name="line2768"></a>2768    end
</span><span class="inferred0"><a name="line2769"></a>2769 
</span><span class="inferred1"><a name="line2770"></a>2770    ###############################################################################
</span><span class="inferred0"><a name="line2771"></a>2771    #
</span><span class="inferred1"><a name="line2772"></a>2772    # _store_colinfo($firstcol, $lastcol, $width, $format, $hidden)
</span><span class="inferred0"><a name="line2773"></a>2773    #
</span><span class="inferred1"><a name="line2774"></a>2774    #   firstcol : First formatted column
</span><span class="inferred0"><a name="line2775"></a>2775    #   lastcol  : Last formatted column
</span><span class="inferred1"><a name="line2776"></a>2776    #   width    : Col width in user units, 8.43 is default
</span><span class="inferred0"><a name="line2777"></a>2777    #   format   : format object
</span><span class="inferred1"><a name="line2778"></a>2778    #   hidden   : hidden flag
</span><span class="inferred0"><a name="line2779"></a>2779    #   
</span><span class="inferred1"><a name="line2780"></a>2780    # Write BIFF record COLINFO to define column widths
</span><span class="inferred0"><a name="line2781"></a>2781    #
</span><span class="inferred1"><a name="line2782"></a>2782    # Note: The SDK says the record length is 0x0B but Excel writes a 0x0C
</span><span class="inferred0"><a name="line2783"></a>2783    # length record.
</span><span class="inferred1"><a name="line2784"></a>2784    #
</span><span class="marked0"><a name="line2785"></a>2785    def store_colinfo(firstcol=0, lastcol=0, width=8.43, format=nil, hidden=0, level=0, collapsed=0)
</span><span class="marked1"><a name="line2786"></a>2786       record   = 0x007D          # Record identifier
</span><span class="marked0"><a name="line2787"></a>2787       length   = 0x000B          # Number of bytes to follow
</span><span class="inferred1"><a name="line2788"></a>2788 
</span><span class="inferred0"><a name="line2789"></a>2789       # Excel rounds the column width to the nearest pixel. Therefore we first
</span><span class="inferred1"><a name="line2790"></a>2790       # convert to pixels and then to the internal units. The pixel to users-units
</span><span class="inferred0"><a name="line2791"></a>2791       # relationship is different for values less than 1.
</span><span class="inferred1"><a name="line2792"></a>2792       #
</span><span class="marked0"><a name="line2793"></a>2793       if width &lt; 1
</span><span class="uncovered1"><a name="line2794"></a>2794          pixels = width *12
</span><span class="inferred0"><a name="line2795"></a>2795       else
</span><span class="marked1"><a name="line2796"></a>2796          pixels = width *7 +5
</span><span class="inferred0"><a name="line2797"></a>2797       end
</span><span class="marked1"><a name="line2798"></a>2798       pixels = pixels.to_i
</span><span class="inferred0"><a name="line2799"></a>2799       
</span><span class="marked1"><a name="line2800"></a>2800       coldx    = (pixels *256/7).to_i   # Col width in internal units
</span><span class="marked0"><a name="line2801"></a>2801       grbit    = 0x0000               # Option flags
</span><span class="marked1"><a name="line2802"></a>2802       reserved = 0x00                 # Reserved
</span><span class="inferred0"><a name="line2803"></a>2803 
</span><span class="inferred1"><a name="line2804"></a>2804       # Check for a format object
</span><span class="marked0"><a name="line2805"></a>2805       if !format.nil? &amp;&amp; format.kind_of?(Format)
</span><span class="uncovered1"><a name="line2806"></a>2806          ixfe = format.get_xf_index
</span><span class="inferred0"><a name="line2807"></a>2807       else
</span><span class="marked1"><a name="line2808"></a>2808          ixfe = 0x0F
</span><span class="inferred0"><a name="line2809"></a>2809       end
</span><span class="inferred1"><a name="line2810"></a>2810 
</span><span class="inferred0"><a name="line2811"></a>2811       # Set the limits for the outline levels (0 &lt;= x &lt;= 7).
</span><span class="marked1"><a name="line2812"></a>2812       level = 0 if level &lt; 0
</span><span class="marked0"><a name="line2813"></a>2813       level = 7 if level &gt; 7
</span><span class="inferred1"><a name="line2814"></a>2814 
</span><span class="inferred0"><a name="line2815"></a>2815 
</span><span class="inferred1"><a name="line2816"></a>2816       # Set the options flags. (See set_row() for more details).
</span><span class="marked0"><a name="line2817"></a>2817       grbit |= 0x0001 if hidden != 0
</span><span class="marked1"><a name="line2818"></a>2818       grbit |= level &lt;&lt; 8
</span><span class="marked0"><a name="line2819"></a>2819       grbit |= 0x1000 if collapsed != 0
</span><span class="inferred1"><a name="line2820"></a>2820 
</span><span class="marked0"><a name="line2821"></a>2821       header = [record, length].pack(&quot;vv&quot;)
</span><span class="marked1"><a name="line2822"></a>2822       data   = [firstcol, lastcol, coldx,
</span><span class="inferred0"><a name="line2823"></a>2823          ixfe, grbit, reserved].pack(&quot;vvvvvC&quot;)
</span><span class="inferred1"><a name="line2824"></a>2824    
</span><span class="marked0"><a name="line2825"></a>2825       prepend(header, data)
</span><span class="inferred1"><a name="line2826"></a>2826    end
</span><span class="inferred0"><a name="line2827"></a>2827 
</span><span class="inferred1"><a name="line2828"></a>2828    ###############################################################################
</span><span class="inferred0"><a name="line2829"></a>2829    #
</span><span class="inferred1"><a name="line2830"></a>2830    # _store_filtermode()
</span><span class="inferred0"><a name="line2831"></a>2831    #
</span><span class="inferred1"><a name="line2832"></a>2832    # Write BIFF record FILTERMODE to indicate that the worksheet contains
</span><span class="inferred0"><a name="line2833"></a>2833    # AUTOFILTER record, ie. autofilters with a filter set.
</span><span class="inferred1"><a name="line2834"></a>2834    #
</span><span class="marked0"><a name="line2835"></a>2835    def store_filtermode
</span><span class="inferred1"><a name="line2836"></a>2836       # Only write the record if the worksheet contains a filtered autofilter.
</span><span class="marked0"><a name="line2837"></a>2837       return '' if @filter_on == 0
</span><span class="inferred1"><a name="line2838"></a>2838 
</span><span class="marked0"><a name="line2839"></a>2839       record      = 0x009B      # Record identifier
</span><span class="marked1"><a name="line2840"></a>2840       length      = 0x0000      # Number of bytes to follow
</span><span class="inferred0"><a name="line2841"></a>2841 
</span><span class="marked1"><a name="line2842"></a>2842       header = [record, length].pack('vv')
</span><span class="inferred0"><a name="line2843"></a>2843 
</span><span class="marked1"><a name="line2844"></a>2844       prepend(header)
</span><span class="inferred0"><a name="line2845"></a>2845    end
</span><span class="inferred1"><a name="line2846"></a>2846 
</span><span class="inferred0"><a name="line2847"></a>2847 
</span><span class="inferred1"><a name="line2848"></a>2848    ###############################################################################
</span><span class="inferred0"><a name="line2849"></a>2849    #
</span><span class="inferred1"><a name="line2850"></a>2850    # _store_autofilterinfo()
</span><span class="inferred0"><a name="line2851"></a>2851    #
</span><span class="inferred1"><a name="line2852"></a>2852    # Write BIFF record AUTOFILTERINFO.
</span><span class="inferred0"><a name="line2853"></a>2853    #
</span><span class="marked1"><a name="line2854"></a>2854    def store_autofilterinfo
</span><span class="uncovered0"><a name="line2855"></a>2855       # Only write the record if the worksheet contains an autofilter.
</span><span class="uncovered1"><a name="line2856"></a>2856       return '' if @filter_count == 0
</span><span class="uncovered0"><a name="line2857"></a>2857 
</span><span class="uncovered1"><a name="line2858"></a>2858       record      = 0x009D      # Record identifier
</span><span class="uncovered0"><a name="line2859"></a>2859       length      = 0x0002      # Number of bytes to follow
</span><span class="uncovered1"><a name="line2860"></a>2860       num_filters = @filter_count
</span><span class="uncovered0"><a name="line2861"></a>2861 
</span><span class="uncovered1"><a name="line2862"></a>2862       header = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line2863"></a>2863       data   = [num_filters].pack('v')
</span><span class="uncovered1"><a name="line2864"></a>2864 
</span><span class="uncovered0"><a name="line2865"></a>2865       prepend(header, data)
</span><span class="uncovered1"><a name="line2866"></a>2866    end
</span><span class="inferred0"><a name="line2867"></a>2867 
</span><span class="inferred1"><a name="line2868"></a>2868 
</span><span class="inferred0"><a name="line2869"></a>2869    ###############################################################################
</span><span class="inferred1"><a name="line2870"></a>2870    #
</span><span class="inferred0"><a name="line2871"></a>2871    # _store_selection($first_row, $first_col, $last_row, $last_col)
</span><span class="inferred1"><a name="line2872"></a>2872    #
</span><span class="inferred0"><a name="line2873"></a>2873    # Write BIFF record SELECTION.
</span><span class="inferred1"><a name="line2874"></a>2874    #
</span><span class="marked0"><a name="line2875"></a>2875    def store_selection(first_row=0, first_col=0, last_row = nil, last_col =nil)
</span><span class="marked1"><a name="line2876"></a>2876       record   = 0x001D                  # Record identifier
</span><span class="marked0"><a name="line2877"></a>2877       length   = 0x000F                  # Number of bytes to follow
</span><span class="inferred1"><a name="line2878"></a>2878 
</span><span class="marked0"><a name="line2879"></a>2879       pnn      = @active_pane   # Pane position
</span><span class="marked1"><a name="line2880"></a>2880       rwAct    = first_row                   # Active row
</span><span class="marked0"><a name="line2881"></a>2881       colAct   = first_col                   # Active column
</span><span class="marked1"><a name="line2882"></a>2882       irefAct  = 0                       # Active cell ref
</span><span class="marked0"><a name="line2883"></a>2883       cref     = 1                       # Number of refs
</span><span class="inferred1"><a name="line2884"></a>2884 
</span><span class="marked0"><a name="line2885"></a>2885       rwFirst  = first_row                   # First row in reference
</span><span class="marked1"><a name="line2886"></a>2886       colFirst = first_col                   # First col in reference
</span><span class="marked0"><a name="line2887"></a>2887       rwLast   = last_row || rwFirst       # Last  row in reference
</span><span class="marked1"><a name="line2888"></a>2888       colLast  = last_col || colFirst      # Last  col in reference
</span><span class="inferred0"><a name="line2889"></a>2889 
</span><span class="inferred1"><a name="line2890"></a>2890       # Swap last row/col for first row/col as necessary
</span><span class="marked0"><a name="line2891"></a>2891       if rwFirst &gt; rwLast
</span><span class="uncovered1"><a name="line2892"></a>2892          tmp = rwFirst
</span><span class="uncovered0"><a name="line2893"></a>2893          rwFirst = rwLast
</span><span class="uncovered1"><a name="line2894"></a>2894          rwLast = tmp
</span><span class="uncovered0"><a name="line2895"></a>2895       end
</span><span class="inferred1"><a name="line2896"></a>2896 
</span><span class="marked0"><a name="line2897"></a>2897       if colFirst &gt; colLast
</span><span class="uncovered1"><a name="line2898"></a>2898          tmp = colFirst
</span><span class="uncovered0"><a name="line2899"></a>2899          colFirst = colLast
</span><span class="uncovered1"><a name="line2900"></a>2900          colLast = tmp
</span><span class="uncovered0"><a name="line2901"></a>2901       end
</span><span class="inferred1"><a name="line2902"></a>2902 
</span><span class="marked0"><a name="line2903"></a>2903       header = [record, length].pack('vv')
</span><span class="marked1"><a name="line2904"></a>2904       data = [pnn, rwAct, colAct, irefAct, cref,
</span><span class="inferred0"><a name="line2905"></a>2905          rwFirst, rwLast, colFirst, colLast].pack('CvvvvvvCC')
</span><span class="inferred1"><a name="line2906"></a>2906 
</span><span class="marked0"><a name="line2907"></a>2907       append(header, data)
</span><span class="inferred1"><a name="line2908"></a>2908    end
</span><span class="inferred0"><a name="line2909"></a>2909 
</span><span class="inferred1"><a name="line2910"></a>2910 
</span><span class="inferred0"><a name="line2911"></a>2911    ###############################################################################
</span><span class="inferred1"><a name="line2912"></a>2912    #
</span><span class="inferred0"><a name="line2913"></a>2913    # _store_externcount($count)
</span><span class="inferred1"><a name="line2914"></a>2914    #
</span><span class="inferred0"><a name="line2915"></a>2915    # Write BIFF record EXTERNCOUNT to indicate the number of external sheet
</span><span class="inferred1"><a name="line2916"></a>2916    # references in a worksheet.
</span><span class="inferred0"><a name="line2917"></a>2917    #
</span><span class="inferred1"><a name="line2918"></a>2918    # Excel only stores references to external sheets that are used in formulas.
</span><span class="inferred0"><a name="line2919"></a>2919    # For simplicity we store references to all the sheets in the workbook
</span><span class="inferred1"><a name="line2920"></a>2920    # regardless of whether they are used or not. This reduces the overall
</span><span class="inferred0"><a name="line2921"></a>2921    # complexity and eliminates the need for a two way dialogue between the formula
</span><span class="inferred1"><a name="line2922"></a>2922    # parser the worksheet objects.
</span><span class="inferred0"><a name="line2923"></a>2923    #
</span><span class="marked1"><a name="line2924"></a>2924    def store_externcount(count)
</span><span class="uncovered0"><a name="line2925"></a>2925       record   = 0x0016          # Record identifier
</span><span class="uncovered1"><a name="line2926"></a>2926       length   = 0x0002          # Number of bytes to follow
</span><span class="uncovered0"><a name="line2927"></a>2927 
</span><span class="uncovered1"><a name="line2928"></a>2928       cxals    = count           # Number of external references
</span><span class="uncovered0"><a name="line2929"></a>2929 
</span><span class="uncovered1"><a name="line2930"></a>2930       header = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line2931"></a>2931       data   = [cxals].pack('v')
</span><span class="uncovered1"><a name="line2932"></a>2932 
</span><span class="uncovered0"><a name="line2933"></a>2933       prepend(header, data)
</span><span class="uncovered1"><a name="line2934"></a>2934    end
</span><span class="inferred0"><a name="line2935"></a>2935 
</span><span class="inferred1"><a name="line2936"></a>2936 
</span><span class="inferred0"><a name="line2937"></a>2937    ###############################################################################
</span><span class="inferred1"><a name="line2938"></a>2938    #
</span><span class="inferred0"><a name="line2939"></a>2939    # _store_externsheet($sheetname)
</span><span class="inferred1"><a name="line2940"></a>2940    #    sheetname  : Worksheet name
</span><span class="inferred0"><a name="line2941"></a>2941    #
</span><span class="inferred1"><a name="line2942"></a>2942    # Writes the Excel BIFF EXTERNSHEET record. These references are used by
</span><span class="inferred0"><a name="line2943"></a>2943    # formulas. A formula references a sheet name via an index. Since we store a
</span><span class="inferred1"><a name="line2944"></a>2944    # reference to all of the external worksheets the EXTERNSHEET index is the same
</span><span class="inferred0"><a name="line2945"></a>2945    # as the worksheet index.
</span><span class="inferred1"><a name="line2946"></a>2946    #
</span><span class="marked0"><a name="line2947"></a>2947    def store_externsheet(sheetname)
</span><span class="uncovered1"><a name="line2948"></a>2948       record    = 0x0017         # Record identifier
</span><span class="uncovered0"><a name="line2949"></a>2949       # length;                     # Number of bytes to follow
</span><span class="uncovered1"><a name="line2950"></a>2950 
</span><span class="uncovered0"><a name="line2951"></a>2951       # cch                        # Length of sheet name
</span><span class="uncovered1"><a name="line2952"></a>2952       # rgch                       # Filename encoding
</span><span class="uncovered0"><a name="line2953"></a>2953 
</span><span class="uncovered1"><a name="line2954"></a>2954       # References to the current sheet are encoded differently to references to
</span><span class="uncovered0"><a name="line2955"></a>2955       # external sheets.
</span><span class="uncovered1"><a name="line2956"></a>2956       #
</span><span class="uncovered0"><a name="line2957"></a>2957       if @name == sheetname
</span><span class="uncovered1"><a name="line2958"></a>2958          sheetname = ''
</span><span class="uncovered0"><a name="line2959"></a>2959          length    = 0x02  # The following 2 bytes
</span><span class="uncovered1"><a name="line2960"></a>2960          cch       = 1     # The following byte
</span><span class="uncovered0"><a name="line2961"></a>2961          rgch      = 0x02  # Self reference
</span><span class="uncovered1"><a name="line2962"></a>2962       else
</span><span class="uncovered0"><a name="line2963"></a>2963          length    = 0x02 + sheetname.length
</span><span class="uncovered1"><a name="line2964"></a>2964          cch       = sheetname.length
</span><span class="uncovered0"><a name="line2965"></a>2965          rgch      = 0x03  # Reference to a sheet in the current workbook
</span><span class="uncovered1"><a name="line2966"></a>2966       end
</span><span class="uncovered0"><a name="line2967"></a>2967 
</span><span class="uncovered1"><a name="line2968"></a>2968       header = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line2969"></a>2969       data   = [cch, rgch].pack('CC')
</span><span class="uncovered1"><a name="line2970"></a>2970 
</span><span class="uncovered0"><a name="line2971"></a>2971       prepend(header, data, sheetname)
</span><span class="uncovered1"><a name="line2972"></a>2972    end
</span><span class="inferred0"><a name="line2973"></a>2973 
</span><span class="inferred1"><a name="line2974"></a>2974 
</span><span class="inferred0"><a name="line2975"></a>2975    ###############################################################################
</span><span class="inferred1"><a name="line2976"></a>2976    #
</span><span class="inferred0"><a name="line2977"></a>2977    # _store_panes(y, x, colLeft, no_split, pnnAct)
</span><span class="inferred1"><a name="line2978"></a>2978    #    y           = args[0] || 0   # Vertical split position
</span><span class="inferred0"><a name="line2979"></a>2979    #    x           = $_[1] || 0;   # Horizontal split position
</span><span class="inferred1"><a name="line2980"></a>2980    #    rwTop       = $_[2];        # Top row visible
</span><span class="inferred0"><a name="line2981"></a>2981    #    my $colLeft     = $_[3];        # Leftmost column visible
</span><span class="inferred1"><a name="line2982"></a>2982    #    my $no_split    = $_[4];        # No used here.
</span><span class="inferred0"><a name="line2983"></a>2983    #    my $pnnAct      = $_[5];        # Active pane
</span><span class="inferred1"><a name="line2984"></a>2984    #
</span><span class="inferred0"><a name="line2985"></a>2985    #
</span><span class="inferred1"><a name="line2986"></a>2986    # Writes the Excel BIFF PANE record.
</span><span class="inferred0"><a name="line2987"></a>2987    # The panes can either be frozen or thawed (unfrozen).
</span><span class="inferred1"><a name="line2988"></a>2988    # Frozen panes are specified in terms of a integer number of rows and columns.
</span><span class="inferred0"><a name="line2989"></a>2989    # Thawed panes are specified in terms of Excel's units for rows and columns.
</span><span class="inferred1"><a name="line2990"></a>2990    #
</span><span class="marked0"><a name="line2991"></a>2991    def store_panes(y, x, colLeft, no_split, pnnAct)
</span><span class="uncovered1"><a name="line2992"></a>2992       record      = 0x0041       # Record identifier
</span><span class="uncovered0"><a name="line2993"></a>2993       length      = 0x000A       # Number of bytes to follow
</span><span class="uncovered1"><a name="line2994"></a>2994 
</span><span class="uncovered0"><a name="line2995"></a>2995       y = 0 if y.nil?
</span><span class="uncovered1"><a name="line2996"></a>2996       x = 0 if x.nil?
</span><span class="uncovered0"><a name="line2997"></a>2997 
</span><span class="uncovered1"><a name="line2998"></a>2998       # Code specific to frozen or thawed panes.
</span><span class="uncovered0"><a name="line2999"></a>2999       if @frozen != 0
</span><span class="uncovered1"><a name="line3000"></a>3000          # Set default values for $rwTop and $colLeft
</span><span class="uncovered0"><a name="line3001"></a>3001          rwTop   = y unless defined? rwTop
</span><span class="uncovered1"><a name="line3002"></a>3002          colLeft = x unless defined? colLeft
</span><span class="uncovered0"><a name="line3003"></a>3003       else
</span><span class="uncovered1"><a name="line3004"></a>3004          # Set default values for $rwTop and $colLeft
</span><span class="uncovered0"><a name="line3005"></a>3005          rwTop   = 0  unless defined? rwTop
</span><span class="uncovered1"><a name="line3006"></a>3006          colLeft = 0  unless defined? colLeft
</span><span class="uncovered0"><a name="line3007"></a>3007 
</span><span class="uncovered1"><a name="line3008"></a>3008          # Convert Excel's row and column units to the internal units.
</span><span class="uncovered0"><a name="line3009"></a>3009          # The default row height is 12.75
</span><span class="uncovered1"><a name="line3010"></a>3010          # The default column width is 8.43
</span><span class="uncovered0"><a name="line3011"></a>3011          # The following slope and intersection values were interpolated.
</span><span class="uncovered1"><a name="line3012"></a>3012          #
</span><span class="uncovered0"><a name="line3013"></a>3013          y = 20*y      + 255
</span><span class="uncovered1"><a name="line3014"></a>3014          x = 113.879*x + 390
</span><span class="uncovered0"><a name="line3015"></a>3015       end
</span><span class="uncovered1"><a name="line3016"></a>3016 
</span><span class="uncovered0"><a name="line3017"></a>3017 
</span><span class="uncovered1"><a name="line3018"></a>3018       # Determine which pane should be active. There is also the undocumented
</span><span class="uncovered0"><a name="line3019"></a>3019       # option to override this should it be necessary: may be removed later.
</span><span class="uncovered1"><a name="line3020"></a>3020       #
</span><span class="uncovered0"><a name="line3021"></a>3021       unless defined? pnnAct
</span><span class="uncovered1"><a name="line3022"></a>3022          pnnAct = 0 if (x != 0 &amp;&amp; y != 0) # Bottom right
</span><span class="uncovered0"><a name="line3023"></a>3023          pnnAct = 1 if (x != 0 &amp;&amp; y == 0) # Top right
</span><span class="uncovered1"><a name="line3024"></a>3024          pnnAct = 2 if (x == 0 &amp;&amp; y != 0) # Bottom left
</span><span class="uncovered0"><a name="line3025"></a>3025          pnnAct = 3 if (x == 0 &amp;&amp; y == 0) # Top left
</span><span class="uncovered1"><a name="line3026"></a>3026       end
</span><span class="uncovered0"><a name="line3027"></a>3027 
</span><span class="uncovered1"><a name="line3028"></a>3028       @active_pane = pnnAct # Used in _store_selection
</span><span class="uncovered0"><a name="line3029"></a>3029 
</span><span class="uncovered1"><a name="line3030"></a>3030       header = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3031"></a>3031       data   = [x, y, rwTop, colLeft, pnnAct].pack('vvvvv')
</span><span class="uncovered1"><a name="line3032"></a>3032 
</span><span class="uncovered0"><a name="line3033"></a>3033       append(header, data)
</span><span class="uncovered1"><a name="line3034"></a>3034    end
</span><span class="inferred0"><a name="line3035"></a>3035 
</span><span class="inferred1"><a name="line3036"></a>3036 
</span><span class="inferred0"><a name="line3037"></a>3037    ###############################################################################
</span><span class="inferred1"><a name="line3038"></a>3038    #
</span><span class="inferred0"><a name="line3039"></a>3039    # _store_setup()
</span><span class="inferred1"><a name="line3040"></a>3040    #
</span><span class="inferred0"><a name="line3041"></a>3041    # Store the page setup SETUP BIFF record.
</span><span class="inferred1"><a name="line3042"></a>3042    #
</span><span class="marked0"><a name="line3043"></a>3043    def store_setup
</span><span class="uncovered1"><a name="line3044"></a>3044       record       = 0x00A1                  # Record identifier
</span><span class="uncovered0"><a name="line3045"></a>3045       length       = 0x0022                  # Number of bytes to follow
</span><span class="uncovered1"><a name="line3046"></a>3046 
</span><span class="uncovered0"><a name="line3047"></a>3047       iPaperSize   = @paper_size    # Paper size
</span><span class="uncovered1"><a name="line3048"></a>3048       iScale       = @print_scale   # Print scaling factor
</span><span class="uncovered0"><a name="line3049"></a>3049       iPageStart   = @page_start    # Starting page number
</span><span class="uncovered1"><a name="line3050"></a>3050       iFitWidth    = @fit_width     # Fit to number of pages wide
</span><span class="uncovered0"><a name="line3051"></a>3051       iFitHeight   = @fit_height    # Fit to number of pages high
</span><span class="uncovered1"><a name="line3052"></a>3052       grbit        = 0x00                    # Option flags
</span><span class="uncovered0"><a name="line3053"></a>3053       iRes         = 0x0258                  # Print resolution
</span><span class="uncovered1"><a name="line3054"></a>3054       iVRes        = 0x0258                  # Vertical print resolution
</span><span class="uncovered0"><a name="line3055"></a>3055       numHdr       = @margin_header # Header Margin
</span><span class="uncovered1"><a name="line3056"></a>3056       numFtr       = @margin_footer # Footer Margin
</span><span class="uncovered0"><a name="line3057"></a>3057       iCopies      = 0x01                    # Number of copies
</span><span class="uncovered1"><a name="line3058"></a>3058 
</span><span class="uncovered0"><a name="line3059"></a>3059       fLeftToRight = @page_order    # Print over then down
</span><span class="uncovered1"><a name="line3060"></a>3060       fLandscape   = @orientation   # Page orientation
</span><span class="uncovered0"><a name="line3061"></a>3061       fNoPls       = 0x0                     # Setup not read from printer
</span><span class="uncovered1"><a name="line3062"></a>3062       fNoColor     = @black_white   # Print black and white
</span><span class="uncovered0"><a name="line3063"></a>3063       fDraft       = @draft_quality # Print draft quality
</span><span class="uncovered1"><a name="line3064"></a>3064       fNotes       = @print_comments# Print notes
</span><span class="uncovered0"><a name="line3065"></a>3065       fNoOrient    = 0x0            # Orientation not set
</span><span class="uncovered1"><a name="line3066"></a>3066       fUsePage     = @custom_start  # Use custom starting page
</span><span class="uncovered0"><a name="line3067"></a>3067 
</span><span class="uncovered1"><a name="line3068"></a>3068       grbit           = fLeftToRight
</span><span class="uncovered0"><a name="line3069"></a>3069       grbit          |= fLandscape    &lt;&lt; 1
</span><span class="uncovered1"><a name="line3070"></a>3070       grbit          |= fNoPls        &lt;&lt; 2
</span><span class="uncovered0"><a name="line3071"></a>3071       grbit          |= fNoColor      &lt;&lt; 3
</span><span class="uncovered1"><a name="line3072"></a>3072       grbit          |= fDraft        &lt;&lt; 4
</span><span class="uncovered0"><a name="line3073"></a>3073       grbit          |= fNotes        &lt;&lt; 5
</span><span class="uncovered1"><a name="line3074"></a>3074       grbit          |= fNoOrient     &lt;&lt; 6
</span><span class="uncovered0"><a name="line3075"></a>3075       grbit          |= fUsePage      &lt;&lt; 7
</span><span class="uncovered1"><a name="line3076"></a>3076 
</span><span class="uncovered0"><a name="line3077"></a>3077 
</span><span class="uncovered1"><a name="line3078"></a>3078       numHdr = [numHdr].pack('d')
</span><span class="uncovered0"><a name="line3079"></a>3079       numFtr = [numFtr].pack('d')
</span><span class="uncovered1"><a name="line3080"></a>3080 
</span><span class="uncovered0"><a name="line3081"></a>3081       if @byte_order != 0
</span><span class="uncovered1"><a name="line3082"></a>3082          numHdr = numHdr.reverse
</span><span class="uncovered0"><a name="line3083"></a>3083          numFtr = numFtr.reverse
</span><span class="uncovered1"><a name="line3084"></a>3084       end
</span><span class="uncovered0"><a name="line3085"></a>3085 
</span><span class="uncovered1"><a name="line3086"></a>3086       header = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3087"></a>3087       data1  = [iPaperSize, iScale, iPageStart,
</span><span class="uncovered1"><a name="line3088"></a>3088          iFitWidth, iFitHeight, grbit, iRes, iVRes].pack(&quot;vvvvvvvv&quot;)
</span><span class="uncovered0"><a name="line3089"></a>3089 
</span><span class="uncovered1"><a name="line3090"></a>3090       data2  = numHdr + numFtr
</span><span class="uncovered0"><a name="line3091"></a>3091       data3  = [iCopies].pack('v')
</span><span class="uncovered1"><a name="line3092"></a>3092 
</span><span class="uncovered0"><a name="line3093"></a>3093       prepend(header, data1, data2, data3)
</span><span class="uncovered1"><a name="line3094"></a>3094 
</span><span class="uncovered0"><a name="line3095"></a>3095    end
</span><span class="inferred1"><a name="line3096"></a>3096 
</span><span class="inferred0"><a name="line3097"></a>3097    ###############################################################################
</span><span class="inferred1"><a name="line3098"></a>3098    #
</span><span class="inferred0"><a name="line3099"></a>3099    # _store_header()
</span><span class="inferred1"><a name="line3100"></a>3100    #
</span><span class="inferred0"><a name="line3101"></a>3101    # Store the header caption BIFF record.
</span><span class="inferred1"><a name="line3102"></a>3102    #
</span><span class="marked0"><a name="line3103"></a>3103    def store_header
</span><span class="uncovered1"><a name="line3104"></a>3104       record      = 0x0014                       # Record identifier
</span><span class="uncovered0"><a name="line3105"></a>3105       # length                                     # Bytes to follow
</span><span class="uncovered1"><a name="line3106"></a>3106 
</span><span class="uncovered0"><a name="line3107"></a>3107       str         = @header             # header string
</span><span class="uncovered1"><a name="line3108"></a>3108       cch         = str.length                 # Length of header string
</span><span class="uncovered0"><a name="line3109"></a>3109       encoding    = @header_encoding    # Character encoding
</span><span class="uncovered1"><a name="line3110"></a>3110 
</span><span class="uncovered0"><a name="line3111"></a>3111 
</span><span class="uncovered1"><a name="line3112"></a>3112       # Character length is num of chars not num of bytes
</span><span class="uncovered0"><a name="line3113"></a>3113       cch           /= 2 if encoding != 0
</span><span class="uncovered1"><a name="line3114"></a>3114 
</span><span class="uncovered0"><a name="line3115"></a>3115       # Change the UTF-16 name from BE to LE
</span><span class="uncovered1"><a name="line3116"></a>3116       str            = [str].unpack('v*').pack('n*') if encoding != 0
</span><span class="uncovered0"><a name="line3117"></a>3117 
</span><span class="uncovered1"><a name="line3118"></a>3118       length         = 3 + str.length
</span><span class="uncovered0"><a name="line3119"></a>3119 
</span><span class="uncovered1"><a name="line3120"></a>3120       header      = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3121"></a>3121       data        =  [cch, encoding].pack('vC')
</span><span class="uncovered1"><a name="line3122"></a>3122 
</span><span class="uncovered0"><a name="line3123"></a>3123       prepend(header, data, str)
</span><span class="uncovered1"><a name="line3124"></a>3124    end
</span><span class="inferred0"><a name="line3125"></a>3125 
</span><span class="inferred1"><a name="line3126"></a>3126 
</span><span class="inferred0"><a name="line3127"></a>3127    ###############################################################################
</span><span class="inferred1"><a name="line3128"></a>3128    #
</span><span class="inferred0"><a name="line3129"></a>3129    # _store_footer()
</span><span class="inferred1"><a name="line3130"></a>3130    #
</span><span class="inferred0"><a name="line3131"></a>3131    # Store the footer caption BIFF record.
</span><span class="inferred1"><a name="line3132"></a>3132    #
</span><span class="marked0"><a name="line3133"></a>3133    def store_footer
</span><span class="uncovered1"><a name="line3134"></a>3134       record      = 0x0015                       # Record identifier
</span><span class="uncovered0"><a name="line3135"></a>3135       # length;                                     # Bytes to follow
</span><span class="uncovered1"><a name="line3136"></a>3136 
</span><span class="uncovered0"><a name="line3137"></a>3137       str         = @footer             # footer string
</span><span class="uncovered1"><a name="line3138"></a>3138       cch         = str.length                 # Length of ooter string
</span><span class="uncovered0"><a name="line3139"></a>3139       encoding    = @footer_encoding    # Character encoding
</span><span class="uncovered1"><a name="line3140"></a>3140 
</span><span class="uncovered0"><a name="line3141"></a>3141 
</span><span class="uncovered1"><a name="line3142"></a>3142       # Character length is num of chars not num of bytes
</span><span class="uncovered0"><a name="line3143"></a>3143       cch           /= 2 if encoding != 0
</span><span class="uncovered1"><a name="line3144"></a>3144 
</span><span class="uncovered0"><a name="line3145"></a>3145       # Change the UTF-16 name from BE to LE
</span><span class="uncovered1"><a name="line3146"></a>3146       str            = [str].unpack('v*').pack('n*')
</span><span class="uncovered0"><a name="line3147"></a>3147 
</span><span class="uncovered1"><a name="line3148"></a>3148       length         = 3 + str.length
</span><span class="uncovered0"><a name="line3149"></a>3149 
</span><span class="uncovered1"><a name="line3150"></a>3150       header      = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3151"></a>3151       data        =  [cch, encoding].pack('vC')
</span><span class="uncovered1"><a name="line3152"></a>3152 
</span><span class="uncovered0"><a name="line3153"></a>3153       prepend(header, data, str)
</span><span class="uncovered1"><a name="line3154"></a>3154    end
</span><span class="inferred0"><a name="line3155"></a>3155 
</span><span class="inferred1"><a name="line3156"></a>3156 
</span><span class="inferred0"><a name="line3157"></a>3157    ###############################################################################
</span><span class="inferred1"><a name="line3158"></a>3158    #
</span><span class="inferred0"><a name="line3159"></a>3159    # _store_hcenter()
</span><span class="inferred1"><a name="line3160"></a>3160    #
</span><span class="inferred0"><a name="line3161"></a>3161    # Store the horizontal centering HCENTER BIFF record.
</span><span class="inferred1"><a name="line3162"></a>3162    #
</span><span class="marked0"><a name="line3163"></a>3163    def store_hcenter
</span><span class="uncovered1"><a name="line3164"></a>3164       record   = 0x0083              # Record identifier
</span><span class="uncovered0"><a name="line3165"></a>3165       length   = 0x0002              # Bytes to follow
</span><span class="uncovered1"><a name="line3166"></a>3166 
</span><span class="uncovered0"><a name="line3167"></a>3167       fHCenter = @hcenter   # Horizontal centering
</span><span class="uncovered1"><a name="line3168"></a>3168 
</span><span class="uncovered0"><a name="line3169"></a>3169       header      = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line3170"></a>3170       data      = [fHCenter].pack('v')
</span><span class="uncovered0"><a name="line3171"></a>3171 
</span><span class="uncovered1"><a name="line3172"></a>3172       prepend(header, data)
</span><span class="uncovered0"><a name="line3173"></a>3173    end
</span><span class="inferred1"><a name="line3174"></a>3174 
</span><span class="inferred0"><a name="line3175"></a>3175 
</span><span class="inferred1"><a name="line3176"></a>3176    ###############################################################################
</span><span class="inferred0"><a name="line3177"></a>3177    #
</span><span class="inferred1"><a name="line3178"></a>3178    # _store_vcenter()
</span><span class="inferred0"><a name="line3179"></a>3179    #
</span><span class="inferred1"><a name="line3180"></a>3180    # Store the vertical centering VCENTER BIFF record.
</span><span class="inferred0"><a name="line3181"></a>3181    #
</span><span class="marked1"><a name="line3182"></a>3182    def store_vcenter
</span><span class="uncovered0"><a name="line3183"></a>3183       record   = 0x0084              # Record identifier
</span><span class="uncovered1"><a name="line3184"></a>3184       length   = 0x0002              # Bytes to follow
</span><span class="uncovered0"><a name="line3185"></a>3185 
</span><span class="uncovered1"><a name="line3186"></a>3186       mfVCenter = @vcenter   # Horizontal centering
</span><span class="uncovered0"><a name="line3187"></a>3187 
</span><span class="uncovered1"><a name="line3188"></a>3188       header      = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3189"></a>3189       data      = [mfVCenter].pack('v')
</span><span class="uncovered1"><a name="line3190"></a>3190 
</span><span class="uncovered0"><a name="line3191"></a>3191       prepend(header, data)
</span><span class="uncovered1"><a name="line3192"></a>3192    end
</span><span class="inferred0"><a name="line3193"></a>3193 
</span><span class="inferred1"><a name="line3194"></a>3194 
</span><span class="inferred0"><a name="line3195"></a>3195    ###############################################################################
</span><span class="inferred1"><a name="line3196"></a>3196    #
</span><span class="inferred0"><a name="line3197"></a>3197    # _store_margin_left()
</span><span class="inferred1"><a name="line3198"></a>3198    #
</span><span class="inferred0"><a name="line3199"></a>3199    # Store the LEFTMARGIN BIFF record.
</span><span class="inferred1"><a name="line3200"></a>3200    #
</span><span class="marked0"><a name="line3201"></a>3201    def store_margin_left
</span><span class="uncovered1"><a name="line3202"></a>3202       record  = 0x0026                   # Record identifier
</span><span class="uncovered0"><a name="line3203"></a>3203       length  = 0x0008                   # Bytes to follow
</span><span class="uncovered1"><a name="line3204"></a>3204 
</span><span class="uncovered0"><a name="line3205"></a>3205       margin  = @margin_left    # Margin in inches
</span><span class="uncovered1"><a name="line3206"></a>3206 
</span><span class="uncovered0"><a name="line3207"></a>3207       header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line3208"></a>3208       data    = [margin].pack('d')
</span><span class="uncovered0"><a name="line3209"></a>3209 
</span><span class="uncovered1"><a name="line3210"></a>3210       data = data.reverse if @byte_order != 0
</span><span class="uncovered0"><a name="line3211"></a>3211 
</span><span class="uncovered1"><a name="line3212"></a>3212       prepend(header, data)
</span><span class="uncovered0"><a name="line3213"></a>3213    end
</span><span class="inferred1"><a name="line3214"></a>3214 
</span><span class="inferred0"><a name="line3215"></a>3215 
</span><span class="inferred1"><a name="line3216"></a>3216    ###############################################################################
</span><span class="inferred0"><a name="line3217"></a>3217    #
</span><span class="inferred1"><a name="line3218"></a>3218    # _store_margin_right()
</span><span class="inferred0"><a name="line3219"></a>3219    #
</span><span class="inferred1"><a name="line3220"></a>3220    # Store the RIGHTMARGIN BIFF record.
</span><span class="inferred0"><a name="line3221"></a>3221    #
</span><span class="marked1"><a name="line3222"></a>3222    def store_margin_right
</span><span class="uncovered0"><a name="line3223"></a>3223       record  = 0x0027                   # Record identifier
</span><span class="uncovered1"><a name="line3224"></a>3224       length  = 0x0008                   # Bytes to follow
</span><span class="uncovered0"><a name="line3225"></a>3225 
</span><span class="uncovered1"><a name="line3226"></a>3226       margin  = @margin_right   # Margin in inches
</span><span class="uncovered0"><a name="line3227"></a>3227 
</span><span class="uncovered1"><a name="line3228"></a>3228       header  = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3229"></a>3229       data    = [margin].pack('d')
</span><span class="uncovered1"><a name="line3230"></a>3230 
</span><span class="uncovered0"><a name="line3231"></a>3231       data = data.reverse if @byte_order != 0
</span><span class="uncovered1"><a name="line3232"></a>3232 
</span><span class="uncovered0"><a name="line3233"></a>3233       prepend(header, data)
</span><span class="uncovered1"><a name="line3234"></a>3234    end
</span><span class="inferred0"><a name="line3235"></a>3235 
</span><span class="inferred1"><a name="line3236"></a>3236 
</span><span class="inferred0"><a name="line3237"></a>3237    ###############################################################################
</span><span class="inferred1"><a name="line3238"></a>3238    #
</span><span class="inferred0"><a name="line3239"></a>3239    # _store_margin_top()
</span><span class="inferred1"><a name="line3240"></a>3240    #
</span><span class="inferred0"><a name="line3241"></a>3241    # Store the TOPMARGIN BIFF record.
</span><span class="inferred1"><a name="line3242"></a>3242    #
</span><span class="marked0"><a name="line3243"></a>3243    def store_margin_top
</span><span class="uncovered1"><a name="line3244"></a>3244       record  = 0x0028                   # Record identifier
</span><span class="uncovered0"><a name="line3245"></a>3245       length  = 0x0008                   # Bytes to follow
</span><span class="uncovered1"><a name="line3246"></a>3246 
</span><span class="uncovered0"><a name="line3247"></a>3247       margin  = @margin_top     # Margin in inches
</span><span class="uncovered1"><a name="line3248"></a>3248 
</span><span class="uncovered0"><a name="line3249"></a>3249       header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line3250"></a>3250       data    = [margin].pack('d')
</span><span class="uncovered0"><a name="line3251"></a>3251 
</span><span class="uncovered1"><a name="line3252"></a>3252       data = data.reverse if @byte_order != 0
</span><span class="uncovered0"><a name="line3253"></a>3253 
</span><span class="uncovered1"><a name="line3254"></a>3254       prepend(header, data)
</span><span class="uncovered0"><a name="line3255"></a>3255    end
</span><span class="inferred1"><a name="line3256"></a>3256 
</span><span class="inferred0"><a name="line3257"></a>3257 
</span><span class="inferred1"><a name="line3258"></a>3258    ###############################################################################
</span><span class="inferred0"><a name="line3259"></a>3259    #
</span><span class="inferred1"><a name="line3260"></a>3260    # _store_margin_bottom()
</span><span class="inferred0"><a name="line3261"></a>3261    #
</span><span class="inferred1"><a name="line3262"></a>3262    # Store the BOTTOMMARGIN BIFF record.
</span><span class="inferred0"><a name="line3263"></a>3263    #
</span><span class="marked1"><a name="line3264"></a>3264    def store_margin_bottom
</span><span class="uncovered0"><a name="line3265"></a>3265       record  = 0x0029                   # Record identifier
</span><span class="uncovered1"><a name="line3266"></a>3266       length  = 0x0008                   # Bytes to follow
</span><span class="uncovered0"><a name="line3267"></a>3267 
</span><span class="uncovered1"><a name="line3268"></a>3268       margin  = @margin_bottom  # Margin in inches
</span><span class="uncovered0"><a name="line3269"></a>3269 
</span><span class="uncovered1"><a name="line3270"></a>3270       header  = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3271"></a>3271       data    = [margin].pack('d')
</span><span class="uncovered1"><a name="line3272"></a>3272 
</span><span class="uncovered0"><a name="line3273"></a>3273       data = data.reverse if @byte_order != 0
</span><span class="uncovered1"><a name="line3274"></a>3274 
</span><span class="uncovered0"><a name="line3275"></a>3275       prepend(header, data)
</span><span class="uncovered1"><a name="line3276"></a>3276    end
</span><span class="inferred0"><a name="line3277"></a>3277 
</span><span class="inferred1"><a name="line3278"></a>3278    ###############################################################################
</span><span class="inferred0"><a name="line3279"></a>3279    #
</span><span class="inferred1"><a name="line3280"></a>3280    # merge_cells($first_row, $first_col, $last_row, $last_col)
</span><span class="inferred0"><a name="line3281"></a>3281    #
</span><span class="inferred1"><a name="line3282"></a>3282    # This is an Excel97/2000 method. It is required to perform more complicated
</span><span class="inferred0"><a name="line3283"></a>3283    # merging than the normal align merge in Format.pm
</span><span class="inferred1"><a name="line3284"></a>3284    #
</span><span class="marked0"><a name="line3285"></a>3285    def merge_cells(*args)
</span><span class="inferred1"><a name="line3286"></a>3286       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line3287"></a>3287       if args[0] =~ /^\D/
</span><span class="inferred1"><a name="line3288"></a>3288          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line3289"></a>3289       end
</span><span class="inferred1"><a name="line3290"></a>3290 
</span><span class="marked0"><a name="line3291"></a>3291       record  = 0x00E5                    # Record identifier
</span><span class="marked1"><a name="line3292"></a>3292       length  = 0x000A                    # Bytes to follow
</span><span class="inferred0"><a name="line3293"></a>3293 
</span><span class="marked1"><a name="line3294"></a>3294       cref     = 1                        # Number of refs
</span><span class="marked0"><a name="line3295"></a>3295       rwFirst  = args[0]                  # First row in reference
</span><span class="marked1"><a name="line3296"></a>3296       colFirst = args[1]                  # First col in reference
</span><span class="marked0"><a name="line3297"></a>3297       rwLast   = args[2] || rwFirst       # Last  row in reference
</span><span class="marked1"><a name="line3298"></a>3298       colLast  = args[3] || colFirst      # Last  col in reference
</span><span class="inferred0"><a name="line3299"></a>3299 
</span><span class="inferred1"><a name="line3300"></a>3300       # Excel doesn't allow a single cell to be merged
</span><span class="marked0"><a name="line3301"></a>3301       return if rwFirst == rwLast and colFirst == colLast
</span><span class="inferred1"><a name="line3302"></a>3302 
</span><span class="inferred0"><a name="line3303"></a>3303       # Swap last row/col with first row/col as necessary
</span><span class="marked1"><a name="line3304"></a>3304       rwFirst,  rwLast  = rwLast,  rwFirst  if rwFirst  &gt; rwLast
</span><span class="marked0"><a name="line3305"></a>3305       colFirst, colLast = colLast, colFirst if colFirst &gt; colLast
</span><span class="inferred1"><a name="line3306"></a>3306 
</span><span class="marked0"><a name="line3307"></a>3307       header   = [record, length].pack(&quot;vv&quot;)
</span><span class="marked1"><a name="line3308"></a>3308       data     = [cref, rwFirst, rwLast, colFirst, colLast].pack(&quot;vvvvv&quot;)
</span><span class="inferred0"><a name="line3309"></a>3309 
</span><span class="marked1"><a name="line3310"></a>3310       append(header, data)
</span><span class="inferred0"><a name="line3311"></a>3311    end
</span><span class="inferred1"><a name="line3312"></a>3312 
</span><span class="inferred0"><a name="line3313"></a>3313    ###############################################################################
</span><span class="inferred1"><a name="line3314"></a>3314    #
</span><span class="inferred0"><a name="line3315"></a>3315    # merge_range($row1, $col1, $row2, $col2, $string, $format, $encoding)
</span><span class="inferred1"><a name="line3316"></a>3316    #
</span><span class="inferred0"><a name="line3317"></a>3317    # This is a wrapper to ensure correct use of the merge_cells method, i.e., write
</span><span class="inferred1"><a name="line3318"></a>3318    # the first cell of the range, write the formatted blank cells in the range and
</span><span class="inferred0"><a name="line3319"></a>3319    # then call the merge_cells record. Failing to do the steps in this order will
</span><span class="inferred1"><a name="line3320"></a>3320    # cause Excel 97 to crash.
</span><span class="inferred0"><a name="line3321"></a>3321    #
</span><span class="marked1"><a name="line3322"></a>3322    def merge_range(*args)
</span><span class="inferred0"><a name="line3323"></a>3323       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked1"><a name="line3324"></a>3324       if args[0] =~ /^\D/
</span><span class="marked0"><a name="line3325"></a>3325          args = substitute_cellref(*args)
</span><span class="inferred1"><a name="line3326"></a>3326       end
</span><span class="marked0"><a name="line3327"></a>3327       raise &quot;Incorrect number of arguments&quot; if args.size != 6 and args.size != 7
</span><span class="marked1"><a name="line3328"></a>3328       raise &quot;Format argument is not a format object&quot; unless args[5].kind_of?(Format)
</span><span class="inferred0"><a name="line3329"></a>3329 
</span><span class="marked1"><a name="line3330"></a>3330       rwFirst  = args[0]
</span><span class="marked0"><a name="line3331"></a>3331       colFirst = args[1]
</span><span class="marked1"><a name="line3332"></a>3332       rwLast   = args[2]
</span><span class="marked0"><a name="line3333"></a>3333       colLast  = args[3]
</span><span class="marked1"><a name="line3334"></a>3334       string   = args[4]
</span><span class="marked0"><a name="line3335"></a>3335       format   = args[5]
</span><span class="marked1"><a name="line3336"></a>3336       encoding = args[6] ? 1 : 0
</span><span class="inferred0"><a name="line3337"></a>3337 
</span><span class="inferred1"><a name="line3338"></a>3338       # Temp code to prevent merged formats in non-merged cells.
</span><span class="marked0"><a name="line3339"></a>3339       error = &quot;Error: refer to merge_range() in the documentation. &quot; +
</span><span class="inferred1"><a name="line3340"></a>3340         &quot;Can't use previously non-merged format in merged cells&quot;
</span><span class="inferred0"><a name="line3341"></a>3341 
</span><span class="marked1"><a name="line3342"></a>3342       raise error if format.used_merge == -1
</span><span class="marked0"><a name="line3343"></a>3343       format.used_merge = 0   # Until the end of this function.
</span><span class="inferred1"><a name="line3344"></a>3344 
</span><span class="inferred0"><a name="line3345"></a>3345       # Set the merge_range property of the format object. For BIFF8+.
</span><span class="marked1"><a name="line3346"></a>3346       format.set_merge_range
</span><span class="inferred0"><a name="line3347"></a>3347 
</span><span class="inferred1"><a name="line3348"></a>3348       # Excel doesn't allow a single cell to be merged
</span><span class="inferred0"><a name="line3349"></a>3349       raise &quot;Can't merge single cell&quot; if rwFirst  == rwLast and
</span><span class="marked1"><a name="line3350"></a>3350         colFirst == colLast
</span><span class="inferred0"><a name="line3351"></a>3351 
</span><span class="inferred1"><a name="line3352"></a>3352       # Swap last row/col with first row/col as necessary
</span><span class="marked0"><a name="line3353"></a>3353       rwFirst,  rwLast  = rwLast,  rwFirst  if rwFirst  &gt; rwLast
</span><span class="marked1"><a name="line3354"></a>3354       colFirst, colLast = colLast, colFirst if colFirst &gt; colLast
</span><span class="inferred0"><a name="line3355"></a>3355 
</span><span class="inferred1"><a name="line3356"></a>3356       # Write the first cell
</span><span class="marked0"><a name="line3357"></a>3357       if encoding != 0
</span><span class="uncovered1"><a name="line3358"></a>3358          write_utf16be_string(rwFirst, colFirst, string, format)
</span><span class="inferred0"><a name="line3359"></a>3359       else
</span><span class="marked1"><a name="line3360"></a>3360          write(rwFirst, colFirst, string, format)
</span><span class="inferred0"><a name="line3361"></a>3361       end
</span><span class="inferred1"><a name="line3362"></a>3362 
</span><span class="inferred0"><a name="line3363"></a>3363       # Pad out the rest of the area with formatted blank cells.
</span><span class="marked1"><a name="line3364"></a>3364       (rwFirst .. rwLast).each do |row|
</span><span class="marked0"><a name="line3365"></a>3365          (colFirst .. colLast).each do |col|
</span><span class="marked1"><a name="line3366"></a>3366             next if row == rwFirst and col == colFirst
</span><span class="marked0"><a name="line3367"></a>3367             write_blank(row, col, format)
</span><span class="inferred1"><a name="line3368"></a>3368          end
</span><span class="inferred0"><a name="line3369"></a>3369       end
</span><span class="inferred1"><a name="line3370"></a>3370 
</span><span class="marked0"><a name="line3371"></a>3371       merge_cells(rwFirst, colFirst, rwLast, colLast)
</span><span class="inferred1"><a name="line3372"></a>3372 
</span><span class="inferred0"><a name="line3373"></a>3373       # Temp code to prevent merged formats in non-merged cells.
</span><span class="marked1"><a name="line3374"></a>3374       format.used_merge = 1
</span><span class="inferred0"><a name="line3375"></a>3375    end
</span><span class="inferred1"><a name="line3376"></a>3376 
</span><span class="inferred0"><a name="line3377"></a>3377    ###############################################################################
</span><span class="inferred1"><a name="line3378"></a>3378    #
</span><span class="inferred0"><a name="line3379"></a>3379    # _store_print_headers()
</span><span class="inferred1"><a name="line3380"></a>3380    #
</span><span class="inferred0"><a name="line3381"></a>3381    # Write the PRINTHEADERS BIFF record.
</span><span class="inferred1"><a name="line3382"></a>3382    #
</span><span class="marked0"><a name="line3383"></a>3383    def store_print_headers
</span><span class="uncovered1"><a name="line3384"></a>3384       record      = 0x002a                   # Record identifier
</span><span class="uncovered0"><a name="line3385"></a>3385       length      = 0x0002                   # Bytes to follow
</span><span class="uncovered1"><a name="line3386"></a>3386 
</span><span class="uncovered0"><a name="line3387"></a>3387       fPrintRwCol = @print_headers           # Boolean flag
</span><span class="uncovered1"><a name="line3388"></a>3388 
</span><span class="uncovered0"><a name="line3389"></a>3389       header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line3390"></a>3390       data        = [fPrintRwCol].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line3391"></a>3391 
</span><span class="uncovered1"><a name="line3392"></a>3392       prepend(header, data)
</span><span class="uncovered0"><a name="line3393"></a>3393    end
</span><span class="inferred1"><a name="line3394"></a>3394 
</span><span class="inferred0"><a name="line3395"></a>3395    ###############################################################################
</span><span class="inferred1"><a name="line3396"></a>3396    #
</span><span class="inferred0"><a name="line3397"></a>3397    # _store_print_gridlines()
</span><span class="inferred1"><a name="line3398"></a>3398    #
</span><span class="inferred0"><a name="line3399"></a>3399    # Write the PRINTGRIDLINES BIFF record. Must be used in conjunction with the
</span><span class="inferred1"><a name="line3400"></a>3400    # GRIDSET record.
</span><span class="inferred0"><a name="line3401"></a>3401    #
</span><span class="marked1"><a name="line3402"></a>3402    def store_print_gridlines
</span><span class="uncovered0"><a name="line3403"></a>3403       record      = 0x002b                    # Record identifier
</span><span class="uncovered1"><a name="line3404"></a>3404       length      = 0x0002                    # Bytes to follow
</span><span class="uncovered0"><a name="line3405"></a>3405 
</span><span class="uncovered1"><a name="line3406"></a>3406       fPrintGrid  = @print_gridlines          # Boolean flag
</span><span class="uncovered0"><a name="line3407"></a>3407 
</span><span class="uncovered1"><a name="line3408"></a>3408       header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line3409"></a>3409       data        = [fPrintGrid].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line3410"></a>3410 
</span><span class="uncovered0"><a name="line3411"></a>3411       prepend(header, data)
</span><span class="uncovered1"><a name="line3412"></a>3412    end
</span><span class="inferred0"><a name="line3413"></a>3413 
</span><span class="inferred1"><a name="line3414"></a>3414    ###############################################################################
</span><span class="inferred0"><a name="line3415"></a>3415    #
</span><span class="inferred1"><a name="line3416"></a>3416    # _store_gridset()
</span><span class="inferred0"><a name="line3417"></a>3417    #
</span><span class="inferred1"><a name="line3418"></a>3418    # Write the GRIDSET BIFF record. Must be used in conjunction with the
</span><span class="inferred0"><a name="line3419"></a>3419    # PRINTGRIDLINES record.
</span><span class="inferred1"><a name="line3420"></a>3420    #
</span><span class="marked0"><a name="line3421"></a>3421    def store_gridset
</span><span class="uncovered1"><a name="line3422"></a>3422       record      = 0x0082                        # Record identifier
</span><span class="uncovered0"><a name="line3423"></a>3423       length      = 0x0002                        # Bytes to follow
</span><span class="uncovered1"><a name="line3424"></a>3424 
</span><span class="uncovered0"><a name="line3425"></a>3425       fGridSet    = !@print_gridlines          # Boolean flag
</span><span class="uncovered1"><a name="line3426"></a>3426 
</span><span class="uncovered0"><a name="line3427"></a>3427       header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line3428"></a>3428       data        = [fGridSet].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line3429"></a>3429 
</span><span class="uncovered1"><a name="line3430"></a>3430       prepend(header, data)
</span><span class="uncovered0"><a name="line3431"></a>3431    end
</span><span class="inferred1"><a name="line3432"></a>3432    
</span><span class="inferred0"><a name="line3433"></a>3433    ###############################################################################
</span><span class="inferred1"><a name="line3434"></a>3434    #
</span><span class="inferred0"><a name="line3435"></a>3435    # _store_guts()
</span><span class="inferred1"><a name="line3436"></a>3436    #
</span><span class="inferred0"><a name="line3437"></a>3437    # Write the GUTS BIFF record. This is used to configure the gutter margins
</span><span class="inferred1"><a name="line3438"></a>3438    # where Excel outline symbols are displayed. The visibility of the gutters is
</span><span class="inferred0"><a name="line3439"></a>3439    # controlled by a flag in WSBOOL. See also _store_wsbool().
</span><span class="inferred1"><a name="line3440"></a>3440    #
</span><span class="inferred0"><a name="line3441"></a>3441    # We are all in the gutter but some of us are looking at the stars.
</span><span class="inferred1"><a name="line3442"></a>3442    #
</span><span class="marked0"><a name="line3443"></a>3443    def store_guts
</span><span class="uncovered1"><a name="line3444"></a>3444       record      = 0x0080   # Record identifier
</span><span class="uncovered0"><a name="line3445"></a>3445       length      = 0x0008   # Bytes to follow
</span><span class="uncovered1"><a name="line3446"></a>3446 
</span><span class="uncovered0"><a name="line3447"></a>3447       dxRwGut     = 0x0000   # Size of row gutter
</span><span class="uncovered1"><a name="line3448"></a>3448       dxColGut    = 0x0000   # Size of col gutter
</span><span class="uncovered0"><a name="line3449"></a>3449 
</span><span class="uncovered1"><a name="line3450"></a>3450       row_level   = @outline_row_level
</span><span class="uncovered0"><a name="line3451"></a>3451       col_level   = 0
</span><span class="uncovered1"><a name="line3452"></a>3452 
</span><span class="uncovered0"><a name="line3453"></a>3453 
</span><span class="uncovered1"><a name="line3454"></a>3454       # Calculate the maximum column outline level. The equivalent calculation
</span><span class="uncovered0"><a name="line3455"></a>3455       # for the row outline level is carried out in set_row().
</span><span class="uncovered1"><a name="line3456"></a>3456       #
</span><span class="uncovered0"><a name="line3457"></a>3457       @colinfo.each do |colinfo|
</span><span class="uncovered1"><a name="line3458"></a>3458          # Skip cols without outline level info.
</span><span class="uncovered0"><a name="line3459"></a>3459          next if colinfo.size &lt; 6
</span><span class="uncovered1"><a name="line3460"></a>3460          col_level = colinfo[5] if colinfo[5] &gt; col_level
</span><span class="uncovered0"><a name="line3461"></a>3461       end
</span><span class="uncovered1"><a name="line3462"></a>3462 
</span><span class="uncovered0"><a name="line3463"></a>3463       # Set the limits for the outline levels (0 &lt;= x &lt;= 7).
</span><span class="uncovered1"><a name="line3464"></a>3464       col_level = 0 if col_level &lt; 0
</span><span class="uncovered0"><a name="line3465"></a>3465       col_level = 7 if col_level &gt; 7
</span><span class="uncovered1"><a name="line3466"></a>3466 
</span><span class="uncovered0"><a name="line3467"></a>3467       # The displayed level is one greater than the max outline levels
</span><span class="uncovered1"><a name="line3468"></a>3468       row_level = row_level + 1 if row_level &gt; 0
</span><span class="uncovered0"><a name="line3469"></a>3469       col_level = col_level + 1 if col_level &gt; 0
</span><span class="uncovered1"><a name="line3470"></a>3470 
</span><span class="uncovered0"><a name="line3471"></a>3471       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line3472"></a>3472       data   = [dxRwGut, dxColGut, row_level, col_level].pack(&quot;vvvv&quot;)
</span><span class="uncovered0"><a name="line3473"></a>3473 
</span><span class="uncovered1"><a name="line3474"></a>3474       prepend(header, data)
</span><span class="uncovered0"><a name="line3475"></a>3475    end
</span><span class="inferred1"><a name="line3476"></a>3476 
</span><span class="inferred0"><a name="line3477"></a>3477    ###############################################################################
</span><span class="inferred1"><a name="line3478"></a>3478    #
</span><span class="inferred0"><a name="line3479"></a>3479    # _store_wsbool()
</span><span class="inferred1"><a name="line3480"></a>3480    #
</span><span class="inferred0"><a name="line3481"></a>3481    # Write the WSBOOL BIFF record, mainly for fit-to-page. Used in conjunction
</span><span class="inferred1"><a name="line3482"></a>3482    # with the SETUP record.
</span><span class="inferred0"><a name="line3483"></a>3483    #
</span><span class="marked1"><a name="line3484"></a>3484    def store_wsbool
</span><span class="uncovered0"><a name="line3485"></a>3485       record      = 0x0081   # Record identifier
</span><span class="uncovered1"><a name="line3486"></a>3486       length      = 0x0002   # Bytes to follow
</span><span class="uncovered0"><a name="line3487"></a>3487    
</span><span class="uncovered1"><a name="line3488"></a>3488       grbit       = 0x0000   # Option flags
</span><span class="uncovered0"><a name="line3489"></a>3489    
</span><span class="uncovered1"><a name="line3490"></a>3490       # Set the option flags
</span><span class="uncovered0"><a name="line3491"></a>3491       grbit |= 0x0001                        # Auto page breaks visible
</span><span class="uncovered1"><a name="line3492"></a>3492       grbit |= 0x0020 if @outline_style != 0 # Auto outline styles
</span><span class="uncovered0"><a name="line3493"></a>3493       grbit |= 0x0040 if @outline_below != 0 # Outline summary below
</span><span class="uncovered1"><a name="line3494"></a>3494       grbit |= 0x0080 if @outline_right != 0 # Outline summary right
</span><span class="uncovered0"><a name="line3495"></a>3495       grbit |= 0x0100 if @fit_page      != 0 # Page setup fit to page
</span><span class="uncovered1"><a name="line3496"></a>3496       grbit |= 0x0400 if @outline_on    != 0 # Outline symbols displayed
</span><span class="uncovered0"><a name="line3497"></a>3497    
</span><span class="uncovered1"><a name="line3498"></a>3498       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line3499"></a>3499       data   = [grbit].pack('v')
</span><span class="uncovered1"><a name="line3500"></a>3500    
</span><span class="uncovered0"><a name="line3501"></a>3501       prepend(header, data)
</span><span class="uncovered1"><a name="line3502"></a>3502    end
</span><span class="inferred0"><a name="line3503"></a>3503    
</span><span class="inferred1"><a name="line3504"></a>3504    ###############################################################################
</span><span class="inferred0"><a name="line3505"></a>3505    #
</span><span class="inferred1"><a name="line3506"></a>3506    # _store_hbreak()
</span><span class="inferred0"><a name="line3507"></a>3507    #
</span><span class="inferred1"><a name="line3508"></a>3508    # Write the HORIZONTALPAGEBREAKS BIFF record.
</span><span class="inferred0"><a name="line3509"></a>3509    #
</span><span class="marked1"><a name="line3510"></a>3510    def store_hbreak
</span><span class="uncovered0"><a name="line3511"></a>3511       # Return if the user hasn't specified pagebreaks
</span><span class="uncovered1"><a name="line3512"></a>3512       return if @hbreaks.size == 0
</span><span class="uncovered0"><a name="line3513"></a>3513    
</span><span class="uncovered1"><a name="line3514"></a>3514       # Sort and filter array of page breaks
</span><span class="uncovered0"><a name="line3515"></a>3515       breaks  = sort_pagebreaks(@hbreaks)
</span><span class="uncovered1"><a name="line3516"></a>3516    
</span><span class="uncovered0"><a name="line3517"></a>3517       record  = 0x001b               # Record identifier
</span><span class="uncovered1"><a name="line3518"></a>3518       cbrk    = breaks.size          # Number of page breaks
</span><span class="uncovered0"><a name="line3519"></a>3519       length  = 2 + 6 * cbrk         # Bytes to follow
</span><span class="uncovered1"><a name="line3520"></a>3520    
</span><span class="uncovered0"><a name="line3521"></a>3521       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line3522"></a>3522       data   = [cbrk].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line3523"></a>3523 
</span><span class="uncovered1"><a name="line3524"></a>3524       # Append each page break
</span><span class="uncovered0"><a name="line3525"></a>3525       breaks.each do |brk|
</span><span class="uncovered1"><a name="line3526"></a>3526          data = data + [brk, 0x0000, 0x00ff].pack(&quot;vvv&quot;)
</span><span class="uncovered0"><a name="line3527"></a>3527       end
</span><span class="uncovered1"><a name="line3528"></a>3528    
</span><span class="uncovered0"><a name="line3529"></a>3529       prepend(header, data)
</span><span class="uncovered1"><a name="line3530"></a>3530    end
</span><span class="inferred0"><a name="line3531"></a>3531    
</span><span class="inferred1"><a name="line3532"></a>3532    ###############################################################################
</span><span class="inferred0"><a name="line3533"></a>3533    #
</span><span class="inferred1"><a name="line3534"></a>3534    # _store_vbreak()
</span><span class="inferred0"><a name="line3535"></a>3535    #
</span><span class="inferred1"><a name="line3536"></a>3536    # Write the VERTICALPAGEBREAKS BIFF record.
</span><span class="inferred0"><a name="line3537"></a>3537    #
</span><span class="marked1"><a name="line3538"></a>3538    def store_vbreak
</span><span class="uncovered0"><a name="line3539"></a>3539       # Return if the user hasn't specified pagebreaks
</span><span class="uncovered1"><a name="line3540"></a>3540       return if @vbreaks.size == 0
</span><span class="uncovered0"><a name="line3541"></a>3541    
</span><span class="uncovered1"><a name="line3542"></a>3542       # Sort and filter array of page breaks
</span><span class="uncovered0"><a name="line3543"></a>3543       breaks  = sort_pagebreaks(@vbreaks)
</span><span class="uncovered1"><a name="line3544"></a>3544    
</span><span class="uncovered0"><a name="line3545"></a>3545       record  = 0x001a               # Record identifier
</span><span class="uncovered1"><a name="line3546"></a>3546       cbrk    = breaks.size          # Number of page breaks
</span><span class="uncovered0"><a name="line3547"></a>3547       length  = 2 + 6*cbrk           # Bytes to follow
</span><span class="uncovered1"><a name="line3548"></a>3548    
</span><span class="uncovered0"><a name="line3549"></a>3549       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line3550"></a>3550       data   = [cbrk].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line3551"></a>3551    
</span><span class="uncovered1"><a name="line3552"></a>3552       # Append each page break
</span><span class="uncovered0"><a name="line3553"></a>3553       breaks.each do |brk|
</span><span class="uncovered1"><a name="line3554"></a>3554          data = data + [brk, 0x0000, 0x00ff].pack(&quot;vvv&quot;)
</span><span class="uncovered0"><a name="line3555"></a>3555       end
</span><span class="uncovered1"><a name="line3556"></a>3556    
</span><span class="uncovered0"><a name="line3557"></a>3557       prepend(header, data)
</span><span class="uncovered1"><a name="line3558"></a>3558    end
</span><span class="inferred0"><a name="line3559"></a>3559    
</span><span class="inferred1"><a name="line3560"></a>3560    
</span><span class="inferred0"><a name="line3561"></a>3561    ###############################################################################
</span><span class="inferred1"><a name="line3562"></a>3562    #
</span><span class="inferred0"><a name="line3563"></a>3563    # _store_protect()
</span><span class="inferred1"><a name="line3564"></a>3564    #
</span><span class="inferred0"><a name="line3565"></a>3565    # Set the Biff PROTECT record to indicate that the worksheet is protected.
</span><span class="inferred1"><a name="line3566"></a>3566    #
</span><span class="marked0"><a name="line3567"></a>3567    def store_protect
</span><span class="uncovered1"><a name="line3568"></a>3568       # Exit unless sheet protection has been specified
</span><span class="uncovered0"><a name="line3569"></a>3569       return if @protect == 0
</span><span class="uncovered1"><a name="line3570"></a>3570    
</span><span class="uncovered0"><a name="line3571"></a>3571       record      = 0x0012               # Record identifier
</span><span class="uncovered1"><a name="line3572"></a>3572       length      = 0x0002               # Bytes to follow
</span><span class="uncovered0"><a name="line3573"></a>3573    
</span><span class="uncovered1"><a name="line3574"></a>3574       fLock       = @protect             # Worksheet is protected
</span><span class="uncovered0"><a name="line3575"></a>3575    
</span><span class="uncovered1"><a name="line3576"></a>3576       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line3577"></a>3577       data   = [fLock].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line3578"></a>3578    
</span><span class="uncovered0"><a name="line3579"></a>3579       prepend(header, data)
</span><span class="uncovered1"><a name="line3580"></a>3580    end
</span><span class="inferred0"><a name="line3581"></a>3581    
</span><span class="inferred1"><a name="line3582"></a>3582    ###############################################################################
</span><span class="inferred0"><a name="line3583"></a>3583    #
</span><span class="inferred1"><a name="line3584"></a>3584    # _store_obj_protect()
</span><span class="inferred0"><a name="line3585"></a>3585    #
</span><span class="inferred1"><a name="line3586"></a>3586    # Set the Biff OBJPROTECT record to indicate that objects are protected.
</span><span class="inferred0"><a name="line3587"></a>3587    #
</span><span class="marked1"><a name="line3588"></a>3588    def store_obj_protect
</span><span class="uncovered0"><a name="line3589"></a>3589       # Exit unless sheet protection has been specified
</span><span class="uncovered1"><a name="line3590"></a>3590       return if @protect == 0
</span><span class="uncovered0"><a name="line3591"></a>3591    
</span><span class="uncovered1"><a name="line3592"></a>3592       record      = 0x0063               # Record identifier
</span><span class="uncovered0"><a name="line3593"></a>3593       length      = 0x0002               # Bytes to follow
</span><span class="uncovered1"><a name="line3594"></a>3594    
</span><span class="uncovered0"><a name="line3595"></a>3595       fLock       = @protect             # Worksheet is protected
</span><span class="uncovered1"><a name="line3596"></a>3596    
</span><span class="uncovered0"><a name="line3597"></a>3597       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line3598"></a>3598       data   = [fLock].pack(&quot;v&quot;)
</span><span class="uncovered0"><a name="line3599"></a>3599    
</span><span class="uncovered1"><a name="line3600"></a>3600       prepend(header, data)
</span><span class="uncovered0"><a name="line3601"></a>3601    end
</span><span class="inferred1"><a name="line3602"></a>3602    
</span><span class="inferred0"><a name="line3603"></a>3603    ###############################################################################
</span><span class="inferred1"><a name="line3604"></a>3604    #
</span><span class="inferred0"><a name="line3605"></a>3605    # _store_password()
</span><span class="inferred1"><a name="line3606"></a>3606    #
</span><span class="inferred0"><a name="line3607"></a>3607    # Write the worksheet PASSWORD record.
</span><span class="inferred1"><a name="line3608"></a>3608    #
</span><span class="marked0"><a name="line3609"></a>3609    def store_password
</span><span class="uncovered1"><a name="line3610"></a>3610       # Exit unless sheet protection and password have been specified
</span><span class="uncovered0"><a name="line3611"></a>3611       return if (@protect == 0 or @password.nil?)
</span><span class="uncovered1"><a name="line3612"></a>3612    
</span><span class="uncovered0"><a name="line3613"></a>3613       record      = 0x0013               # Record identifier
</span><span class="uncovered1"><a name="line3614"></a>3614       length      = 0x0002               # Bytes to follow
</span><span class="uncovered0"><a name="line3615"></a>3615    
</span><span class="uncovered1"><a name="line3616"></a>3616       wPassword   = @password            # Encoded password
</span><span class="uncovered0"><a name="line3617"></a>3617    
</span><span class="uncovered1"><a name="line3618"></a>3618       header = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line3619"></a>3619       data   = [wPassword].pack(&quot;v&quot;)
</span><span class="uncovered1"><a name="line3620"></a>3620    
</span><span class="uncovered0"><a name="line3621"></a>3621       prepend(header, data)
</span><span class="uncovered1"><a name="line3622"></a>3622    end
</span><span class="inferred0"><a name="line3623"></a>3623    
</span><span class="inferred1"><a name="line3624"></a>3624    #
</span><span class="inferred0"><a name="line3625"></a>3625    # Note about compatibility mode.
</span><span class="inferred1"><a name="line3626"></a>3626    #
</span><span class="inferred0"><a name="line3627"></a>3627    # Excel doesn't require every possible Biff record to be present in a file.
</span><span class="inferred1"><a name="line3628"></a>3628    # In particular if the indexing records INDEX, ROW and DBCELL aren't present
</span><span class="inferred0"><a name="line3629"></a>3629    # it just ignores the fact and reads the cells anyway. This is also true of
</span><span class="inferred1"><a name="line3630"></a>3630    # the EXTSST record. Gnumeric and OOo also take this approach. This allows
</span><span class="inferred0"><a name="line3631"></a>3631    # WriteExcel to ignore these records in order to minimise the amount of data
</span><span class="inferred1"><a name="line3632"></a>3632    # stored in memory. However, other third party applications that read Excel
</span><span class="inferred0"><a name="line3633"></a>3633    # files often expect these records to be present. In &quot;compatibility mode&quot;
</span><span class="inferred1"><a name="line3634"></a>3634    # WriteExcel writes these records and tries to be as close to an Excel
</span><span class="inferred0"><a name="line3635"></a>3635    # generated file as possible.
</span><span class="inferred1"><a name="line3636"></a>3636    #
</span><span class="inferred0"><a name="line3637"></a>3637    # This requires additional data to be stored in memory until the file is
</span><span class="inferred1"><a name="line3638"></a>3638    # about to be written. This incurs a memory and speed penalty and may not be
</span><span class="inferred0"><a name="line3639"></a>3639    # suitable for very large files.
</span><span class="inferred1"><a name="line3640"></a>3640    #
</span><span class="inferred0"><a name="line3641"></a>3641    
</span><span class="inferred1"><a name="line3642"></a>3642    
</span><span class="inferred0"><a name="line3643"></a>3643    
</span><span class="inferred1"><a name="line3644"></a>3644    ###############################################################################
</span><span class="inferred0"><a name="line3645"></a>3645    #
</span><span class="inferred1"><a name="line3646"></a>3646    # _store_table()
</span><span class="inferred0"><a name="line3647"></a>3647    #
</span><span class="inferred1"><a name="line3648"></a>3648    # Write cell data stored in the worksheet row/col table.
</span><span class="inferred0"><a name="line3649"></a>3649    #
</span><span class="inferred1"><a name="line3650"></a>3650    # This is only used when compatibity_mode() is in operation.
</span><span class="inferred0"><a name="line3651"></a>3651    #
</span><span class="inferred1"><a name="line3652"></a>3652    # This method writes ROW data, then cell data (NUMBER, LABELSST, etc) and then
</span><span class="inferred0"><a name="line3653"></a>3653    # DBCELL records in blocks of 32 rows. This is explained in detail (for a
</span><span class="inferred1"><a name="line3654"></a>3654    # change) in the Excel SDK and in the OOo Excel file format doc.
</span><span class="inferred0"><a name="line3655"></a>3655    #
</span><span class="marked1"><a name="line3656"></a>3656    def store_table
</span><span class="uncovered0"><a name="line3657"></a>3657       return if @compatibility == 0
</span><span class="uncovered1"><a name="line3658"></a>3658    
</span><span class="uncovered0"><a name="line3659"></a>3659       # Offset from the DBCELL record back to the first ROW of the 32 row block.
</span><span class="uncovered1"><a name="line3660"></a>3660       row_offset = 0
</span><span class="uncovered0"><a name="line3661"></a>3661    
</span><span class="uncovered1"><a name="line3662"></a>3662       # Track rows that have cell data or modified by set_row().
</span><span class="uncovered0"><a name="line3663"></a>3663       written_rows = []
</span><span class="uncovered1"><a name="line3664"></a>3664    
</span><span class="uncovered0"><a name="line3665"></a>3665    
</span><span class="uncovered1"><a name="line3666"></a>3666       # Write the ROW records with updated max/min col fields.
</span><span class="uncovered0"><a name="line3667"></a>3667       #
</span><span class="uncovered1"><a name="line3668"></a>3668       (0 .. @dim_rowmax-1).each do |row|
</span><span class="uncovered0"><a name="line3669"></a>3669          # Skip unless there is cell data in row or the row has been modified.
</span><span class="uncovered1"><a name="line3670"></a>3670          next unless @table[row] or @row_data[row]
</span><span class="uncovered0"><a name="line3671"></a>3671    
</span><span class="uncovered1"><a name="line3672"></a>3672          # Store the rows with data.
</span><span class="uncovered0"><a name="line3673"></a>3673          written_rows.push(row)
</span><span class="uncovered1"><a name="line3674"></a>3674    
</span><span class="uncovered0"><a name="line3675"></a>3675          # Increase the row offset by the length of a ROW record;
</span><span class="uncovered1"><a name="line3676"></a>3676          row_offset += 20
</span><span class="uncovered0"><a name="line3677"></a>3677    
</span><span class="uncovered1"><a name="line3678"></a>3678          # The max/min cols in the ROW records are the same as in DIMENSIONS.
</span><span class="uncovered0"><a name="line3679"></a>3679          col_min = @dim_colmin
</span><span class="uncovered1"><a name="line3680"></a>3680          col_max = @dim_colmax
</span><span class="uncovered0"><a name="line3681"></a>3681    
</span><span class="uncovered1"><a name="line3682"></a>3682          # Write a user specifed ROW record (modified by set_row()).
</span><span class="uncovered0"><a name="line3683"></a>3683          if @row_data[row]
</span><span class="uncovered1"><a name="line3684"></a>3684             # Rewrite the min and max cols for user defined row record.
</span><span class="uncovered0"><a name="line3685"></a>3685             packed_row = @row_data[row]
</span><span class="uncovered1"><a name="line3686"></a>3686             packed_row[6..9] = [col_min, col_max].pack('vv')
</span><span class="uncovered0"><a name="line3687"></a>3687             append(packed_row)
</span><span class="uncovered1"><a name="line3688"></a>3688          else
</span><span class="uncovered0"><a name="line3689"></a>3689             # Write a default Row record if there isn't a  user defined ROW.
</span><span class="uncovered1"><a name="line3690"></a>3690             write_row_default(row, col_min, col_max)
</span><span class="uncovered0"><a name="line3691"></a>3691          end
</span><span class="uncovered1"><a name="line3692"></a>3692    
</span><span class="uncovered0"><a name="line3693"></a>3693          # If 32 rows have been written or we are at the last row in the
</span><span class="uncovered1"><a name="line3694"></a>3694          # worksheet then write the cell data and the DBCELL record.
</span><span class="uncovered0"><a name="line3695"></a>3695          #
</span><span class="uncovered1"><a name="line3696"></a>3696          if written_rows.size == 32 or row == @dim_rowmax -1
</span><span class="uncovered0"><a name="line3697"></a>3697             # Offsets to the first cell of each row.
</span><span class="uncovered1"><a name="line3698"></a>3698             cell_offsets = []
</span><span class="uncovered0"><a name="line3699"></a>3699             cell_offsets.push(row_offset - 20)
</span><span class="uncovered1"><a name="line3700"></a>3700    
</span><span class="uncovered0"><a name="line3701"></a>3701             # Write the cell data in each row and sum their lengths for the
</span><span class="uncovered1"><a name="line3702"></a>3702             # cell offsets.
</span><span class="uncovered0"><a name="line3703"></a>3703             #
</span><span class="uncovered1"><a name="line3704"></a>3704             written_rows.each do |row|
</span><span class="uncovered0"><a name="line3705"></a>3705                cell_offset = 0
</span><span class="uncovered1"><a name="line3706"></a>3706    
</span><span class="uncovered0"><a name="line3707"></a>3707                    
</span><span class="uncovered1"><a name="line3708"></a>3708                @table[row].each do |col|
</span><span class="uncovered0"><a name="line3709"></a>3709                   next unless col
</span><span class="uncovered1"><a name="line3710"></a>3710                   append(col)
</span><span class="uncovered0"><a name="line3711"></a>3711                   ength = col.length
</span><span class="uncovered1"><a name="line3712"></a>3712                   row_offset  = row_offset  + length
</span><span class="uncovered0"><a name="line3713"></a>3713                   cell_offset = cell_offset + length
</span><span class="uncovered1"><a name="line3714"></a>3714                end
</span><span class="uncovered0"><a name="line3715"></a>3715                cell_offsets.push(cell_offset)
</span><span class="uncovered1"><a name="line3716"></a>3716             end
</span><span class="uncovered0"><a name="line3717"></a>3717    
</span><span class="uncovered1"><a name="line3718"></a>3718             # The last offset isn't required.
</span><span class="uncovered0"><a name="line3719"></a>3719             cell_offsets.pop
</span><span class="uncovered1"><a name="line3720"></a>3720    
</span><span class="uncovered0"><a name="line3721"></a>3721             # Stores the DBCELL offset for use in the INDEX record.
</span><span class="uncovered1"><a name="line3722"></a>3722             @db_indices.push(@datasize)
</span><span class="uncovered0"><a name="line3723"></a>3723    
</span><span class="uncovered1"><a name="line3724"></a>3724             # Write the DBCELL record.
</span><span class="uncovered0"><a name="line3725"></a>3725             store_dbcell(row_offset, cell_offsets)
</span><span class="uncovered1"><a name="line3726"></a>3726    
</span><span class="uncovered0"><a name="line3727"></a>3727             # Clear the variable for the next block of rows.
</span><span class="uncovered1"><a name="line3728"></a>3728             written_rows   = []
</span><span class="uncovered0"><a name="line3729"></a>3729             cell_offsets   = []
</span><span class="uncovered1"><a name="line3730"></a>3730             row_offset     = 0
</span><span class="uncovered0"><a name="line3731"></a>3731          end
</span><span class="uncovered1"><a name="line3732"></a>3732       end
</span><span class="uncovered0"><a name="line3733"></a>3733    end
</span><span class="inferred1"><a name="line3734"></a>3734    
</span><span class="inferred0"><a name="line3735"></a>3735    ###############################################################################
</span><span class="inferred1"><a name="line3736"></a>3736    #
</span><span class="inferred0"><a name="line3737"></a>3737    # _store_dbcell()
</span><span class="inferred1"><a name="line3738"></a>3738    #
</span><span class="inferred0"><a name="line3739"></a>3739    # Store the DBCELL record using the offset calculated in _store_table().
</span><span class="inferred1"><a name="line3740"></a>3740    #
</span><span class="inferred0"><a name="line3741"></a>3741    # This is only used when compatibity_mode() is in operation.
</span><span class="inferred1"><a name="line3742"></a>3742    #
</span><span class="marked0"><a name="line3743"></a>3743    def store_dbcell(row_offset, cell_offsets)
</span><span class="uncovered1"><a name="line3744"></a>3744       record          = 0x00D7                     # Record identifier
</span><span class="uncovered0"><a name="line3745"></a>3745       length          = 4 + 2 * cell_offsets.size  # Bytes to follow
</span><span class="uncovered1"><a name="line3746"></a>3746    
</span><span class="uncovered0"><a name="line3747"></a>3747       header          = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line3748"></a>3748       data            = [row_offset].pack('V')
</span><span class="uncovered0"><a name="line3749"></a>3749       cell_offsets.each do |co|
</span><span class="uncovered1"><a name="line3750"></a>3750          data = data + [co].pack('v')
</span><span class="uncovered0"><a name="line3751"></a>3751       end
</span><span class="uncovered1"><a name="line3752"></a>3752    
</span><span class="uncovered0"><a name="line3753"></a>3753       append(header, data)
</span><span class="uncovered1"><a name="line3754"></a>3754    end
</span><span class="inferred0"><a name="line3755"></a>3755    
</span><span class="inferred1"><a name="line3756"></a>3756    
</span><span class="inferred0"><a name="line3757"></a>3757    ###############################################################################
</span><span class="inferred1"><a name="line3758"></a>3758    #
</span><span class="inferred0"><a name="line3759"></a>3759    # _store_index()
</span><span class="inferred1"><a name="line3760"></a>3760    #
</span><span class="inferred0"><a name="line3761"></a>3761    # Store the INDEX record using the DBCELL offsets calculated in _store_table().
</span><span class="inferred1"><a name="line3762"></a>3762    #
</span><span class="inferred0"><a name="line3763"></a>3763    # This is only used when compatibity_mode() is in operation.
</span><span class="inferred1"><a name="line3764"></a>3764    #
</span><span class="marked0"><a name="line3765"></a>3765    def store_index
</span><span class="uncovered1"><a name="line3766"></a>3766       return if @compatibility == 0
</span><span class="uncovered0"><a name="line3767"></a>3767    
</span><span class="uncovered1"><a name="line3768"></a>3768       indices     = @db_indices
</span><span class="uncovered0"><a name="line3769"></a>3769       reserved    = 0x00000000
</span><span class="uncovered1"><a name="line3770"></a>3770       row_min     = @dim_rowmin
</span><span class="uncovered0"><a name="line3771"></a>3771       row_max     = @dim_rowmax
</span><span class="uncovered1"><a name="line3772"></a>3772    
</span><span class="uncovered0"><a name="line3773"></a>3773       record      = 0x020B                 # Record identifier
</span><span class="uncovered1"><a name="line3774"></a>3774       length      = 16 + 4 * indices.size  # Bytes to follow
</span><span class="uncovered0"><a name="line3775"></a>3775    
</span><span class="uncovered1"><a name="line3776"></a>3776       header      = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line3777"></a>3777       data        = [reserved, row_min, row_max, reserved].pack('VVVV')
</span><span class="uncovered1"><a name="line3778"></a>3778    
</span><span class="uncovered0"><a name="line3779"></a>3779       indices.each do |index|
</span><span class="uncovered1"><a name="line3780"></a>3780          data = data + [index + @offset + 20 + length + 4].pack('V')
</span><span class="uncovered0"><a name="line3781"></a>3781       end
</span><span class="uncovered1"><a name="line3782"></a>3782    
</span><span class="uncovered0"><a name="line3783"></a>3783       prepend(header, data)
</span><span class="uncovered1"><a name="line3784"></a>3784    end
</span><span class="inferred0"><a name="line3785"></a>3785 
</span><span class="inferred1"><a name="line3786"></a>3786    ###############################################################################
</span><span class="inferred0"><a name="line3787"></a>3787    #
</span><span class="inferred1"><a name="line3788"></a>3788    # embed_chart($row, $col, $filename, $x, $y, $scale_x, $scale_y)
</span><span class="inferred0"><a name="line3789"></a>3789    #
</span><span class="inferred1"><a name="line3790"></a>3790    # Embed an extracted chart in a worksheet.
</span><span class="inferred0"><a name="line3791"></a>3791    #
</span><span class="marked1"><a name="line3792"></a>3792    def embed_chart(*args)
</span><span class="uncovered0"><a name="line3793"></a>3793       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered1"><a name="line3794"></a>3794       if args[0] =~ /^\D/
</span><span class="uncovered0"><a name="line3795"></a>3795          args = substitute_cellref(*args)
</span><span class="uncovered1"><a name="line3796"></a>3796       end
</span><span class="uncovered0"><a name="line3797"></a>3797    
</span><span class="uncovered1"><a name="line3798"></a>3798       row         = args[0]
</span><span class="uncovered0"><a name="line3799"></a>3799       col         = args[1]
</span><span class="uncovered1"><a name="line3800"></a>3800       chart       = args[2]
</span><span class="uncovered0"><a name="line3801"></a>3801       x_offset    = args[3] || 0
</span><span class="uncovered1"><a name="line3802"></a>3802       y_offset    = args[4] || 0
</span><span class="uncovered0"><a name="line3803"></a>3803       scale_x     = args[5] || 1
</span><span class="uncovered1"><a name="line3804"></a>3804       scale_y     = args[6] || 1
</span><span class="uncovered0"><a name="line3805"></a>3805    
</span><span class="uncovered1"><a name="line3806"></a>3806       raise &quot;Insufficient arguments in embed_chart()&quot; unless args.size &gt;= 3
</span><span class="uncovered0"><a name="line3807"></a>3807       #       raise &quot;Couldn't locate $chart: $!&quot;              unless -e $chart;
</span><span class="uncovered1"><a name="line3808"></a>3808    
</span><span class="uncovered0"><a name="line3809"></a>3809       @charts[row][col] =  [row, col, chart,
</span><span class="uncovered1"><a name="line3810"></a>3810          x_offset, y_offset, scale_x, scale_y, ]
</span><span class="uncovered0"><a name="line3811"></a>3811    
</span><span class="uncovered1"><a name="line3812"></a>3812    end
</span><span class="inferred0"><a name="line3813"></a>3813    
</span><span class="inferred1"><a name="line3814"></a>3814    ###############################################################################
</span><span class="inferred0"><a name="line3815"></a>3815    #
</span><span class="inferred1"><a name="line3816"></a>3816    # insert_image($row, $col, $filename, $x, $y, $scale_x, $scale_y)
</span><span class="inferred0"><a name="line3817"></a>3817    #
</span><span class="inferred1"><a name="line3818"></a>3818    # Insert an image into the worksheet.
</span><span class="inferred0"><a name="line3819"></a>3819    #
</span><span class="marked1"><a name="line3820"></a>3820    def insert_image(*args)
</span><span class="uncovered0"><a name="line3821"></a>3821       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered1"><a name="line3822"></a>3822       if args[0] =~ /^\D/
</span><span class="uncovered0"><a name="line3823"></a>3823          args = substitute_cellref(*args)
</span><span class="uncovered1"><a name="line3824"></a>3824       end
</span><span class="uncovered0"><a name="line3825"></a>3825    
</span><span class="uncovered1"><a name="line3826"></a>3826       row         = args[0]
</span><span class="uncovered0"><a name="line3827"></a>3827       col         = args[1]
</span><span class="uncovered1"><a name="line3828"></a>3828       image       = args[2]
</span><span class="uncovered0"><a name="line3829"></a>3829       x_offset    = args[3] || 0
</span><span class="uncovered1"><a name="line3830"></a>3830       y_offset    = args[4] || 0
</span><span class="uncovered0"><a name="line3831"></a>3831       scale_x     = args[5] || 1
</span><span class="uncovered1"><a name="line3832"></a>3832       scale_y     = args[6] || 1
</span><span class="uncovered0"><a name="line3833"></a>3833    
</span><span class="uncovered1"><a name="line3834"></a>3834       raise &quot;Insufficient arguments in insert_image()&quot; unless args.size &gt;= 3
</span><span class="uncovered0"><a name="line3835"></a>3835       raise &quot;Couldn't locate #{image}: $!&quot;             unless test(?e, image)
</span><span class="uncovered1"><a name="line3836"></a>3836    
</span><span class="uncovered0"><a name="line3837"></a>3837       @images[row][col] = [ row, col, image,
</span><span class="uncovered1"><a name="line3838"></a>3838          x_offset, y_offset, scale_x, scale_y,]
</span><span class="uncovered0"><a name="line3839"></a>3839    
</span><span class="uncovered1"><a name="line3840"></a>3840    end
</span><span class="inferred0"><a name="line3841"></a>3841    
</span><span class="inferred1"><a name="line3842"></a>3842    # Older method name for backwards compatibility.
</span><span class="inferred0"><a name="line3843"></a>3843    #   *insert_bitmap = *insert_image;
</span><span class="inferred1"><a name="line3844"></a>3844    
</span><span class="inferred0"><a name="line3845"></a>3845    
</span><span class="inferred1"><a name="line3846"></a>3846    ###############################################################################
</span><span class="inferred0"><a name="line3847"></a>3847    #
</span><span class="inferred1"><a name="line3848"></a>3848    #  _position_object()
</span><span class="inferred0"><a name="line3849"></a>3849    #
</span><span class="inferred1"><a name="line3850"></a>3850    # Calculate the vertices that define the position of a graphical object within
</span><span class="inferred0"><a name="line3851"></a>3851    # the worksheet.
</span><span class="inferred1"><a name="line3852"></a>3852    #
</span><span class="inferred0"><a name="line3853"></a>3853    #         +------------+------------+
</span><span class="inferred1"><a name="line3854"></a>3854    #         |     A      |      B     |
</span><span class="inferred0"><a name="line3855"></a>3855    #   +-----+------------+------------+
</span><span class="inferred1"><a name="line3856"></a>3856    #   |     |(x1,y1)     |            |
</span><span class="inferred0"><a name="line3857"></a>3857    #   |  1  |(A1)._______|______      |
</span><span class="inferred1"><a name="line3858"></a>3858    #   |     |    |              |     |
</span><span class="inferred0"><a name="line3859"></a>3859    #   |     |    |              |     |
</span><span class="inferred1"><a name="line3860"></a>3860    #   +-----+----|    BITMAP    |-----+
</span><span class="inferred0"><a name="line3861"></a>3861    #   |     |    |              |     |
</span><span class="inferred1"><a name="line3862"></a>3862    #   |  2  |    |______________.     |
</span><span class="inferred0"><a name="line3863"></a>3863    #   |     |            |        (B2)|
</span><span class="inferred1"><a name="line3864"></a>3864    #   |     |            |     (x2,y2)|
</span><span class="inferred0"><a name="line3865"></a>3865    #   +---- +------------+------------+
</span><span class="inferred1"><a name="line3866"></a>3866    #
</span><span class="inferred0"><a name="line3867"></a>3867    # Example of a bitmap that covers some of the area from cell A1 to cell B2.
</span><span class="inferred1"><a name="line3868"></a>3868    #
</span><span class="inferred0"><a name="line3869"></a>3869    # Based on the width and height of the bitmap we need to calculate 8 vars:
</span><span class="inferred1"><a name="line3870"></a>3870    #     $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
</span><span class="inferred0"><a name="line3871"></a>3871    # The width and height of the cells are also variable and have to be taken into
</span><span class="inferred1"><a name="line3872"></a>3872    # account.
</span><span class="inferred0"><a name="line3873"></a>3873    # The values of $col_start and $row_start are passed in from the calling
</span><span class="inferred1"><a name="line3874"></a>3874    # function. The values of $col_end and $row_end are calculated by subtracting
</span><span class="inferred0"><a name="line3875"></a>3875    # the width and height of the bitmap from the width and height of the
</span><span class="inferred1"><a name="line3876"></a>3876    # underlying cells.
</span><span class="inferred0"><a name="line3877"></a>3877    # The vertices are expressed as a percentage of the underlying cell width as
</span><span class="inferred1"><a name="line3878"></a>3878    # follows (rhs values are in pixels):
</span><span class="inferred0"><a name="line3879"></a>3879    #
</span><span class="inferred1"><a name="line3880"></a>3880    #       x1 = X / W *1024
</span><span class="inferred0"><a name="line3881"></a>3881    #       y1 = Y / H *256
</span><span class="inferred1"><a name="line3882"></a>3882    #       x2 = (X-1) / W *1024
</span><span class="inferred0"><a name="line3883"></a>3883    #       y2 = (Y-1) / H *256
</span><span class="inferred1"><a name="line3884"></a>3884    #
</span><span class="inferred0"><a name="line3885"></a>3885    #       Where:  X is distance from the left side of the underlying cell
</span><span class="inferred1"><a name="line3886"></a>3886    #               Y is distance from the top of the underlying cell
</span><span class="inferred0"><a name="line3887"></a>3887    #               W is the width of the cell
</span><span class="inferred1"><a name="line3888"></a>3888    #               H is the height of the cell
</span><span class="inferred0"><a name="line3889"></a>3889    #
</span><span class="inferred1"><a name="line3890"></a>3890    # Note: the SDK incorrectly states that the height should be expressed as a
</span><span class="inferred0"><a name="line3891"></a>3891    # percentage of 1024.
</span><span class="inferred1"><a name="line3892"></a>3892    #
</span><span class="marked0"><a name="line3893"></a>3893    def position_object(col_start, row_start, x1, y1, width, height)
</span><span class="inferred1"><a name="line3894"></a>3894       # col_start;  # Col containing upper left corner of object
</span><span class="inferred0"><a name="line3895"></a>3895       # x1;         # Distance to left side of object
</span><span class="inferred1"><a name="line3896"></a>3896    
</span><span class="inferred0"><a name="line3897"></a>3897       # row_start;  # Row containing top left corner of object
</span><span class="inferred1"><a name="line3898"></a>3898       # y1;         # Distance to top of object
</span><span class="inferred0"><a name="line3899"></a>3899    
</span><span class="inferred1"><a name="line3900"></a>3900       # col_end;    # Col containing lower right corner of object
</span><span class="inferred0"><a name="line3901"></a>3901       # x2;         # Distance to right side of object
</span><span class="inferred1"><a name="line3902"></a>3902    
</span><span class="inferred0"><a name="line3903"></a>3903       # row_end;    # Row containing bottom right corner of object
</span><span class="inferred1"><a name="line3904"></a>3904       # y2;         # Distance to bottom of object
</span><span class="inferred0"><a name="line3905"></a>3905    
</span><span class="inferred1"><a name="line3906"></a>3906       # width;      # Width of image frame
</span><span class="inferred0"><a name="line3907"></a>3907       # height;     # Height of image frame
</span><span class="inferred1"><a name="line3908"></a>3908    
</span><span class="inferred0"><a name="line3909"></a>3909       # Adjust start column for offsets that are greater than the col width
</span><span class="marked1"><a name="line3910"></a>3910       while x1 &gt;= size_col(col_start)
</span><span class="uncovered0"><a name="line3911"></a>3911          x1 = x1 - size_col(col_start)
</span><span class="uncovered1"><a name="line3912"></a>3912          col_start = col_start + 1
</span><span class="uncovered0"><a name="line3913"></a>3913       end
</span><span class="inferred1"><a name="line3914"></a>3914    
</span><span class="inferred0"><a name="line3915"></a>3915       # Adjust start row for offsets that are greater than the row height
</span><span class="marked1"><a name="line3916"></a>3916       while y1 &gt;= size_row(row_start)
</span><span class="uncovered0"><a name="line3917"></a>3917          y1 = y1 - size_row(row_start)
</span><span class="uncovered1"><a name="line3918"></a>3918          row_start = row_start + 1
</span><span class="uncovered0"><a name="line3919"></a>3919       end
</span><span class="inferred1"><a name="line3920"></a>3920    
</span><span class="inferred0"><a name="line3921"></a>3921       # Initialise end cell to the same as the start cell
</span><span class="marked1"><a name="line3922"></a>3922       col_end    = col_start
</span><span class="marked0"><a name="line3923"></a>3923       row_end    = row_start
</span><span class="inferred1"><a name="line3924"></a>3924    
</span><span class="marked0"><a name="line3925"></a>3925       width      = width  + x1 -1
</span><span class="marked1"><a name="line3926"></a>3926       height     = height + y1 -1
</span><span class="inferred0"><a name="line3927"></a>3927    
</span><span class="inferred1"><a name="line3928"></a>3928       # Subtract the underlying cell widths to find the end cell of the image
</span><span class="marked0"><a name="line3929"></a>3929       while width &gt;= size_col(col_end)
</span><span class="marked1"><a name="line3930"></a>3930          width = width - size_col(col_end)
</span><span class="marked0"><a name="line3931"></a>3931          col_end = col_end + 1
</span><span class="inferred1"><a name="line3932"></a>3932       end
</span><span class="inferred0"><a name="line3933"></a>3933    
</span><span class="inferred1"><a name="line3934"></a>3934       # Subtract the underlying cell heights to find the end cell of the image
</span><span class="marked0"><a name="line3935"></a>3935       while height &gt;= size_row(row_end)
</span><span class="marked1"><a name="line3936"></a>3936          height  = height - size_row(row_end)
</span><span class="marked0"><a name="line3937"></a>3937          row_end = row_end + 1
</span><span class="inferred1"><a name="line3938"></a>3938       end
</span><span class="inferred0"><a name="line3939"></a>3939    
</span><span class="inferred1"><a name="line3940"></a>3940       # Bitmap isn't allowed to start or finish in a hidden cell, i.e. a cell
</span><span class="inferred0"><a name="line3941"></a>3941       # with zero eight or width.
</span><span class="inferred1"><a name="line3942"></a>3942       #
</span><span class="marked0"><a name="line3943"></a>3943       return if size_col(col_start) == 0
</span><span class="marked1"><a name="line3944"></a>3944       return if size_col(col_end)   == 0
</span><span class="marked0"><a name="line3945"></a>3945       return if size_row(row_start) == 0
</span><span class="marked1"><a name="line3946"></a>3946       return if size_row(row_end)   == 0
</span><span class="inferred0"><a name="line3947"></a>3947    
</span><span class="inferred1"><a name="line3948"></a>3948       # Convert the pixel values to the percentage value expected by Excel
</span><span class="marked0"><a name="line3949"></a>3949       x1 = x1     / size_col(col_start)   * 1024
</span><span class="marked1"><a name="line3950"></a>3950       y1 = y1     / size_row(row_start)   *  256
</span><span class="marked0"><a name="line3951"></a>3951       x2 = width  / size_col(col_end)     * 1024
</span><span class="marked1"><a name="line3952"></a>3952       y2 = height / size_row(row_end)     *  256
</span><span class="inferred0"><a name="line3953"></a>3953    
</span><span class="inferred1"><a name="line3954"></a>3954       # Simulate ceil() without calling POSIX::ceil().
</span><span class="marked0"><a name="line3955"></a>3955       x1 = (x1 +0.5).to_i
</span><span class="marked1"><a name="line3956"></a>3956       y1 = (y1 +0.5).to_i
</span><span class="marked0"><a name="line3957"></a>3957       x2 = (x2 +0.5).to_i
</span><span class="marked1"><a name="line3958"></a>3958       y2 = (y2 +0.5).to_i
</span><span class="inferred0"><a name="line3959"></a>3959    
</span><span class="inferred1"><a name="line3960"></a>3960       return [col_start, x1,
</span><span class="inferred0"><a name="line3961"></a>3961          row_start, y1,
</span><span class="inferred1"><a name="line3962"></a>3962          col_end,   x2,
</span><span class="inferred0"><a name="line3963"></a>3963          row_end,   y2
</span><span class="marked1"><a name="line3964"></a>3964       ]
</span><span class="inferred0"><a name="line3965"></a>3965    end
</span><span class="inferred1"><a name="line3966"></a>3966 
</span><span class="inferred0"><a name="line3967"></a>3967    ###############################################################################
</span><span class="inferred1"><a name="line3968"></a>3968    #
</span><span class="inferred0"><a name="line3969"></a>3969    # _size_col($col)
</span><span class="inferred1"><a name="line3970"></a>3970    #
</span><span class="inferred0"><a name="line3971"></a>3971    # Convert the width of a cell from user's units to pixels. Excel rounds the
</span><span class="inferred1"><a name="line3972"></a>3972    # column width to the nearest pixel. If the width hasn't been set by the user
</span><span class="inferred0"><a name="line3973"></a>3973    # we use the default value. If the column is hidden we use a value of zero.
</span><span class="inferred1"><a name="line3974"></a>3974    #
</span><span class="marked0"><a name="line3975"></a>3975    def size_col(col)
</span><span class="inferred1"><a name="line3976"></a>3976       # Look up the cell value to see if it has been changed
</span><span class="marked0"><a name="line3977"></a>3977       unless @col_sizes[col].nil?
</span><span class="uncovered1"><a name="line3978"></a>3978          width = @col_sizes[col]
</span><span class="uncovered0"><a name="line3979"></a>3979    
</span><span class="uncovered1"><a name="line3980"></a>3980          # The relationship is different for user units less than 1.
</span><span class="uncovered0"><a name="line3981"></a>3981          if width &lt; 1
</span><span class="uncovered1"><a name="line3982"></a>3982             return (width *12).to_i
</span><span class="uncovered0"><a name="line3983"></a>3983          else
</span><span class="uncovered1"><a name="line3984"></a>3984             return (width *7 +5 ).to_i
</span><span class="uncovered0"><a name="line3985"></a>3985          end
</span><span class="inferred1"><a name="line3986"></a>3986       else
</span><span class="marked0"><a name="line3987"></a>3987          return 64
</span><span class="inferred1"><a name="line3988"></a>3988       end
</span><span class="marked0"><a name="line3989"></a>3989    end
</span><span class="inferred1"><a name="line3990"></a>3990    
</span><span class="inferred0"><a name="line3991"></a>3991    ###############################################################################
</span><span class="inferred1"><a name="line3992"></a>3992    #
</span><span class="inferred0"><a name="line3993"></a>3993    # _size_row($row)
</span><span class="inferred1"><a name="line3994"></a>3994    #
</span><span class="inferred0"><a name="line3995"></a>3995    # Convert the height of a cell from user's units to pixels. By interpolation
</span><span class="inferred1"><a name="line3996"></a>3996    # the relationship is: y = 4/3x. If the height hasn't been set by the user we
</span><span class="inferred0"><a name="line3997"></a>3997    # use the default value. If the row is hidden we use a value of zero. (Not
</span><span class="inferred1"><a name="line3998"></a>3998    # possible to hide row yet).
</span><span class="inferred0"><a name="line3999"></a>3999    #
</span><span class="marked1"><a name="line4000"></a>4000    def size_row(row)
</span><span class="inferred0"><a name="line4001"></a>4001       # Look up the cell value to see if it has been changed
</span><span class="marked1"><a name="line4002"></a>4002       unless @row_sizes[row].nil?
</span><span class="uncovered0"><a name="line4003"></a>4003          if @row_sizes[row] == 0
</span><span class="uncovered1"><a name="line4004"></a>4004             return 0
</span><span class="uncovered0"><a name="line4005"></a>4005          else
</span><span class="uncovered1"><a name="line4006"></a>4006             return (4/3 * @row_sizes[row]).to_i
</span><span class="uncovered0"><a name="line4007"></a>4007          end
</span><span class="inferred1"><a name="line4008"></a>4008       else
</span><span class="marked0"><a name="line4009"></a>4009          return 17
</span><span class="inferred1"><a name="line4010"></a>4010       end
</span><span class="marked0"><a name="line4011"></a>4011    end
</span><span class="inferred1"><a name="line4012"></a>4012 
</span><span class="inferred0"><a name="line4013"></a>4013    ###############################################################################
</span><span class="inferred1"><a name="line4014"></a>4014    #
</span><span class="inferred0"><a name="line4015"></a>4015    # _store_zoom($zoom)
</span><span class="inferred1"><a name="line4016"></a>4016    #
</span><span class="inferred0"><a name="line4017"></a>4017    #
</span><span class="inferred1"><a name="line4018"></a>4018    # Store the window zoom factor. This should be a reduced fraction but for
</span><span class="inferred0"><a name="line4019"></a>4019    # simplicity we will store all fractions with a numerator of 100.
</span><span class="inferred1"><a name="line4020"></a>4020    #
</span><span class="marked0"><a name="line4021"></a>4021    def store_zoom
</span><span class="uncovered1"><a name="line4022"></a>4022       # If scale is 100 we don't need to write a record
</span><span class="uncovered0"><a name="line4023"></a>4023       return if @zoom == 100
</span><span class="uncovered1"><a name="line4024"></a>4024    
</span><span class="uncovered0"><a name="line4025"></a>4025       record      = 0x00A0               # Record identifier
</span><span class="uncovered1"><a name="line4026"></a>4026       length      = 0x0004               # Bytes to follow
</span><span class="uncovered0"><a name="line4027"></a>4027    
</span><span class="uncovered1"><a name="line4028"></a>4028       header      = [record, header].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line4029"></a>4029       data        = [@zoom, 100].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line4030"></a>4030    
</span><span class="uncovered0"><a name="line4031"></a>4031       append(header, data)
</span><span class="uncovered1"><a name="line4032"></a>4032    end
</span><span class="inferred0"><a name="line4033"></a>4033    
</span><span class="inferred1"><a name="line4034"></a>4034    ###############################################################################
</span><span class="inferred0"><a name="line4035"></a>4035    #
</span><span class="inferred1"><a name="line4036"></a>4036    # write_utf16be_string($row, $col, $string, $format)
</span><span class="inferred0"><a name="line4037"></a>4037    #
</span><span class="inferred1"><a name="line4038"></a>4038    # Write a Unicode string to the specified row and column (zero indexed).
</span><span class="inferred0"><a name="line4039"></a>4039    # $format is optional.
</span><span class="inferred1"><a name="line4040"></a>4040    # Returns  0 : normal termination
</span><span class="inferred0"><a name="line4041"></a>4041    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line4042"></a>4042    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line4043"></a>4043    #         -3 : long string truncated to 255 chars
</span><span class="inferred1"><a name="line4044"></a>4044    #
</span><span class="marked0"><a name="line4045"></a>4045    def write_utf16be_string(*args)
</span><span class="inferred1"><a name="line4046"></a>4046       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line4047"></a>4047       if args[0] =~ /^\D/
</span><span class="inferred1"><a name="line4048"></a>4048          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line4049"></a>4049       end
</span><span class="inferred1"><a name="line4050"></a>4050    
</span><span class="marked0"><a name="line4051"></a>4051       return -1 if (args.size &lt; 3)                     # Check the number of args
</span><span class="inferred1"><a name="line4052"></a>4052    
</span><span class="marked0"><a name="line4053"></a>4053       record      = 0x00FD                        # Record identifier
</span><span class="marked1"><a name="line4054"></a>4054       length      = 0x000A                        # Bytes to follow
</span><span class="inferred0"><a name="line4055"></a>4055    
</span><span class="marked1"><a name="line4056"></a>4056       row         = args[0]                         # Zero indexed row
</span><span class="marked0"><a name="line4057"></a>4057       col         = args[1]                         # Zero indexed column
</span><span class="marked1"><a name="line4058"></a>4058       strlen      = args[2].length
</span><span class="marked0"><a name="line4059"></a>4059       str         = args[2]
</span><span class="marked1"><a name="line4060"></a>4060       xf          = xf_record_index(row, col, args[3]) # The cell format
</span><span class="marked0"><a name="line4061"></a>4061       encoding    = 0x1
</span><span class="marked1"><a name="line4062"></a>4062       str_error   = 0
</span><span class="inferred0"><a name="line4063"></a>4063    
</span><span class="inferred1"><a name="line4064"></a>4064       # Check that row and col are valid and store max and min values
</span><span class="marked0"><a name="line4065"></a>4065       return -2 if check_dimensions(row, col) != 0
</span><span class="inferred1"><a name="line4066"></a>4066    
</span><span class="inferred0"><a name="line4067"></a>4067       # Limit the utf16 string to the max number of chars (not bytes).
</span><span class="marked1"><a name="line4068"></a>4068       if strlen &gt; 32767* 2
</span><span class="uncovered0"><a name="line4069"></a>4069          str       = str[0..32767*2]
</span><span class="uncovered1"><a name="line4070"></a>4070          str_error = -3
</span><span class="uncovered0"><a name="line4071"></a>4071       end
</span><span class="inferred1"><a name="line4072"></a>4072    
</span><span class="marked0"><a name="line4073"></a>4073       num_bytes = str.length
</span><span class="marked1"><a name="line4074"></a>4074       num_chars = (num_bytes / 2).to_i
</span><span class="inferred0"><a name="line4075"></a>4075    
</span><span class="inferred1"><a name="line4076"></a>4076       # Check for a valid 2-byte char string.
</span><span class="marked0"><a name="line4077"></a>4077       raise &quot;Uneven number of bytes in Unicode string&quot; if num_bytes % 2 != 0
</span><span class="inferred1"><a name="line4078"></a>4078    
</span><span class="inferred0"><a name="line4079"></a>4079       # Change from UTF16 big-endian to little endian
</span><span class="marked1"><a name="line4080"></a>4080       str = str.unpack('n*').pack('v')
</span><span class="inferred0"><a name="line4081"></a>4081    
</span><span class="inferred1"><a name="line4082"></a>4082       # Add the encoding and length header to the string.
</span><span class="marked0"><a name="line4083"></a>4083       str_header  = [num_chars, encoding].pack(&quot;vC&quot;)
</span><span class="marked1"><a name="line4084"></a>4084       str         = str_header + str
</span><span class="inferred0"><a name="line4085"></a>4085    
</span><span class="marked1"><a name="line4086"></a>4086       unless @str_table[str]
</span><span class="marked0"><a name="line4087"></a>4087          @str_table[str] = @str_unique
</span><span class="marked1"><a name="line4088"></a>4088          @str_unique += 1
</span><span class="inferred0"><a name="line4089"></a>4089       end
</span><span class="inferred1"><a name="line4090"></a>4090    
</span><span class="marked0"><a name="line4091"></a>4091       @str_total += 1
</span><span class="inferred1"><a name="line4092"></a>4092    
</span><span class="marked0"><a name="line4093"></a>4093       header = [record, length].pack(&quot;vv&quot;)
</span><span class="marked1"><a name="line4094"></a>4094       data   = [row, col, xf, @str_table[str]].pack(&quot;vvvV&quot;)
</span><span class="inferred0"><a name="line4095"></a>4095    
</span><span class="inferred1"><a name="line4096"></a>4096       # Store the data or write immediately depending on the compatibility mode.
</span><span class="marked0"><a name="line4097"></a>4097       if @compatibility != 0
</span><span class="uncovered1"><a name="line4098"></a>4098          tmp = []
</span><span class="uncovered0"><a name="line4099"></a>4099          tmp[col] = header + data
</span><span class="uncovered1"><a name="line4100"></a>4100          @table[row] = tmp
</span><span class="inferred0"><a name="line4101"></a>4101       else
</span><span class="marked1"><a name="line4102"></a>4102          append(header, data)
</span><span class="inferred0"><a name="line4103"></a>4103       end
</span><span class="inferred1"><a name="line4104"></a>4104    
</span><span class="marked0"><a name="line4105"></a>4105       return str_error
</span><span class="inferred1"><a name="line4106"></a>4106    end
</span><span class="inferred0"><a name="line4107"></a>4107    
</span><span class="inferred1"><a name="line4108"></a>4108    ###############################################################################
</span><span class="inferred0"><a name="line4109"></a>4109    #
</span><span class="inferred1"><a name="line4110"></a>4110    # write_utf16le_string($row, $col, $string, $format)
</span><span class="inferred0"><a name="line4111"></a>4111    #
</span><span class="inferred1"><a name="line4112"></a>4112    # Write a UTF-16LE string to the specified row and column (zero indexed).
</span><span class="inferred0"><a name="line4113"></a>4113    # $format is optional.
</span><span class="inferred1"><a name="line4114"></a>4114    # Returns  0 : normal termination
</span><span class="inferred0"><a name="line4115"></a>4115    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line4116"></a>4116    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line4117"></a>4117    #         -3 : long string truncated to 255 chars
</span><span class="inferred1"><a name="line4118"></a>4118    #
</span><span class="marked0"><a name="line4119"></a>4119    def write_utf16le_string(*args)
</span><span class="inferred1"><a name="line4120"></a>4120       # Check for a cell reference in A1 notation and substitute row and column
</span><span class="marked0"><a name="line4121"></a>4121       if args[0] =~ /^\D/
</span><span class="inferred1"><a name="line4122"></a>4122          args = substitute_cellref(*args)
</span><span class="inferred0"><a name="line4123"></a>4123       end
</span><span class="inferred1"><a name="line4124"></a>4124    
</span><span class="marked0"><a name="line4125"></a>4125       return -1 if (args.size &lt; 3)                     # Check the number of args
</span><span class="inferred1"><a name="line4126"></a>4126    
</span><span class="marked0"><a name="line4127"></a>4127       record      = 0x00FD                          # Record identifier
</span><span class="marked1"><a name="line4128"></a>4128       length      = 0x000A                          # Bytes to follow
</span><span class="inferred0"><a name="line4129"></a>4129    
</span><span class="marked1"><a name="line4130"></a>4130       row         = args[0]                         # Zero indexed row
</span><span class="marked0"><a name="line4131"></a>4131       col         = args[1]                         # Zero indexed column
</span><span class="marked1"><a name="line4132"></a>4132       str         = args[2]
</span><span class="marked0"><a name="line4133"></a>4133       format      = args[3]                         # The cell format
</span><span class="marked1"><a name="line4134"></a>4134 bp=true   
</span><span class="inferred0"><a name="line4135"></a>4135       # Change from UTF16 big-endian to little endian
</span><span class="marked1"><a name="line4136"></a>4136       str = str.unpack('n*').pack(&quot;v*&quot;)
</span><span class="inferred0"><a name="line4137"></a>4137    
</span><span class="marked1"><a name="line4138"></a>4138       return write_utf16be_string(row, col, str, format)
</span><span class="inferred0"><a name="line4139"></a>4139    end
</span><span class="inferred1"><a name="line4140"></a>4140    
</span><span class="inferred0"><a name="line4141"></a>4141    
</span><span class="inferred1"><a name="line4142"></a>4142    # Older method name for backwards compatibility.
</span><span class="inferred0"><a name="line4143"></a>4143    #   *write_unicode    = *write_utf16be_string;
</span><span class="inferred1"><a name="line4144"></a>4144    #   *write_unicode_le = *write_utf16le_string;
</span><span class="inferred0"><a name="line4145"></a>4145 
</span><span class="inferred1"><a name="line4146"></a>4146    ###############################################################################
</span><span class="inferred0"><a name="line4147"></a>4147    #
</span><span class="inferred1"><a name="line4148"></a>4148    # _store_autofilters()
</span><span class="inferred0"><a name="line4149"></a>4149    #
</span><span class="inferred1"><a name="line4150"></a>4150    # Function to iterate through the columns that form part of an autofilter
</span><span class="inferred0"><a name="line4151"></a>4151    # range and write Biff AUTOFILTER records if a filter expression has been set.
</span><span class="inferred1"><a name="line4152"></a>4152    #
</span><span class="marked0"><a name="line4153"></a>4153    def store_autofilters
</span><span class="uncovered1"><a name="line4154"></a>4154       # Skip all columns if no filter have been set.
</span><span class="uncovered0"><a name="line4155"></a>4155       return '' if @filter_on == 0
</span><span class="uncovered1"><a name="line4156"></a>4156 
</span><span class="uncovered0"><a name="line4157"></a>4157       col1 = @filter_area[2]
</span><span class="uncovered1"><a name="line4158"></a>4158       col2 = @filter_area[3]
</span><span class="uncovered0"><a name="line4159"></a>4159 
</span><span class="uncovered1"><a name="line4160"></a>4160       i = col1
</span><span class="uncovered0"><a name="line4161"></a>4161       while i &lt;= col2
</span><span class="uncovered1"><a name="line4162"></a>4162          # Reverse order since records are being pre-pended.
</span><span class="uncovered0"><a name="line4163"></a>4163          col = col2 -i
</span><span class="uncovered1"><a name="line4164"></a>4164 
</span><span class="uncovered0"><a name="line4165"></a>4165          # Skip if column doesn't have an active filter.
</span><span class="uncovered1"><a name="line4166"></a>4166          next unless @filter_cols[col]
</span><span class="uncovered0"><a name="line4167"></a>4167 
</span><span class="uncovered1"><a name="line4168"></a>4168          # Retrieve the filter tokens and write the autofilter records.
</span><span class="uncovered0"><a name="line4169"></a>4169          store_autofilter(col, @filter_cols[col])
</span><span class="uncovered1"><a name="line4170"></a>4170       end
</span><span class="uncovered0"><a name="line4171"></a>4171    end
</span><span class="inferred1"><a name="line4172"></a>4172 
</span><span class="inferred0"><a name="line4173"></a>4173    ###############################################################################
</span><span class="inferred1"><a name="line4174"></a>4174    #
</span><span class="inferred0"><a name="line4175"></a>4175    # _store_autofilter()
</span><span class="inferred1"><a name="line4176"></a>4176    #
</span><span class="inferred0"><a name="line4177"></a>4177    # Function to write worksheet AUTOFILTER records. These contain 2 Biff Doper
</span><span class="inferred1"><a name="line4178"></a>4178    # structures to represent the 2 possible filter conditions.
</span><span class="inferred0"><a name="line4179"></a>4179    #
</span><span class="marked1"><a name="line4180"></a>4180    def store_autofilter(index, operator, token_1, join, operator_2, token_2)
</span><span class="uncovered0"><a name="line4181"></a>4181       record          = 0x009E
</span><span class="uncovered1"><a name="line4182"></a>4182       length          = 0x0000
</span><span class="uncovered0"><a name="line4183"></a>4183 
</span><span class="uncovered1"><a name="line4184"></a>4184       top10_active    = 0
</span><span class="uncovered0"><a name="line4185"></a>4185       top10_direction = 0
</span><span class="uncovered1"><a name="line4186"></a>4186       top10_percent   = 0
</span><span class="uncovered0"><a name="line4187"></a>4187       top10_value     = 101
</span><span class="uncovered1"><a name="line4188"></a>4188 
</span><span class="uncovered0"><a name="line4189"></a>4189       grbit       = join
</span><span class="uncovered1"><a name="line4190"></a>4190       optimised_1 = 0
</span><span class="uncovered0"><a name="line4191"></a>4191       optimised_2 = 0
</span><span class="uncovered1"><a name="line4192"></a>4192       doper_1     = ''
</span><span class="uncovered0"><a name="line4193"></a>4193       doper_2     = ''
</span><span class="uncovered1"><a name="line4194"></a>4194       string_1    = ''
</span><span class="uncovered0"><a name="line4195"></a>4195       string_2    = ''
</span><span class="uncovered1"><a name="line4196"></a>4196 
</span><span class="uncovered0"><a name="line4197"></a>4197       # Excel used an optimisation in the case of a simple equality.
</span><span class="uncovered1"><a name="line4198"></a>4198       optimised_1 = 1 if                         operator_1 == 2
</span><span class="uncovered0"><a name="line4199"></a>4199       optimised_2 = 1 if defined operator_2 and operator_2 == 2
</span><span class="uncovered1"><a name="line4200"></a>4200 
</span><span class="uncovered0"><a name="line4201"></a>4201       # Convert non-simple equalities back to type 2. See  _parse_filter_tokens().
</span><span class="uncovered1"><a name="line4202"></a>4202       operator_1 = 2 if                        operator_1 == 22
</span><span class="uncovered0"><a name="line4203"></a>4203       operator_2 = 2 if defined operator_2 and operator_2 == 22
</span><span class="uncovered1"><a name="line4204"></a>4204 
</span><span class="uncovered0"><a name="line4205"></a>4205       # Handle a &quot;Top&quot; style expression.
</span><span class="uncovered1"><a name="line4206"></a>4206       if operator_1 &gt;= 30
</span><span class="uncovered0"><a name="line4207"></a>4207          # Remove the second expression if present.
</span><span class="uncovered1"><a name="line4208"></a>4208          operator_2 = nil
</span><span class="uncovered0"><a name="line4209"></a>4209          token_2    = nil
</span><span class="uncovered1"><a name="line4210"></a>4210 
</span><span class="uncovered0"><a name="line4211"></a>4211          # Set the active flag.
</span><span class="uncovered1"><a name="line4212"></a>4212          top10_active    = 1
</span><span class="uncovered0"><a name="line4213"></a>4213 
</span><span class="uncovered1"><a name="line4214"></a>4214          if (operator_1 == 30 or operator_1 == 31)
</span><span class="uncovered0"><a name="line4215"></a>4215             top10_direction = 1
</span><span class="uncovered1"><a name="line4216"></a>4216          end
</span><span class="uncovered0"><a name="line4217"></a>4217 
</span><span class="uncovered1"><a name="line4218"></a>4218          if (operator_1 == 31 or operator_1 == 33)
</span><span class="uncovered0"><a name="line4219"></a>4219             top10_percent = 1
</span><span class="uncovered1"><a name="line4220"></a>4220          end
</span><span class="uncovered0"><a name="line4221"></a>4221 
</span><span class="uncovered1"><a name="line4222"></a>4222          if (top10_direction == 1)
</span><span class="uncovered0"><a name="line4223"></a>4223             operator_1 = 6
</span><span class="uncovered1"><a name="line4224"></a>4224          else
</span><span class="uncovered0"><a name="line4225"></a>4225             operator_1 = 3
</span><span class="uncovered1"><a name="line4226"></a>4226          end
</span><span class="uncovered0"><a name="line4227"></a>4227 
</span><span class="uncovered1"><a name="line4228"></a>4228          top10_value     = token_1
</span><span class="uncovered0"><a name="line4229"></a>4229          token_1         = 0
</span><span class="uncovered1"><a name="line4230"></a>4230       end
</span><span class="uncovered0"><a name="line4231"></a>4231 
</span><span class="uncovered1"><a name="line4232"></a>4232       grbit     |= optimised_1      &lt;&lt; 2
</span><span class="uncovered0"><a name="line4233"></a>4233       grbit     |= optimised_2      &lt;&lt; 3
</span><span class="uncovered1"><a name="line4234"></a>4234       grbit     |= top10_active     &lt;&lt; 4
</span><span class="uncovered0"><a name="line4235"></a>4235       grbit     |= top10_direction  &lt;&lt; 5
</span><span class="uncovered1"><a name="line4236"></a>4236       grbit     |= top10_percent    &lt;&lt; 6
</span><span class="uncovered0"><a name="line4237"></a>4237       grbit     |= top10_value      &lt;&lt; 7
</span><span class="uncovered1"><a name="line4238"></a>4238 
</span><span class="uncovered0"><a name="line4239"></a>4239       doper_1, string_1 = pack_doper(operator_1, token_1)
</span><span class="uncovered1"><a name="line4240"></a>4240       doper_2, string_2   = pack_doper(operator_2, token_2)
</span><span class="uncovered0"><a name="line4241"></a>4241 
</span><span class="uncovered1"><a name="line4242"></a>4242       data = [index].pack('v')
</span><span class="uncovered0"><a name="line4243"></a>4243       data = data + [grbit].pack('v')
</span><span class="uncovered1"><a name="line4244"></a>4244       data = data + doper_1 + doper_2 + string_1 + string_2
</span><span class="uncovered0"><a name="line4245"></a>4245 
</span><span class="uncovered1"><a name="line4246"></a>4246       length  = data.length
</span><span class="uncovered0"><a name="line4247"></a>4247       header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line4248"></a>4248 
</span><span class="uncovered0"><a name="line4249"></a>4249       prepend(header, data)
</span><span class="uncovered1"><a name="line4250"></a>4250    end
</span><span class="inferred0"><a name="line4251"></a>4251 
</span><span class="inferred1"><a name="line4252"></a>4252    ###############################################################################
</span><span class="inferred0"><a name="line4253"></a>4253    #
</span><span class="inferred1"><a name="line4254"></a>4254    # _pack_doper()
</span><span class="inferred0"><a name="line4255"></a>4255    #
</span><span class="inferred1"><a name="line4256"></a>4256    # Create a Biff Doper structure that represents a filter expression. Depending
</span><span class="inferred0"><a name="line4257"></a>4257    # on the type of the token we pack an Empty, String or Number doper.
</span><span class="inferred1"><a name="line4258"></a>4258    #
</span><span class="marked0"><a name="line4259"></a>4259    def pack_doper(operator, token)
</span><span class="uncovered1"><a name="line4260"></a>4260       doper       = ''
</span><span class="uncovered0"><a name="line4261"></a>4261       string      = ''
</span><span class="uncovered1"><a name="line4262"></a>4262 
</span><span class="uncovered0"><a name="line4263"></a>4263       # Return default doper for non-defined filters.
</span><span class="uncovered1"><a name="line4264"></a>4264       if operator.nil?
</span><span class="uncovered0"><a name="line4265"></a>4265          return @pack_unused_doper, string
</span><span class="uncovered1"><a name="line4266"></a>4266       end
</span><span class="uncovered0"><a name="line4267"></a>4267 
</span><span class="uncovered1"><a name="line4268"></a>4268       if token =~ /^blanks|nonblanks$/i
</span><span class="uncovered0"><a name="line4269"></a>4269          doper  = pack_blanks_doper(operator, token)
</span><span class="uncovered1"><a name="line4270"></a>4270       elsif operator == 2 or
</span><span class="uncovered0"><a name="line4271"></a>4271            !(token  =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
</span><span class="uncovered1"><a name="line4272"></a>4272          # Excel treats all tokens as strings if the operator is equality, =.
</span><span class="uncovered0"><a name="line4273"></a>4273          string = token
</span><span class="uncovered1"><a name="line4274"></a>4274 
</span><span class="uncovered0"><a name="line4275"></a>4275          encoding = 0
</span><span class="uncovered1"><a name="line4276"></a>4276          length   = string.length
</span><span class="uncovered0"><a name="line4277"></a>4277 
</span><span class="uncovered1"><a name="line4278"></a>4278          # Handle utf8 strings in perl 5.8.
</span><span class="uncovered0"><a name="line4279"></a>4279          #  if ($] &gt;= 5.008) {
</span><span class="uncovered1"><a name="line4280"></a>4280          #      require Encode;
</span><span class="uncovered0"><a name="line4281"></a>4281          #
</span><span class="uncovered1"><a name="line4282"></a>4282          #      if (Encode::is_utf8($string)) {
</span><span class="uncovered0"><a name="line4283"></a>4283          #          $string = Encode::encode(&quot;UTF-16BE&quot;, $string);
</span><span class="uncovered1"><a name="line4284"></a>4284          #          $encoding = 1;
</span><span class="uncovered0"><a name="line4285"></a>4285          #      }
</span><span class="uncovered1"><a name="line4286"></a>4286          #  }
</span><span class="uncovered0"><a name="line4287"></a>4287 
</span><span class="uncovered1"><a name="line4288"></a>4288          string = [encoding].pack('C') + string
</span><span class="uncovered0"><a name="line4289"></a>4289          doper  = pack_string_doper(operator, length)
</span><span class="uncovered1"><a name="line4290"></a>4290       else
</span><span class="uncovered0"><a name="line4291"></a>4291          string = ''
</span><span class="uncovered1"><a name="line4292"></a>4292          doper  = pack_number_doper(operator, token)
</span><span class="uncovered0"><a name="line4293"></a>4293       end
</span><span class="uncovered1"><a name="line4294"></a>4294 
</span><span class="uncovered0"><a name="line4295"></a>4295       return doper, string
</span><span class="uncovered1"><a name="line4296"></a>4296    end
</span><span class="inferred0"><a name="line4297"></a>4297 
</span><span class="inferred1"><a name="line4298"></a>4298    ###############################################################################
</span><span class="inferred0"><a name="line4299"></a>4299    #
</span><span class="inferred1"><a name="line4300"></a>4300    # _pack_unused_doper()
</span><span class="inferred0"><a name="line4301"></a>4301    #
</span><span class="inferred1"><a name="line4302"></a>4302    # Pack an empty Doper structure.
</span><span class="inferred0"><a name="line4303"></a>4303    #
</span><span class="marked1"><a name="line4304"></a>4304    def pack_unused_doper
</span><span class="uncovered0"><a name="line4305"></a>4305       return [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0].pack('C10')
</span><span class="uncovered1"><a name="line4306"></a>4306    end
</span><span class="inferred0"><a name="line4307"></a>4307 
</span><span class="inferred1"><a name="line4308"></a>4308    ###############################################################################
</span><span class="inferred0"><a name="line4309"></a>4309    #
</span><span class="inferred1"><a name="line4310"></a>4310    # _pack_blanks_doper()
</span><span class="inferred0"><a name="line4311"></a>4311    #
</span><span class="inferred1"><a name="line4312"></a>4312    # Pack an Blanks/NonBlanks Doper structure.
</span><span class="inferred0"><a name="line4313"></a>4313    #
</span><span class="marked1"><a name="line4314"></a>4314    def pack_blanks_doper(operator, token)
</span><span class="uncovered0"><a name="line4315"></a>4315       if token == 'blanks'
</span><span class="uncovered1"><a name="line4316"></a>4316          type     = 0x0C
</span><span class="uncovered0"><a name="line4317"></a>4317          operator = 2
</span><span class="uncovered1"><a name="line4318"></a>4318       else
</span><span class="uncovered0"><a name="line4319"></a>4319          type     = 0x0E
</span><span class="uncovered1"><a name="line4320"></a>4320          operator = 5
</span><span class="uncovered0"><a name="line4321"></a>4321       end
</span><span class="uncovered1"><a name="line4322"></a>4322 
</span><span class="uncovered0"><a name="line4323"></a>4323       doper = [type,       # Data type
</span><span class="uncovered1"><a name="line4324"></a>4324          operator,
</span><span class="uncovered0"><a name="line4325"></a>4325          0x0000, 0x0000     # Reserved
</span><span class="uncovered1"><a name="line4326"></a>4326       ].pack('CCVV')
</span><span class="uncovered0"><a name="line4327"></a>4327       return doper
</span><span class="uncovered1"><a name="line4328"></a>4328    end
</span><span class="inferred0"><a name="line4329"></a>4329 
</span><span class="inferred1"><a name="line4330"></a>4330    ###############################################################################
</span><span class="inferred0"><a name="line4331"></a>4331    #
</span><span class="inferred1"><a name="line4332"></a>4332    # _pack_string_doper()
</span><span class="inferred0"><a name="line4333"></a>4333    #
</span><span class="inferred1"><a name="line4334"></a>4334    # Pack an string Doper structure.
</span><span class="inferred0"><a name="line4335"></a>4335    #
</span><span class="marked1"><a name="line4336"></a>4336    def pack_string_doper(operator, length)
</span><span class="uncovered0"><a name="line4337"></a>4337       doper = [0x06,     # Data type
</span><span class="uncovered1"><a name="line4338"></a>4338          operator,
</span><span class="uncovered0"><a name="line4339"></a>4339          0x0000,         #Reserved
</span><span class="uncovered1"><a name="line4340"></a>4340          length,         # String char length
</span><span class="uncovered0"><a name="line4341"></a>4341          0x0, 0x0, 0x0   # Reserved
</span><span class="uncovered1"><a name="line4342"></a>4342       ].pack('CCVCCCC')
</span><span class="uncovered0"><a name="line4343"></a>4343       return doper
</span><span class="uncovered1"><a name="line4344"></a>4344    end
</span><span class="inferred0"><a name="line4345"></a>4345 
</span><span class="inferred1"><a name="line4346"></a>4346    ###############################################################################
</span><span class="inferred0"><a name="line4347"></a>4347    #
</span><span class="inferred1"><a name="line4348"></a>4348    # _pack_number_doper()
</span><span class="inferred0"><a name="line4349"></a>4349    #
</span><span class="inferred1"><a name="line4350"></a>4350    # Pack an IEEE double number Doper structure.
</span><span class="inferred0"><a name="line4351"></a>4351    #
</span><span class="marked1"><a name="line4352"></a>4352    def pack_number_doper(operator, number)
</span><span class="uncovered0"><a name="line4353"></a>4353       number = [number].pack('d')
</span><span class="uncovered1"><a name="line4354"></a>4354       number.reverse! if @byte_order != 0
</span><span class="uncovered0"><a name="line4355"></a>4355 
</span><span class="uncovered1"><a name="line4356"></a>4356       doper  = [0x04, operator].pack('CC') + number
</span><span class="uncovered0"><a name="line4357"></a>4357       return doper
</span><span class="uncovered1"><a name="line4358"></a>4358    end
</span><span class="inferred0"><a name="line4359"></a>4359 
</span><span class="inferred1"><a name="line4360"></a>4360    #
</span><span class="inferred0"><a name="line4361"></a>4361    # Methods related to comments and MSO objects.
</span><span class="inferred1"><a name="line4362"></a>4362    #
</span><span class="inferred0"><a name="line4363"></a>4363    
</span><span class="inferred1"><a name="line4364"></a>4364    
</span><span class="inferred0"><a name="line4365"></a>4365    ###############################################################################
</span><span class="inferred1"><a name="line4366"></a>4366    #
</span><span class="inferred0"><a name="line4367"></a>4367    # _prepare_images()
</span><span class="inferred1"><a name="line4368"></a>4368    #
</span><span class="inferred0"><a name="line4369"></a>4369    # Turn the HoH that stores the images into an array for easier handling.
</span><span class="inferred1"><a name="line4370"></a>4370    #
</span><span class="marked0"><a name="line4371"></a>4371    def prepare_images
</span><span class="uncovered1"><a name="line4372"></a>4372        count  = 0
</span><span class="uncovered0"><a name="line4373"></a>4373        images = []
</span><span class="uncovered1"><a name="line4374"></a>4374    
</span><span class="uncovered0"><a name="line4375"></a>4375        # We sort the images by row and column but that isn't strictly required.
</span><span class="uncovered1"><a name="line4376"></a>4376        #
</span><span class="uncovered0"><a name="line4377"></a>4377        rows = @images.keys.sort
</span><span class="uncovered1"><a name="line4378"></a>4378    
</span><span class="uncovered0"><a name="line4379"></a>4379        rows.each do |row|
</span><span class="uncovered1"><a name="line4380"></a>4380            cols = @images[row].keys.sort
</span><span class="uncovered0"><a name="line4381"></a>4381            cols.each do |col|
</span><span class="uncovered1"><a name="line4382"></a>4382                images.push(@images[row][col])
</span><span class="uncovered0"><a name="line4383"></a>4383                count = count + 1
</span><span class="uncovered1"><a name="line4384"></a>4384            end
</span><span class="uncovered0"><a name="line4385"></a>4385        end
</span><span class="uncovered1"><a name="line4386"></a>4386    
</span><span class="uncovered0"><a name="line4387"></a>4387        @images       = {}
</span><span class="uncovered1"><a name="line4388"></a>4388        @images_array = @images
</span><span class="uncovered0"><a name="line4389"></a>4389    
</span><span class="uncovered1"><a name="line4390"></a>4390        return count
</span><span class="uncovered0"><a name="line4391"></a>4391    end
</span><span class="inferred1"><a name="line4392"></a>4392    
</span><span class="inferred0"><a name="line4393"></a>4393    ###############################################################################
</span><span class="inferred1"><a name="line4394"></a>4394    #
</span><span class="inferred0"><a name="line4395"></a>4395    # _prepare_comments()
</span><span class="inferred1"><a name="line4396"></a>4396    #
</span><span class="inferred0"><a name="line4397"></a>4397    # Turn the HoH that stores the comments into an array for easier handling.
</span><span class="inferred1"><a name="line4398"></a>4398    #
</span><span class="marked0"><a name="line4399"></a>4399    def prepare_comments
</span><span class="uncovered1"><a name="line4400"></a>4400        count   = 0
</span><span class="uncovered0"><a name="line4401"></a>4401        comments = []
</span><span class="uncovered1"><a name="line4402"></a>4402        
</span><span class="uncovered0"><a name="line4403"></a>4403        # We sort the comments by row and column but that isn't strictly required.
</span><span class="uncovered1"><a name="line4404"></a>4404        #
</span><span class="uncovered0"><a name="line4405"></a>4405        rows = @comments.keys.sort
</span><span class="uncovered1"><a name="line4406"></a>4406        rows.each do |row|
</span><span class="uncovered0"><a name="line4407"></a>4407            cols = @comments[row].keys.sort
</span><span class="uncovered1"><a name="line4408"></a>4408            cols.each do |col|
</span><span class="uncovered0"><a name="line4409"></a>4409                comments.push(@comments[row][col])
</span><span class="uncovered1"><a name="line4410"></a>4410                count = count + 1
</span><span class="uncovered0"><a name="line4411"></a>4411            end
</span><span class="uncovered1"><a name="line4412"></a>4412        end
</span><span class="uncovered0"><a name="line4413"></a>4413    
</span><span class="uncovered1"><a name="line4414"></a>4414        @comments       = {}
</span><span class="uncovered0"><a name="line4415"></a>4415        @comments_array = @comments
</span><span class="uncovered1"><a name="line4416"></a>4416    
</span><span class="uncovered0"><a name="line4417"></a>4417        return count
</span><span class="uncovered1"><a name="line4418"></a>4418    end
</span><span class="inferred0"><a name="line4419"></a>4419    
</span><span class="inferred1"><a name="line4420"></a>4420    ###############################################################################
</span><span class="inferred0"><a name="line4421"></a>4421    #
</span><span class="inferred1"><a name="line4422"></a>4422    # _prepare_charts()
</span><span class="inferred0"><a name="line4423"></a>4423    #
</span><span class="inferred1"><a name="line4424"></a>4424    # Turn the HoH that stores the charts into an array for easier handling.
</span><span class="inferred0"><a name="line4425"></a>4425    #
</span><span class="marked1"><a name="line4426"></a>4426    def prepare_charts
</span><span class="uncovered0"><a name="line4427"></a>4427        count  = 0
</span><span class="uncovered1"><a name="line4428"></a>4428        charts = []
</span><span class="uncovered0"><a name="line4429"></a>4429    
</span><span class="uncovered1"><a name="line4430"></a>4430        # We sort the charts by row and column but that isn't strictly required.
</span><span class="uncovered0"><a name="line4431"></a>4431        #
</span><span class="uncovered1"><a name="line4432"></a>4432        rows = @charts.keys.sort
</span><span class="uncovered0"><a name="line4433"></a>4433        rows.each do |row|
</span><span class="uncovered1"><a name="line4434"></a>4434            cols = @charts[row].keys.sort
</span><span class="uncovered0"><a name="line4435"></a>4435            cols.each do |col|
</span><span class="uncovered1"><a name="line4436"></a>4436                charts.push(@charts[row][col])
</span><span class="uncovered0"><a name="line4437"></a>4437                count = count + 1
</span><span class="uncovered1"><a name="line4438"></a>4438            end
</span><span class="uncovered0"><a name="line4439"></a>4439        end
</span><span class="uncovered1"><a name="line4440"></a>4440    
</span><span class="uncovered0"><a name="line4441"></a>4441        @charts       = {}
</span><span class="uncovered1"><a name="line4442"></a>4442        @charts_array = @charts
</span><span class="uncovered0"><a name="line4443"></a>4443    end
</span><span class="inferred1"><a name="line4444"></a>4444 
</span><span class="inferred0"><a name="line4445"></a>4445    ###############################################################################
</span><span class="inferred1"><a name="line4446"></a>4446    #
</span><span class="inferred0"><a name="line4447"></a>4447    # _store_images()
</span><span class="inferred1"><a name="line4448"></a>4448    #
</span><span class="inferred0"><a name="line4449"></a>4449    # Store the collections of records that make up images.
</span><span class="inferred1"><a name="line4450"></a>4450    #
</span><span class="marked0"><a name="line4451"></a>4451    def store_images
</span><span class="uncovered1"><a name="line4452"></a>4452        record          = 0x00EC           # Record identifier
</span><span class="uncovered0"><a name="line4453"></a>4453        length          = 0x0000           # Bytes to follow
</span><span class="uncovered1"><a name="line4454"></a>4454    
</span><span class="uncovered0"><a name="line4455"></a>4455        ids             = @object_ids
</span><span class="uncovered1"><a name="line4456"></a>4456        spid            = ids.shift
</span><span class="uncovered0"><a name="line4457"></a>4457    
</span><span class="uncovered1"><a name="line4458"></a>4458        images          = @images_array
</span><span class="uncovered0"><a name="line4459"></a>4459        num_images      = images.size
</span><span class="uncovered1"><a name="line4460"></a>4460    
</span><span class="uncovered0"><a name="line4461"></a>4461        num_filters     = @filter_count
</span><span class="uncovered1"><a name="line4462"></a>4462        num_comments    = @comments_array.size
</span><span class="uncovered0"><a name="line4463"></a>4463        num_charts      = @charts_array.size
</span><span class="uncovered1"><a name="line4464"></a>4464    
</span><span class="uncovered0"><a name="line4465"></a>4465        # Skip this if there aren't any images.
</span><span class="uncovered1"><a name="line4466"></a>4466        return if num_images == 0
</span><span class="uncovered0"><a name="line4467"></a>4467    
</span><span class="uncovered1"><a name="line4468"></a>4468        (0 .. num_images-1).each do |i|
</span><span class="uncovered0"><a name="line4469"></a>4469            row         =   images[i][0]
</span><span class="uncovered1"><a name="line4470"></a>4470            col         =   images[i][1]
</span><span class="uncovered0"><a name="line4471"></a>4471            name        =   images[i][2]
</span><span class="uncovered1"><a name="line4472"></a>4472            x_offset    =   images[i][3]
</span><span class="uncovered0"><a name="line4473"></a>4473            y_offset    =   images[i][4]
</span><span class="uncovered1"><a name="line4474"></a>4474            scale_x     =   images[i][5]
</span><span class="uncovered0"><a name="line4475"></a>4475            scale_y     =   images[i][6]
</span><span class="uncovered1"><a name="line4476"></a>4476            image_id    =   images[i][7]
</span><span class="uncovered0"><a name="line4477"></a>4477            type        =   images[i][8]
</span><span class="uncovered1"><a name="line4478"></a>4478            width       =   images[i][9]
</span><span class="uncovered0"><a name="line4479"></a>4479            height      =   images[i][10]
</span><span class="uncovered1"><a name="line4480"></a>4480    
</span><span class="uncovered0"><a name="line4481"></a>4481            width  = widhth  * scale_x unless scale_x == 0
</span><span class="uncovered1"><a name="line4482"></a>4482            height = height  * scale_y unless scale_y == 0
</span><span class="uncovered0"><a name="line4483"></a>4483    
</span><span class="uncovered1"><a name="line4484"></a>4484            # Calculate the positions of image object.
</span><span class="uncovered0"><a name="line4485"></a>4485            vertices = position_object(col,row,x_offset,y_offset,width,height)
</span><span class="uncovered1"><a name="line4486"></a>4486    
</span><span class="uncovered0"><a name="line4487"></a>4487            if (i == 0)
</span><span class="uncovered1"><a name="line4488"></a>4488                # Write the parent MSODRAWIING record.
</span><span class="uncovered0"><a name="line4489"></a>4489                dg_length   = 156 + 84*(num_images -1)
</span><span class="uncovered1"><a name="line4490"></a>4490                spgr_length = 132 + 84*(num_images -1)
</span><span class="uncovered0"><a name="line4491"></a>4491    
</span><span class="uncovered1"><a name="line4492"></a>4492                dg_length   = dg_length   + 120 * num_charts
</span><span class="uncovered0"><a name="line4493"></a>4493                spgr_length = spgr_length + 120 * num_charts
</span><span class="uncovered1"><a name="line4494"></a>4494    
</span><span class="uncovered0"><a name="line4495"></a>4495                dg_length   = dg_length   +  96 * num_filters
</span><span class="uncovered1"><a name="line4496"></a>4496                spgr_length = spgr_length +  96 * num_filters
</span><span class="uncovered0"><a name="line4497"></a>4497    
</span><span class="uncovered1"><a name="line4498"></a>4498                dg_length   = dg_length   + 128 * num_comments
</span><span class="uncovered0"><a name="line4499"></a>4499                spgr_length = spgr_length + 128 * num_comments
</span><span class="uncovered1"><a name="line4500"></a>4500    
</span><span class="uncovered0"><a name="line4501"></a>4501                data = store_mso_dg_container(dg_length) +
</span><span class="uncovered1"><a name="line4502"></a>4502                   store_mso_dg(ids)                     +
</span><span class="uncovered0"><a name="line4503"></a>4503                   store_mso_spgr_container(spgr_length) +
</span><span class="uncovered1"><a name="line4504"></a>4504                   store_mso_sp_container(40)            +
</span><span class="uncovered0"><a name="line4505"></a>4505                   store_mso_spgr()                      +
</span><span class="uncovered1"><a name="line4506"></a>4506                   store_mso_sp(0x0, spid, 0x0005)
</span><span class="uncovered0"><a name="line4507"></a>4507                spid = spid + 1
</span><span class="uncovered1"><a name="line4508"></a>4508                data = data                              + 
</span><span class="uncovered0"><a name="line4509"></a>4509                   store_mso_sp_container(76)            +
</span><span class="uncovered1"><a name="line4510"></a>4510                   store_mso_sp(75, spid, 0x0A00)
</span><span class="uncovered0"><a name="line4511"></a>4511                spid = spid + 1
</span><span class="uncovered1"><a name="line4512"></a>4512                data = data                              +
</span><span class="uncovered0"><a name="line4513"></a>4513                   store_mso_opt_image(image_id)         +
</span><span class="uncovered1"><a name="line4514"></a>4514                   store_mso_client_anchor(2, vertices)  +
</span><span class="uncovered0"><a name="line4515"></a>4515                   store_mso_client_data()
</span><span class="uncovered1"><a name="line4516"></a>4516            else
</span><span class="uncovered0"><a name="line4517"></a>4517                # Write the child MSODRAWIING record.
</span><span class="uncovered1"><a name="line4518"></a>4518                data = store_mso_sp_container(76)        +
</span><span class="uncovered0"><a name="line4519"></a>4519                   store_mso_sp(75, spid, 0x0A00)
</span><span class="uncovered1"><a name="line4520"></a>4520                spid = spid + 1
</span><span class="uncovered0"><a name="line4521"></a>4521                data = data                              +
</span><span class="uncovered1"><a name="line4522"></a>4522                   store_mso_opt_image(image_id)         +
</span><span class="uncovered0"><a name="line4523"></a>4523                   store_mso_client_anchor(2, vertices)  +
</span><span class="uncovered1"><a name="line4524"></a>4524                   store_mso_client_data()
</span><span class="uncovered0"><a name="line4525"></a>4525            end
</span><span class="uncovered1"><a name="line4526"></a>4526            length      = data.length
</span><span class="uncovered0"><a name="line4527"></a>4527            header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line4528"></a>4528            append(header, data)
</span><span class="uncovered0"><a name="line4529"></a>4529    
</span><span class="uncovered1"><a name="line4530"></a>4530            store_obj_image(i+1)
</span><span class="uncovered0"><a name="line4531"></a>4531        end
</span><span class="uncovered1"><a name="line4532"></a>4532    
</span><span class="uncovered0"><a name="line4533"></a>4533        @object_ids[0] = spid
</span><span class="uncovered1"><a name="line4534"></a>4534    end
</span><span class="inferred0"><a name="line4535"></a>4535 
</span><span class="inferred1"><a name="line4536"></a>4536    ###############################################################################
</span><span class="inferred0"><a name="line4537"></a>4537    #
</span><span class="inferred1"><a name="line4538"></a>4538    # _store_chart_binary
</span><span class="inferred0"><a name="line4539"></a>4539    #
</span><span class="inferred1"><a name="line4540"></a>4540    # Add a binary chart object extracted from an Excel file.
</span><span class="inferred0"><a name="line4541"></a>4541    #
</span><span class="marked1"><a name="line4542"></a>4542    def store_chart_binary(filename)
</span><span class="uncovered0"><a name="line4543"></a>4543        filehandle = File.open(filename, &quot;rb&quot;)
</span><span class="uncovered1"><a name="line4544"></a>4544 #                        die &quot;Couldn't open $filename in add_chart_ext(): $!.\n&quot;;
</span><span class="uncovered0"><a name="line4545"></a>4545    
</span><span class="uncovered1"><a name="line4546"></a>4546        while tmp = filehandle.read(4096)
</span><span class="uncovered0"><a name="line4547"></a>4547            append(tmp)
</span><span class="uncovered1"><a name="line4548"></a>4548        end
</span><span class="uncovered0"><a name="line4549"></a>4549    end
</span><span class="inferred1"><a name="line4550"></a>4550 
</span><span class="inferred0"><a name="line4551"></a>4551    ###############################################################################
</span><span class="inferred1"><a name="line4552"></a>4552    #
</span><span class="inferred0"><a name="line4553"></a>4553    # _store_filters()
</span><span class="inferred1"><a name="line4554"></a>4554    #
</span><span class="inferred0"><a name="line4555"></a>4555    # Store the collections of records that make up filters.
</span><span class="inferred1"><a name="line4556"></a>4556    #
</span><span class="marked0"><a name="line4557"></a>4557    def store_filters
</span><span class="uncovered1"><a name="line4558"></a>4558        record          = 0x00EC           # Record identifier
</span><span class="uncovered0"><a name="line4559"></a>4559        length          = 0x0000           # Bytes to follow
</span><span class="uncovered1"><a name="line4560"></a>4560    
</span><span class="uncovered0"><a name="line4561"></a>4561        ids             = @object_ids
</span><span class="uncovered1"><a name="line4562"></a>4562        spid            = ids.shift
</span><span class="uncovered0"><a name="line4563"></a>4563    
</span><span class="uncovered1"><a name="line4564"></a>4564        filter_area     = @filter_area
</span><span class="uncovered0"><a name="line4565"></a>4565        num_filters     = @filter_count
</span><span class="uncovered1"><a name="line4566"></a>4566    
</span><span class="uncovered0"><a name="line4567"></a>4567        num_comments    = @comments_array.size
</span><span class="uncovered1"><a name="line4568"></a>4568    
</span><span class="uncovered0"><a name="line4569"></a>4569        # Number of objects written so far.
</span><span class="uncovered1"><a name="line4570"></a>4570        num_objects     = @images_array.size + @charts_array.size
</span><span class="uncovered0"><a name="line4571"></a>4571    
</span><span class="uncovered1"><a name="line4572"></a>4572        # Skip this if there aren't any filters.
</span><span class="uncovered0"><a name="line4573"></a>4573        return if num_filters == 0
</span><span class="uncovered1"><a name="line4574"></a>4574    
</span><span class="uncovered0"><a name="line4575"></a>4575        row1, row2, col1, col2 = @filter_area
</span><span class="uncovered1"><a name="line4576"></a>4576    
</span><span class="uncovered0"><a name="line4577"></a>4577        (0 .. num_filters-1).each do |i|
</span><span class="uncovered1"><a name="line4578"></a>4578            vertices = [ col1 +i,    0, row1   , 0,
</span><span class="uncovered0"><a name="line4579"></a>4579                         col1 +i +1, 0, row1 +1, 0]
</span><span class="uncovered1"><a name="line4580"></a>4580    
</span><span class="uncovered0"><a name="line4581"></a>4581            if i == 0 and !num_objects.nil?
</span><span class="uncovered1"><a name="line4582"></a>4582                # Write the parent MSODRAWIING record.
</span><span class="uncovered0"><a name="line4583"></a>4583                dg_length   = 168 + 96*(num_filters -1)
</span><span class="uncovered1"><a name="line4584"></a>4584                spgr_length = 144 + 96*(num_filters -1)
</span><span class="uncovered0"><a name="line4585"></a>4585    
</span><span class="uncovered1"><a name="line4586"></a>4586                dg_length   = dg_length   + 128 *num_comments
</span><span class="uncovered0"><a name="line4587"></a>4587                spgr_length = spgr_length + 128 *num_comments
</span><span class="uncovered1"><a name="line4588"></a>4588    
</span><span class="uncovered0"><a name="line4589"></a>4589                data = store_mso_dg_container(dg_length)           +
</span><span class="uncovered1"><a name="line4590"></a>4590                   store_mso_dg(ids)                               +
</span><span class="uncovered0"><a name="line4591"></a>4591                   store_mso_spgr_container(spgr_length)           +
</span><span class="uncovered1"><a name="line4592"></a>4592                   store_mso_sp_container(40)                      +
</span><span class="uncovered0"><a name="line4593"></a>4593                   store_mso_spgr()                                +
</span><span class="uncovered1"><a name="line4594"></a>4594                   store_mso_sp(0x0, spid, 0x0005)
</span><span class="uncovered0"><a name="line4595"></a>4595                spid = spid + 1
</span><span class="uncovered1"><a name="line4596"></a>4596                data = data + store_mso_sp_container(88)           +
</span><span class="uncovered0"><a name="line4597"></a>4597                   store_mso_sp(201, spid, 0x0A00)                 +
</span><span class="uncovered1"><a name="line4598"></a>4598                   store_mso_opt_filter()                          +
</span><span class="uncovered0"><a name="line4599"></a>4599                   store_mso_client_anchor(1, vertices)            +
</span><span class="uncovered1"><a name="line4600"></a>4600                   store_mso_client_data()
</span><span class="uncovered0"><a name="line4601"></a>4601                spid = spid + 1
</span><span class="uncovered1"><a name="line4602"></a>4602    
</span><span class="uncovered0"><a name="line4603"></a>4603            else
</span><span class="uncovered1"><a name="line4604"></a>4604                # Write the child MSODRAWIING record.
</span><span class="uncovered0"><a name="line4605"></a>4605                data = store_mso_sp_container(88)                  +
</span><span class="uncovered1"><a name="line4606"></a>4606                   store_mso_sp(201, spid, 0x0A00)                 +
</span><span class="uncovered0"><a name="line4607"></a>4607                   store_mso_opt_filter()                          +
</span><span class="uncovered1"><a name="line4608"></a>4608                   store_mso_client_anchor(1, vertices)            +
</span><span class="uncovered0"><a name="line4609"></a>4609                   store_mso_client_data()
</span><span class="uncovered1"><a name="line4610"></a>4610                spid = spid + 1
</span><span class="uncovered0"><a name="line4611"></a>4611            end
</span><span class="uncovered1"><a name="line4612"></a>4612            length      = data.length
</span><span class="uncovered0"><a name="line4613"></a>4613            header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line4614"></a>4614            append(header, data)
</span><span class="uncovered0"><a name="line4615"></a>4615    
</span><span class="uncovered1"><a name="line4616"></a>4616            store_obj_filter(num_objects+i+1, col1 +i)
</span><span class="uncovered0"><a name="line4617"></a>4617        end
</span><span class="uncovered1"><a name="line4618"></a>4618    
</span><span class="uncovered0"><a name="line4619"></a>4619        # Simulate the EXTERNSHEET link between the filter and data using a formula
</span><span class="uncovered1"><a name="line4620"></a>4620        # such as '=Sheet1!A1'.
</span><span class="uncovered0"><a name="line4621"></a>4621        # TODO. Won't work for external data refs. Also should use a more direct
</span><span class="uncovered1"><a name="line4622"></a>4622        #       method.
</span><span class="uncovered0"><a name="line4623"></a>4623        #
</span><span class="uncovered1"><a name="line4624"></a>4624        formula = &quot;=#{@name}!A1&quot;
</span><span class="uncovered0"><a name="line4625"></a>4625        store_formula(formula)
</span><span class="uncovered1"><a name="line4626"></a>4626    
</span><span class="uncovered0"><a name="line4627"></a>4627        @object_ids[0] = spid
</span><span class="uncovered1"><a name="line4628"></a>4628    end
</span><span class="inferred0"><a name="line4629"></a>4629    
</span><span class="inferred1"><a name="line4630"></a>4630    ###############################################################################
</span><span class="inferred0"><a name="line4631"></a>4631    #
</span><span class="inferred1"><a name="line4632"></a>4632    # _store_comments()
</span><span class="inferred0"><a name="line4633"></a>4633    #
</span><span class="inferred1"><a name="line4634"></a>4634    # Store the collections of records that make up cell comments.
</span><span class="inferred0"><a name="line4635"></a>4635    #
</span><span class="inferred1"><a name="line4636"></a>4636    # NOTE: We write the comment objects last since that makes it a little easier
</span><span class="inferred0"><a name="line4637"></a>4637    # to write the NOTE records directly after the MSODRAWIING records.
</span><span class="inferred1"><a name="line4638"></a>4638    #
</span><span class="marked0"><a name="line4639"></a>4639    def store_comments
</span><span class="uncovered1"><a name="line4640"></a>4640        record          = 0x00EC           # Record identifier
</span><span class="uncovered0"><a name="line4641"></a>4641        length          = 0x0000           # Bytes to follow
</span><span class="uncovered1"><a name="line4642"></a>4642    
</span><span class="uncovered0"><a name="line4643"></a>4643        ids             = @object_ids
</span><span class="uncovered1"><a name="line4644"></a>4644        spid            = ids.shift
</span><span class="uncovered0"><a name="line4645"></a>4645    
</span><span class="uncovered1"><a name="line4646"></a>4646        comments        = @comments_array
</span><span class="uncovered0"><a name="line4647"></a>4647        num_comments    = @comments.size
</span><span class="uncovered1"><a name="line4648"></a>4648    
</span><span class="uncovered0"><a name="line4649"></a>4649        # Number of objects written so far.
</span><span class="uncovered1"><a name="line4650"></a>4650        num_objects     = @images_array.size + @filter_count + @charts_array.size
</span><span class="uncovered0"><a name="line4651"></a>4651    
</span><span class="uncovered1"><a name="line4652"></a>4652        # Skip this if there aren't any comments.
</span><span class="uncovered0"><a name="line4653"></a>4653        return if num_comments == 0
</span><span class="uncovered1"><a name="line4654"></a>4654    
</span><span class="uncovered0"><a name="line4655"></a>4655        (0 .. num_comments-1).each do |i|
</span><span class="uncovered1"><a name="line4656"></a>4656            row         = comments[i][0]
</span><span class="uncovered0"><a name="line4657"></a>4657            col         = comments[i][1]
</span><span class="uncovered1"><a name="line4658"></a>4658            str         = comments[i][2]
</span><span class="uncovered0"><a name="line4659"></a>4659            encoding    = comments[i][3]
</span><span class="uncovered1"><a name="line4660"></a>4660            visible     = comments[i][6]
</span><span class="uncovered0"><a name="line4661"></a>4661            color       = comments[i][7]
</span><span class="uncovered1"><a name="line4662"></a>4662            vertices    = comments[i][8]
</span><span class="uncovered0"><a name="line4663"></a>4663            str_len     = str.length
</span><span class="uncovered1"><a name="line4664"></a>4664            str_len     = str_len / 2 if encoding != 0 # Num of chars not bytes.
</span><span class="uncovered0"><a name="line4665"></a>4665            formats     = [[0, 5], [str_len, 0]]
</span><span class="uncovered1"><a name="line4666"></a>4666    
</span><span class="uncovered0"><a name="line4667"></a>4667            if i == 0 and num_objects != 0
</span><span class="uncovered1"><a name="line4668"></a>4668                # Write the parent MSODRAWIING record.
</span><span class="uncovered0"><a name="line4669"></a>4669                dg_length   = 200 + 128*(num_comments -1)
</span><span class="uncovered1"><a name="line4670"></a>4670                spgr_length = 176 + 128*(num_comments -1)
</span><span class="uncovered0"><a name="line4671"></a>4671    
</span><span class="uncovered1"><a name="line4672"></a>4672                data = store_mso_dg_container(dg_length)          +
</span><span class="uncovered0"><a name="line4673"></a>4673                   store_mso_dg(ids)                              +
</span><span class="uncovered1"><a name="line4674"></a>4674                   store_mso_spgr_container(spgr_length)          +
</span><span class="uncovered0"><a name="line4675"></a>4675                   store_mso_sp_container(40)                     +
</span><span class="uncovered1"><a name="line4676"></a>4676                   store_mso_spgr()                               +
</span><span class="uncovered0"><a name="line4677"></a>4677                   store_mso_sp(0x0, spid, 0x0005)
</span><span class="uncovered1"><a name="line4678"></a>4678                spid = spid + 1
</span><span class="uncovered0"><a name="line4679"></a>4679                data = data + store_mso_sp_container(120)         +
</span><span class="uncovered1"><a name="line4680"></a>4680                   store_mso_sp(202, spid, 0x0A00)                +
</span><span class="uncovered0"><a name="line4681"></a>4681                   store_mso_opt_comment(0x80, visible, color)    +
</span><span class="uncovered1"><a name="line4682"></a>4682                   store_mso_client_anchor(3, vertices)           +
</span><span class="uncovered0"><a name="line4683"></a>4683                   store_mso_client_data()
</span><span class="uncovered1"><a name="line4684"></a>4684                spid = spid + 1
</span><span class="uncovered0"><a name="line4685"></a>4685    
</span><span class="uncovered1"><a name="line4686"></a>4686            else
</span><span class="uncovered0"><a name="line4687"></a>4687                # Write the child MSODRAWIING record.
</span><span class="uncovered1"><a name="line4688"></a>4688                data = store_mso_sp_container(120)                +
</span><span class="uncovered0"><a name="line4689"></a>4689                   store_mso_sp(202, spid, 0x0A00)                +
</span><span class="uncovered1"><a name="line4690"></a>4690                   store_mso_opt_comment(0x80, visible, color)    +
</span><span class="uncovered0"><a name="line4691"></a>4691                   store_mso_client_anchor(3, vertices)           +
</span><span class="uncovered1"><a name="line4692"></a>4692                   store_mso_client_data()
</span><span class="uncovered0"><a name="line4693"></a>4693                spid = spid + 1
</span><span class="uncovered1"><a name="line4694"></a>4694            end
</span><span class="uncovered0"><a name="line4695"></a>4695            length      = data.length
</span><span class="uncovered1"><a name="line4696"></a>4696            header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line4697"></a>4697            append(eader, data)
</span><span class="uncovered1"><a name="line4698"></a>4698    
</span><span class="uncovered0"><a name="line4699"></a>4699            store_obj_comment(num_objects + i + 1)
</span><span class="uncovered1"><a name="line4700"></a>4700            store_mso_drawing_text_box()
</span><span class="uncovered0"><a name="line4701"></a>4701            store_txo(str_len)
</span><span class="uncovered1"><a name="line4702"></a>4702            store_txo_continue_1(str, encoding)
</span><span class="uncovered0"><a name="line4703"></a>4703            store_txo_continue_2(formats)
</span><span class="uncovered1"><a name="line4704"></a>4704        end
</span><span class="uncovered0"><a name="line4705"></a>4705    
</span><span class="uncovered1"><a name="line4706"></a>4706        # Write the NOTE records after MSODRAWIING records.
</span><span class="uncovered0"><a name="line4707"></a>4707        (0 .. num_comments-1).each do |i|
</span><span class="uncovered1"><a name="line4708"></a>4708            row         = comments[i][0]
</span><span class="uncovered0"><a name="line4709"></a>4709            col         = comments[i][1]
</span><span class="uncovered1"><a name="line4710"></a>4710            author      = comments[i][4]
</span><span class="uncovered0"><a name="line4711"></a>4711            author_enc  = comments[i][5]
</span><span class="uncovered1"><a name="line4712"></a>4712            visible     = comments[i][6]
</span><span class="uncovered0"><a name="line4713"></a>4713    
</span><span class="uncovered1"><a name="line4714"></a>4714            store_note(row, col, num_objects + i + 1,
</span><span class="uncovered0"><a name="line4715"></a>4715                               author, author_enc, visible)
</span><span class="uncovered1"><a name="line4716"></a>4716        end
</span><span class="uncovered0"><a name="line4717"></a>4717    end
</span><span class="inferred1"><a name="line4718"></a>4718    
</span><span class="inferred0"><a name="line4719"></a>4719    ###############################################################################
</span><span class="inferred1"><a name="line4720"></a>4720    #
</span><span class="inferred0"><a name="line4721"></a>4721    # _store_mso_dg_container()
</span><span class="inferred1"><a name="line4722"></a>4722    #
</span><span class="inferred0"><a name="line4723"></a>4723    # Write the Escher DgContainer record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4724"></a>4724    #
</span><span class="marked0"><a name="line4725"></a>4725    def store_mso_dg_container(length)
</span><span class="uncovered1"><a name="line4726"></a>4726        type        = 0xF002
</span><span class="uncovered0"><a name="line4727"></a>4727        version     = 15
</span><span class="uncovered1"><a name="line4728"></a>4728        instance    = 0
</span><span class="uncovered0"><a name="line4729"></a>4729        data        = ''
</span><span class="uncovered1"><a name="line4730"></a>4730        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4731"></a>4731    end
</span><span class="inferred1"><a name="line4732"></a>4732    
</span><span class="inferred0"><a name="line4733"></a>4733    ###############################################################################
</span><span class="inferred1"><a name="line4734"></a>4734    #
</span><span class="inferred0"><a name="line4735"></a>4735    # _store_mso_dg()
</span><span class="inferred1"><a name="line4736"></a>4736    #
</span><span class="inferred0"><a name="line4737"></a>4737    # Write the Escher Dg record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4738"></a>4738    #
</span><span class="marked0"><a name="line4739"></a>4739    def store_mso_dg(instance, num_shapes, max_spid)
</span><span class="uncovered1"><a name="line4740"></a>4740        type        = 0xF008
</span><span class="uncovered0"><a name="line4741"></a>4741        version     = 0
</span><span class="uncovered1"><a name="line4742"></a>4742        data        = ''
</span><span class="uncovered0"><a name="line4743"></a>4743        length      = 8
</span><span class="uncovered1"><a name="line4744"></a>4744        data        = [num_shapes, max_spid].pack(&quot;VV&quot;)
</span><span class="uncovered0"><a name="line4745"></a>4745    
</span><span class="uncovered1"><a name="line4746"></a>4746        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4747"></a>4747    end
</span><span class="inferred1"><a name="line4748"></a>4748    
</span><span class="inferred0"><a name="line4749"></a>4749    ###############################################################################
</span><span class="inferred1"><a name="line4750"></a>4750    #
</span><span class="inferred0"><a name="line4751"></a>4751    # _store_mso_spgr_container()
</span><span class="inferred1"><a name="line4752"></a>4752    #
</span><span class="inferred0"><a name="line4753"></a>4753    # Write the Escher SpgrContainer record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4754"></a>4754    #
</span><span class="marked0"><a name="line4755"></a>4755    def store_mso_spgr_container(length)
</span><span class="uncovered1"><a name="line4756"></a>4756        type        = 0xF003
</span><span class="uncovered0"><a name="line4757"></a>4757        version     = 15
</span><span class="uncovered1"><a name="line4758"></a>4758        instance    = 0
</span><span class="uncovered0"><a name="line4759"></a>4759        data        = ''
</span><span class="uncovered1"><a name="line4760"></a>4760    
</span><span class="uncovered0"><a name="line4761"></a>4761        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line4762"></a>4762    end
</span><span class="inferred0"><a name="line4763"></a>4763    
</span><span class="inferred1"><a name="line4764"></a>4764    ###############################################################################
</span><span class="inferred0"><a name="line4765"></a>4765    #
</span><span class="inferred1"><a name="line4766"></a>4766    # _store_mso_sp_container()
</span><span class="inferred0"><a name="line4767"></a>4767    #
</span><span class="inferred1"><a name="line4768"></a>4768    # Write the Escher SpContainer record that is part of MSODRAWING.
</span><span class="inferred0"><a name="line4769"></a>4769    #
</span><span class="marked1"><a name="line4770"></a>4770    def store_mso_sp_container(length)
</span><span class="uncovered0"><a name="line4771"></a>4771        type        = 0xF004
</span><span class="uncovered1"><a name="line4772"></a>4772        version     = 15
</span><span class="uncovered0"><a name="line4773"></a>4773        instance    = 0
</span><span class="uncovered1"><a name="line4774"></a>4774        data        = ''
</span><span class="uncovered0"><a name="line4775"></a>4775    
</span><span class="uncovered1"><a name="line4776"></a>4776        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4777"></a>4777    end
</span><span class="inferred1"><a name="line4778"></a>4778    
</span><span class="inferred0"><a name="line4779"></a>4779    ###############################################################################
</span><span class="inferred1"><a name="line4780"></a>4780    #
</span><span class="inferred0"><a name="line4781"></a>4781    # _store_mso_spgr()
</span><span class="inferred1"><a name="line4782"></a>4782    #
</span><span class="inferred0"><a name="line4783"></a>4783    # Write the Escher Spgr record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4784"></a>4784    #
</span><span class="marked0"><a name="line4785"></a>4785    def store_mso_spgr
</span><span class="uncovered1"><a name="line4786"></a>4786        type        = 0xF009
</span><span class="uncovered0"><a name="line4787"></a>4787        version     = 1
</span><span class="uncovered1"><a name="line4788"></a>4788        instance    = 0
</span><span class="uncovered0"><a name="line4789"></a>4789        data        = [0, 0, 0, 0].pack(&quot;VVVV&quot;)
</span><span class="uncovered1"><a name="line4790"></a>4790        length      = 16
</span><span class="uncovered0"><a name="line4791"></a>4791    
</span><span class="uncovered1"><a name="line4792"></a>4792        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4793"></a>4793    end
</span><span class="inferred1"><a name="line4794"></a>4794    
</span><span class="inferred0"><a name="line4795"></a>4795    ###############################################################################
</span><span class="inferred1"><a name="line4796"></a>4796    #
</span><span class="inferred0"><a name="line4797"></a>4797    # _store_mso_sp()
</span><span class="inferred1"><a name="line4798"></a>4798    #
</span><span class="inferred0"><a name="line4799"></a>4799    # Write the Escher Sp record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4800"></a>4800    #
</span><span class="marked0"><a name="line4801"></a>4801    def store_mso_sp(instance, spid, options)
</span><span class="uncovered1"><a name="line4802"></a>4802        type        = 0xF00A
</span><span class="uncovered0"><a name="line4803"></a>4803        version     = 2
</span><span class="uncovered1"><a name="line4804"></a>4804        data        = ''
</span><span class="uncovered0"><a name="line4805"></a>4805        length      = 8
</span><span class="uncovered1"><a name="line4806"></a>4806        data        = [spid, options].pack('VV')
</span><span class="uncovered0"><a name="line4807"></a>4807 
</span><span class="uncovered1"><a name="line4808"></a>4808        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4809"></a>4809    end
</span><span class="inferred1"><a name="line4810"></a>4810    
</span><span class="inferred0"><a name="line4811"></a>4811    ###############################################################################
</span><span class="inferred1"><a name="line4812"></a>4812    #
</span><span class="inferred0"><a name="line4813"></a>4813    # _store_mso_opt_comment()
</span><span class="inferred1"><a name="line4814"></a>4814    #
</span><span class="inferred0"><a name="line4815"></a>4815    # Write the Escher Opt record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4816"></a>4816    #
</span><span class="marked0"><a name="line4817"></a>4817    def store_mso_opt_comment(spid, visible, colour = 0x50)
</span><span class="uncovered1"><a name="line4818"></a>4818        type        = 0xF00B
</span><span class="uncovered0"><a name="line4819"></a>4819        version     = 3
</span><span class="uncovered1"><a name="line4820"></a>4820        instance    = 9
</span><span class="uncovered0"><a name="line4821"></a>4821        data        = ''
</span><span class="uncovered1"><a name="line4822"></a>4822        length      = 54
</span><span class="uncovered0"><a name="line4823"></a>4823    
</span><span class="uncovered1"><a name="line4824"></a>4824        # Use the visible flag if set by the user or else use the worksheet value.
</span><span class="uncovered0"><a name="line4825"></a>4825        # Note that the value used is the opposite of _store_note().
</span><span class="uncovered1"><a name="line4826"></a>4826        #
</span><span class="uncovered0"><a name="line4827"></a>4827        unless visible.nil?
</span><span class="uncovered1"><a name="line4828"></a>4828           visible = visible           ? 0x0000 : 0x0002
</span><span class="uncovered0"><a name="line4829"></a>4829        else
</span><span class="uncovered1"><a name="line4830"></a>4830           visible = @comments_visible ? 0x0000 : 0x0002
</span><span class="uncovered0"><a name="line4831"></a>4831        end
</span><span class="uncovered1"><a name="line4832"></a>4832    
</span><span class="uncovered0"><a name="line4833"></a>4833        data = [spid].pack('V')                            +
</span><span class="uncovered1"><a name="line4834"></a>4834           ['0000BF00080008005801000000008101'].pack(&quot;H*&quot;) +
</span><span class="uncovered0"><a name="line4835"></a>4835           [colour].pack(&quot;C&quot;)                              +
</span><span class="uncovered1"><a name="line4836"></a>4836           ['000008830150000008BF011000110001'+'02000000003F0203000300BF03'].pack(&quot;H*&quot;)  +
</span><span class="uncovered0"><a name="line4837"></a>4837           [visible].pack('c')                             +
</span><span class="uncovered1"><a name="line4838"></a>4838           ['0A00'].pack('H*')
</span><span class="uncovered0"><a name="line4839"></a>4839    
</span><span class="uncovered1"><a name="line4840"></a>4840        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4841"></a>4841    end
</span><span class="inferred1"><a name="line4842"></a>4842    
</span><span class="inferred0"><a name="line4843"></a>4843    ###############################################################################
</span><span class="inferred1"><a name="line4844"></a>4844    #
</span><span class="inferred0"><a name="line4845"></a>4845    # _store_mso_opt_image()
</span><span class="inferred1"><a name="line4846"></a>4846    #
</span><span class="inferred0"><a name="line4847"></a>4847    # Write the Escher Opt record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4848"></a>4848    #
</span><span class="marked0"><a name="line4849"></a>4849    def store_mso_opt_image(spid)
</span><span class="uncovered1"><a name="line4850"></a>4850        type        = 0xF00B
</span><span class="uncovered0"><a name="line4851"></a>4851        version     = 3
</span><span class="uncovered1"><a name="line4852"></a>4852        instance    = 3
</span><span class="uncovered0"><a name="line4853"></a>4853        data        = ''
</span><span class="uncovered1"><a name="line4854"></a>4854        length      = nil
</span><span class="uncovered0"><a name="line4855"></a>4855    
</span><span class="uncovered1"><a name="line4856"></a>4856        data = [0x4104].pack('v') +
</span><span class="uncovered0"><a name="line4857"></a>4857          [spid].pack('V')        +
</span><span class="uncovered1"><a name="line4858"></a>4858          [0x01BF].pack('v')      +
</span><span class="uncovered0"><a name="line4859"></a>4859          [0x00010000].pack('V')  +
</span><span class="uncovered1"><a name="line4860"></a>4860          [0x03BF].pack( 'v')     +
</span><span class="uncovered0"><a name="line4861"></a>4861          [0x00080000].pack( 'V')
</span><span class="uncovered1"><a name="line4862"></a>4862    
</span><span class="uncovered0"><a name="line4863"></a>4863        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line4864"></a>4864    end
</span><span class="inferred0"><a name="line4865"></a>4865    
</span><span class="inferred1"><a name="line4866"></a>4866    ###############################################################################
</span><span class="inferred0"><a name="line4867"></a>4867    #
</span><span class="inferred1"><a name="line4868"></a>4868    # _store_mso_opt_chart()
</span><span class="inferred0"><a name="line4869"></a>4869    #
</span><span class="inferred1"><a name="line4870"></a>4870    # Write the Escher Opt record that is part of MSODRAWING.
</span><span class="inferred0"><a name="line4871"></a>4871    #
</span><span class="marked1"><a name="line4872"></a>4872    def store_mso_opt_chart
</span><span class="uncovered0"><a name="line4873"></a>4873        type        = 0xF00B
</span><span class="uncovered1"><a name="line4874"></a>4874        version     = 3
</span><span class="uncovered0"><a name="line4875"></a>4875        instance    = 9
</span><span class="uncovered1"><a name="line4876"></a>4876        data        = ''
</span><span class="uncovered0"><a name="line4877"></a>4877        length      = nil
</span><span class="uncovered1"><a name="line4878"></a>4878    
</span><span class="uncovered0"><a name="line4879"></a>4879        data = [0x007F].pack('v')       +        # Protection -&gt; fLockAgainstGrouping
</span><span class="uncovered1"><a name="line4880"></a>4880           [0x01040104].pack('V')       +
</span><span class="uncovered0"><a name="line4881"></a>4881           [0x00BF].pack('v')           +        # Text -&gt; fFitTextToShape
</span><span class="uncovered1"><a name="line4882"></a>4882           [0x00080008].pack('V')       +
</span><span class="uncovered0"><a name="line4883"></a>4883           [0x0181].pack('v')           +        # Fill Style -&gt; fillColor
</span><span class="uncovered1"><a name="line4884"></a>4884           [0x0800004E].pack('V')       +
</span><span class="uncovered0"><a name="line4885"></a>4885           [0x0183].pack('v')           +        # Fill Style -&gt; fillBackColor
</span><span class="uncovered1"><a name="line4886"></a>4886           [0x0800004D].pack('V')       +
</span><span class="uncovered0"><a name="line4887"></a>4887    
</span><span class="uncovered1"><a name="line4888"></a>4888           [0x01BF].pack('v')           +         # Fill Style -&gt; fNoFillHitTest
</span><span class="uncovered0"><a name="line4889"></a>4889           [0x00110010].pack('V')       +
</span><span class="uncovered1"><a name="line4890"></a>4890           [0x01C0].pack('v')           +        # Line Style -&gt; lineColor
</span><span class="uncovered0"><a name="line4891"></a>4891           [0x0800004D].pack('V')       +
</span><span class="uncovered1"><a name="line4892"></a>4892           [0x01FF].pack('v')           +        # Line Style -&gt; fNoLineDrawDash
</span><span class="uncovered0"><a name="line4893"></a>4893           [0x00080008].pack('V')       +
</span><span class="uncovered1"><a name="line4894"></a>4894           [0x023F].pack('v')            +        # Shadow Style -&gt; fshadowObscured
</span><span class="uncovered0"><a name="line4895"></a>4895           [0x00020000].pack('V')       +
</span><span class="uncovered1"><a name="line4896"></a>4896           [0x03BF].pack('v')           +        # Group Shape -&gt; fPrint
</span><span class="uncovered0"><a name="line4897"></a>4897           [0x00080000].pack('V')
</span><span class="uncovered1"><a name="line4898"></a>4898    
</span><span class="uncovered0"><a name="line4899"></a>4899        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line4900"></a>4900    end
</span><span class="inferred0"><a name="line4901"></a>4901    
</span><span class="inferred1"><a name="line4902"></a>4902    ###############################################################################
</span><span class="inferred0"><a name="line4903"></a>4903    #
</span><span class="inferred1"><a name="line4904"></a>4904    # _store_mso_opt_filter()
</span><span class="inferred0"><a name="line4905"></a>4905    #
</span><span class="inferred1"><a name="line4906"></a>4906    # Write the Escher Opt record that is part of MSODRAWING.
</span><span class="inferred0"><a name="line4907"></a>4907    #
</span><span class="marked1"><a name="line4908"></a>4908    def store_mso_opt_filter
</span><span class="uncovered0"><a name="line4909"></a>4909        type        = 0xF00B
</span><span class="uncovered1"><a name="line4910"></a>4910        version     = 3
</span><span class="uncovered0"><a name="line4911"></a>4911        instance    = 5
</span><span class="uncovered1"><a name="line4912"></a>4912        data        = ''
</span><span class="uncovered0"><a name="line4913"></a>4913        length      = nil
</span><span class="uncovered1"><a name="line4914"></a>4914    
</span><span class="uncovered0"><a name="line4915"></a>4915        data = [0x007F].pack('v')     +    # Protection -&gt; fLockAgainstGrouping
</span><span class="uncovered1"><a name="line4916"></a>4916           [0x01040104].pack('V')     +
</span><span class="uncovered0"><a name="line4917"></a>4917           [0x00BF].pack('v')    +        # Text -&gt; fFitTextToShape
</span><span class="uncovered1"><a name="line4918"></a>4918           [0x00080008].pack('V')+
</span><span class="uncovered0"><a name="line4919"></a>4919           [0x01BF].pack('v')    +        # Fill Style -&gt; fNoFillHitTest
</span><span class="uncovered1"><a name="line4920"></a>4920           [0x00010000].pack('V')+
</span><span class="uncovered0"><a name="line4921"></a>4921           [0x01FF].pack('v')    +        # Line Style -&gt; fNoLineDrawDash
</span><span class="uncovered1"><a name="line4922"></a>4922           [0x00080000].pack('V')+
</span><span class="uncovered0"><a name="line4923"></a>4923           [0x03BF].pack('v')    +        # Group Shape -&gt; fPrint
</span><span class="uncovered1"><a name="line4924"></a>4924           [0x000A0000].pack('V')
</span><span class="uncovered0"><a name="line4925"></a>4925    
</span><span class="uncovered1"><a name="line4926"></a>4926        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4927"></a>4927    end
</span><span class="inferred1"><a name="line4928"></a>4928    
</span><span class="inferred0"><a name="line4929"></a>4929    ###############################################################################
</span><span class="inferred1"><a name="line4930"></a>4930    #
</span><span class="inferred0"><a name="line4931"></a>4931    # _store_mso_client_anchor()
</span><span class="inferred1"><a name="line4932"></a>4932    #    my flag         = shift;
</span><span class="inferred0"><a name="line4933"></a>4933    #    my $col_start   = $_[0];    # Col containing upper left corner of object
</span><span class="inferred1"><a name="line4934"></a>4934    #    my $x1          = $_[1];    # Distance to left side of object
</span><span class="inferred0"><a name="line4935"></a>4935    #
</span><span class="inferred1"><a name="line4936"></a>4936    #    my $row_start   = $_[2];    # Row containing top left corner of object
</span><span class="inferred0"><a name="line4937"></a>4937    #    my $y1          = $_[3];    # Distance to top of object
</span><span class="inferred1"><a name="line4938"></a>4938    #
</span><span class="inferred0"><a name="line4939"></a>4939    #    my $col_end     = $_[4];    # Col containing lower right corner of object
</span><span class="inferred1"><a name="line4940"></a>4940    #    my $x2          = $_[5];    # Distance to right side of object
</span><span class="inferred0"><a name="line4941"></a>4941    #
</span><span class="inferred1"><a name="line4942"></a>4942    #    my $row_end     = $_[6];    # Row containing bottom right corner of object
</span><span class="inferred0"><a name="line4943"></a>4943    #    my $y2          = $_[7];    # Distance to bottom of object
</span><span class="inferred1"><a name="line4944"></a>4944    #
</span><span class="inferred0"><a name="line4945"></a>4945    # Write the Escher ClientAnchor record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4946"></a>4946    #
</span><span class="marked0"><a name="line4947"></a>4947    def store_mso_client_anchor(flag, col_start, x1, row_start, y1, col_end, x2, row_end, y2)
</span><span class="uncovered1"><a name="line4948"></a>4948        type        = 0xF010
</span><span class="uncovered0"><a name="line4949"></a>4949        version     = 0
</span><span class="uncovered1"><a name="line4950"></a>4950        instance    = 0
</span><span class="uncovered0"><a name="line4951"></a>4951        data        = ''
</span><span class="uncovered1"><a name="line4952"></a>4952        length      = 18
</span><span class="uncovered0"><a name="line4953"></a>4953    
</span><span class="uncovered1"><a name="line4954"></a>4954        data = [flag, col_start, x1, row_start, y1, col_end, x2, row_end, y2].pack( &quot;v9&quot;)
</span><span class="uncovered0"><a name="line4955"></a>4955    
</span><span class="uncovered1"><a name="line4956"></a>4956        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4957"></a>4957    end
</span><span class="inferred1"><a name="line4958"></a>4958    
</span><span class="inferred0"><a name="line4959"></a>4959    ###############################################################################
</span><span class="inferred1"><a name="line4960"></a>4960    #
</span><span class="inferred0"><a name="line4961"></a>4961    # _store_mso_client_data()
</span><span class="inferred1"><a name="line4962"></a>4962    #
</span><span class="inferred0"><a name="line4963"></a>4963    # Write the Escher ClientData record that is part of MSODRAWING.
</span><span class="inferred1"><a name="line4964"></a>4964    #
</span><span class="marked0"><a name="line4965"></a>4965    def store_mso_client_data
</span><span class="uncovered1"><a name="line4966"></a>4966        type        = 0xF011
</span><span class="uncovered0"><a name="line4967"></a>4967        version     = 0
</span><span class="uncovered1"><a name="line4968"></a>4968        instance    = 0
</span><span class="uncovered0"><a name="line4969"></a>4969        data        = ''
</span><span class="uncovered1"><a name="line4970"></a>4970        length      = 0
</span><span class="uncovered0"><a name="line4971"></a>4971    
</span><span class="uncovered1"><a name="line4972"></a>4972        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered0"><a name="line4973"></a>4973    end
</span><span class="inferred1"><a name="line4974"></a>4974    
</span><span class="inferred0"><a name="line4975"></a>4975    ###############################################################################
</span><span class="inferred1"><a name="line4976"></a>4976    #
</span><span class="inferred0"><a name="line4977"></a>4977    # _store_obj_comment()
</span><span class="inferred1"><a name="line4978"></a>4978    #    my $obj_id      = $_[0];    # Object ID number.
</span><span class="inferred0"><a name="line4979"></a>4979    #
</span><span class="inferred1"><a name="line4980"></a>4980    # Write the OBJ record that is part of cell comments.
</span><span class="inferred0"><a name="line4981"></a>4981    #
</span><span class="marked1"><a name="line4982"></a>4982    def store_obj_comment(obj_id)
</span><span class="uncovered0"><a name="line4983"></a>4983        record      = 0x005D   # Record identifier
</span><span class="uncovered1"><a name="line4984"></a>4984        length      = 0x0034   # Bytes to follow
</span><span class="uncovered0"><a name="line4985"></a>4985    
</span><span class="uncovered1"><a name="line4986"></a>4986        obj_type    = 0x0019   # Object type (comment).
</span><span class="uncovered0"><a name="line4987"></a>4987        data        = ''       # Record data.
</span><span class="uncovered1"><a name="line4988"></a>4988    
</span><span class="uncovered0"><a name="line4989"></a>4989        sub_record  = 0x0000   # Sub-record identifier.
</span><span class="uncovered1"><a name="line4990"></a>4990        sub_length  = 0x0000   # Length of sub-record.
</span><span class="uncovered0"><a name="line4991"></a>4991        sub_data    = ''       # Data of sub-record.
</span><span class="uncovered1"><a name="line4992"></a>4992        options     = 0x4011
</span><span class="uncovered0"><a name="line4993"></a>4993        reserved    = 0x0000
</span><span class="uncovered1"><a name="line4994"></a>4994    
</span><span class="uncovered0"><a name="line4995"></a>4995        # Add ftCmo (common object data) subobject
</span><span class="uncovered1"><a name="line4996"></a>4996        sub_record     = 0x0015   # ftCmo
</span><span class="uncovered0"><a name="line4997"></a>4997        sub_length     = 0x0012
</span><span class="uncovered1"><a name="line4998"></a>4998        sub_data       = [obj_type, obj_id, options, reserved, reserved, reserved].pack( &quot;vvvVVV&quot;)
</span><span class="uncovered0"><a name="line4999"></a>4999        data           = [sub_record, sub_length].pack(&quot;vv&quot;) + sub_data
</span><span class="uncovered1"><a name="line5000"></a>5000    
</span><span class="uncovered0"><a name="line5001"></a>5001        # Add ftNts (note structure) subobject
</span><span class="uncovered1"><a name="line5002"></a>5002        sub_record  = 0x000D   # ftNts
</span><span class="uncovered0"><a name="line5003"></a>5003        sub_length  = 0x0016
</span><span class="uncovered1"><a name="line5004"></a>5004        sub_data    = [reserved,reserved,reserved,reserved,reserved,reserved].pack( &quot;VVVVVv&quot;)
</span><span class="uncovered0"><a name="line5005"></a>5005        data        = [sub_record, sub_length].pack(&quot;vv&quot;) + sub_data
</span><span class="uncovered1"><a name="line5006"></a>5006    
</span><span class="uncovered0"><a name="line5007"></a>5007        # Add ftEnd (end of object) subobject
</span><span class="uncovered1"><a name="line5008"></a>5008        sub_record  = 0x0000   # ftNts
</span><span class="uncovered0"><a name="line5009"></a>5009        sub_length  = 0x0000
</span><span class="uncovered1"><a name="line5010"></a>5010        data        = data + [sub_record, sub_length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line5011"></a>5011    
</span><span class="uncovered1"><a name="line5012"></a>5012        # Pack the record.
</span><span class="uncovered0"><a name="line5013"></a>5013        header      = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line5014"></a>5014    
</span><span class="uncovered0"><a name="line5015"></a>5015        append(header, data)
</span><span class="uncovered1"><a name="line5016"></a>5016    
</span><span class="uncovered0"><a name="line5017"></a>5017    end
</span><span class="inferred1"><a name="line5018"></a>5018    
</span><span class="inferred0"><a name="line5019"></a>5019    ###############################################################################
</span><span class="inferred1"><a name="line5020"></a>5020    #
</span><span class="inferred0"><a name="line5021"></a>5021    # _store_obj_image()
</span><span class="inferred1"><a name="line5022"></a>5022    #    my $obj_id      = $_[0];    # Object ID number.
</span><span class="inferred0"><a name="line5023"></a>5023    #
</span><span class="inferred1"><a name="line5024"></a>5024    # Write the OBJ record that is part of image records.
</span><span class="inferred0"><a name="line5025"></a>5025    #
</span><span class="marked1"><a name="line5026"></a>5026    def store_obj_image(obj_id)
</span><span class="uncovered0"><a name="line5027"></a>5027        record      = 0x005D   # Record identifier
</span><span class="uncovered1"><a name="line5028"></a>5028        length      = 0x0026   # Bytes to follow
</span><span class="uncovered0"><a name="line5029"></a>5029    
</span><span class="uncovered1"><a name="line5030"></a>5030        obj_type    = 0x0008   # Object type (Picture).
</span><span class="uncovered0"><a name="line5031"></a>5031        data        = ''       # Record data.
</span><span class="uncovered1"><a name="line5032"></a>5032    
</span><span class="uncovered0"><a name="line5033"></a>5033        sub_record  = 0x0000   # Sub-record identifier.
</span><span class="uncovered1"><a name="line5034"></a>5034        sub_length  = 0x0000   # Length of sub-record.
</span><span class="uncovered0"><a name="line5035"></a>5035        sub_data    = ''       # Data of sub-record.
</span><span class="uncovered1"><a name="line5036"></a>5036        options     = 0x6011
</span><span class="uncovered0"><a name="line5037"></a>5037        reserved    = 0x0000
</span><span class="uncovered1"><a name="line5038"></a>5038    
</span><span class="uncovered0"><a name="line5039"></a>5039        # Add ftCmo (common object data) subobject
</span><span class="uncovered1"><a name="line5040"></a>5040        sub_record  = 0x0015   # ftCmo
</span><span class="uncovered0"><a name="line5041"></a>5041        sub_length  = 0x0012
</span><span class="uncovered1"><a name="line5042"></a>5042        sub_data    = [obj_type, obj_id, options, reserved, reserved, reserved].pack('vvvVVV')
</span><span class="uncovered0"><a name="line5043"></a>5043        data        = [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered1"><a name="line5044"></a>5044    
</span><span class="uncovered0"><a name="line5045"></a>5045        # Add ftCf (Clipboard format) subobject
</span><span class="uncovered1"><a name="line5046"></a>5046        sub_record  = 0x0007   # ftCf
</span><span class="uncovered0"><a name="line5047"></a>5047        sub_length  = 0x0002
</span><span class="uncovered1"><a name="line5048"></a>5048        sub_data    = [0xFFFF].pack( 'v')
</span><span class="uncovered0"><a name="line5049"></a>5049        data        = data + [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered1"><a name="line5050"></a>5050    
</span><span class="uncovered0"><a name="line5051"></a>5051        # Add ftPioGrbit (Picture option flags) subobject
</span><span class="uncovered1"><a name="line5052"></a>5052        sub_record  = 0x0008   # ftPioGrbit
</span><span class="uncovered0"><a name="line5053"></a>5053        sub_length  = 0x0002
</span><span class="uncovered1"><a name="line5054"></a>5054        sub_data    = [0x0001].pack('v')
</span><span class="uncovered0"><a name="line5055"></a>5055        data        = data + [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered1"><a name="line5056"></a>5056    
</span><span class="uncovered0"><a name="line5057"></a>5057        # Add ftEnd (end of object) subobject
</span><span class="uncovered1"><a name="line5058"></a>5058        sub_record  = 0x0000   # ftNts
</span><span class="uncovered0"><a name="line5059"></a>5059        sub_length  = 0x0000
</span><span class="uncovered1"><a name="line5060"></a>5060        data        = data + [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered0"><a name="line5061"></a>5061 
</span><span class="uncovered1"><a name="line5062"></a>5062        # Pack the record.
</span><span class="uncovered0"><a name="line5063"></a>5063        header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line5064"></a>5064    
</span><span class="uncovered0"><a name="line5065"></a>5065        append(header, data)
</span><span class="uncovered1"><a name="line5066"></a>5066    
</span><span class="uncovered0"><a name="line5067"></a>5067    end
</span><span class="inferred1"><a name="line5068"></a>5068    
</span><span class="inferred0"><a name="line5069"></a>5069    
</span><span class="inferred1"><a name="line5070"></a>5070    ###############################################################################
</span><span class="inferred0"><a name="line5071"></a>5071    #
</span><span class="inferred1"><a name="line5072"></a>5072    # _store_obj_chart()
</span><span class="inferred0"><a name="line5073"></a>5073    #    my $obj_id      = $_[0];    # Object ID number.
</span><span class="inferred1"><a name="line5074"></a>5074    #
</span><span class="inferred0"><a name="line5075"></a>5075    # Write the OBJ record that is part of chart records.
</span><span class="inferred1"><a name="line5076"></a>5076    #
</span><span class="marked0"><a name="line5077"></a>5077    def store_obj_chart(obj_id)
</span><span class="uncovered1"><a name="line5078"></a>5078        record      = 0x005D   # Record identifier
</span><span class="uncovered0"><a name="line5079"></a>5079        length      = 0x001A   # Bytes to follow
</span><span class="uncovered1"><a name="line5080"></a>5080    
</span><span class="uncovered0"><a name="line5081"></a>5081        obj_type    = 0x0005   # Object type (chart).
</span><span class="uncovered1"><a name="line5082"></a>5082        data        = ''       # Record data.
</span><span class="uncovered0"><a name="line5083"></a>5083    
</span><span class="uncovered1"><a name="line5084"></a>5084        sub_record  = 0x0000   # Sub-record identifier.
</span><span class="uncovered0"><a name="line5085"></a>5085        sub_length  = 0x0000   # Length of sub-record.
</span><span class="uncovered1"><a name="line5086"></a>5086        sub_data    = ''       # Data of sub-record.
</span><span class="uncovered0"><a name="line5087"></a>5087        options     = 0x6011
</span><span class="uncovered1"><a name="line5088"></a>5088        reserved    = 0x0000
</span><span class="uncovered0"><a name="line5089"></a>5089    
</span><span class="uncovered1"><a name="line5090"></a>5090        # Add ftCmo (common object data) subobject
</span><span class="uncovered0"><a name="line5091"></a>5091        sub_record  = 0x0015   # ftCmo
</span><span class="uncovered1"><a name="line5092"></a>5092        sub_length  = 0x0012
</span><span class="uncovered0"><a name="line5093"></a>5093        sub_data    = [obj_type, obj_id, options, reserved, reserved, reserved].pack('vvvVVV')
</span><span class="uncovered1"><a name="line5094"></a>5094        data        = [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered0"><a name="line5095"></a>5095    
</span><span class="uncovered1"><a name="line5096"></a>5096        # Add ftEnd (end of object) subobject
</span><span class="uncovered0"><a name="line5097"></a>5097        sub_record  = 0x0000   # ftNts
</span><span class="uncovered1"><a name="line5098"></a>5098        sub_length  = 0x0000
</span><span class="uncovered0"><a name="line5099"></a>5099        data        = data + [sub_record, sub_length].pack('vv')
</span><span class="uncovered1"><a name="line5100"></a>5100    
</span><span class="uncovered0"><a name="line5101"></a>5101        # Pack the record.
</span><span class="uncovered1"><a name="line5102"></a>5102        header  = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line5103"></a>5103    
</span><span class="uncovered1"><a name="line5104"></a>5104        append(header, data)
</span><span class="uncovered0"><a name="line5105"></a>5105    
</span><span class="uncovered1"><a name="line5106"></a>5106    end
</span><span class="inferred0"><a name="line5107"></a>5107    
</span><span class="inferred1"><a name="line5108"></a>5108    ###############################################################################
</span><span class="inferred0"><a name="line5109"></a>5109    #
</span><span class="inferred1"><a name="line5110"></a>5110    # _store_obj_filter()
</span><span class="inferred0"><a name="line5111"></a>5111    #    my $obj_id      = $_[0];    # Object ID number.
</span><span class="inferred1"><a name="line5112"></a>5112    #    my $col         = $_[1];
</span><span class="inferred0"><a name="line5113"></a>5113    #
</span><span class="inferred1"><a name="line5114"></a>5114    # Write the OBJ record that is part of filter records.
</span><span class="inferred0"><a name="line5115"></a>5115    #
</span><span class="marked1"><a name="line5116"></a>5116    def store_obj_filter(obj_id, col)
</span><span class="uncovered0"><a name="line5117"></a>5117        record      = 0x005D   # Record identifier
</span><span class="uncovered1"><a name="line5118"></a>5118        length      = 0x0046   # Bytes to follow
</span><span class="uncovered0"><a name="line5119"></a>5119    
</span><span class="uncovered1"><a name="line5120"></a>5120        obj_type    = 0x0014   # Object type (combo box).
</span><span class="uncovered0"><a name="line5121"></a>5121        data        = ''       # Record data.
</span><span class="uncovered1"><a name="line5122"></a>5122    
</span><span class="uncovered0"><a name="line5123"></a>5123        sub_record  = 0x0000   # Sub-record identifier.
</span><span class="uncovered1"><a name="line5124"></a>5124        sub_length  = 0x0000   # Length of sub-record.
</span><span class="uncovered0"><a name="line5125"></a>5125        sub_data    = ''       # Data of sub-record.
</span><span class="uncovered1"><a name="line5126"></a>5126        options     = 0x2101
</span><span class="uncovered0"><a name="line5127"></a>5127        reserved    = 0x0000
</span><span class="uncovered1"><a name="line5128"></a>5128    
</span><span class="uncovered0"><a name="line5129"></a>5129        # Add ftCmo (common object data) subobject
</span><span class="uncovered1"><a name="line5130"></a>5130        sub_record  = 0x0015   # ftCmo
</span><span class="uncovered0"><a name="line5131"></a>5131        sub_length  = 0x0012
</span><span class="uncovered1"><a name="line5132"></a>5132        sub_data    = [obj_type, obj_id, options, reserved, reserved, reserved].pack('vvvVVV')
</span><span class="uncovered0"><a name="line5133"></a>5133        data        = [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered1"><a name="line5134"></a>5134    
</span><span class="uncovered0"><a name="line5135"></a>5135        # Add ftSbs Scroll bar subobject
</span><span class="uncovered1"><a name="line5136"></a>5136        sub_record  = 0x000C   # ftSbs
</span><span class="uncovered0"><a name="line5137"></a>5137        sub_length  = 0x0014
</span><span class="uncovered1"><a name="line5138"></a>5138        sub_data    = ['0000000000000000640001000A00000010000100'].pack('H*')
</span><span class="uncovered0"><a name="line5139"></a>5139        data        = data + [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered1"><a name="line5140"></a>5140    
</span><span class="uncovered0"><a name="line5141"></a>5141        # Add ftLbsData (List box data) subobject
</span><span class="uncovered1"><a name="line5142"></a>5142        sub_record  = 0x0013   # ftLbsData
</span><span class="uncovered0"><a name="line5143"></a>5143        sub_length  = 0x1FEE   # Special case (undocumented).
</span><span class="uncovered1"><a name="line5144"></a>5144    
</span><span class="uncovered0"><a name="line5145"></a>5145        # If the filter is active we set one of the undocumented flags.
</span><span class="uncovered1"><a name="line5146"></a>5146    
</span><span class="uncovered0"><a name="line5147"></a>5147        if @filter_cols[col]
</span><span class="uncovered1"><a name="line5148"></a>5148            sub_data       = ['000000000100010300000A0008005700'].pack('H*')
</span><span class="uncovered0"><a name="line5149"></a>5149        else
</span><span class="uncovered1"><a name="line5150"></a>5150            sub_data       = ['00000000010001030000020008005700'].pack('H*')
</span><span class="uncovered0"><a name="line5151"></a>5151        end
</span><span class="uncovered1"><a name="line5152"></a>5152    
</span><span class="uncovered0"><a name="line5153"></a>5153        data        = data + [sub_record, sub_length].pack('vv') + sub_data
</span><span class="uncovered1"><a name="line5154"></a>5154    
</span><span class="uncovered0"><a name="line5155"></a>5155        # Add ftEnd (end of object) subobject
</span><span class="uncovered1"><a name="line5156"></a>5156        sub_record  = 0x0000   # ftNts
</span><span class="uncovered0"><a name="line5157"></a>5157        sub_length  = 0x0000
</span><span class="uncovered1"><a name="line5158"></a>5158        data        = data + [sub_record, sub_length].pack('vv')
</span><span class="uncovered0"><a name="line5159"></a>5159    
</span><span class="uncovered1"><a name="line5160"></a>5160        # Pack the record.
</span><span class="uncovered0"><a name="line5161"></a>5161        header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line5162"></a>5162    
</span><span class="uncovered0"><a name="line5163"></a>5163        append(header, data)
</span><span class="uncovered1"><a name="line5164"></a>5164    end
</span><span class="inferred0"><a name="line5165"></a>5165    
</span><span class="inferred1"><a name="line5166"></a>5166    ###############################################################################
</span><span class="inferred0"><a name="line5167"></a>5167    #
</span><span class="inferred1"><a name="line5168"></a>5168    # _store_mso_drawing_text_box()
</span><span class="inferred0"><a name="line5169"></a>5169    #
</span><span class="inferred1"><a name="line5170"></a>5170    # Write the MSODRAWING ClientTextbox record that is part of comments.
</span><span class="inferred0"><a name="line5171"></a>5171    #
</span><span class="marked1"><a name="line5172"></a>5172    def store_mso_drawing_text_box
</span><span class="uncovered0"><a name="line5173"></a>5173        record      = 0x00EC           # Record identifier
</span><span class="uncovered1"><a name="line5174"></a>5174        length      = 0x0008           # Bytes to follow
</span><span class="uncovered0"><a name="line5175"></a>5175    
</span><span class="uncovered1"><a name="line5176"></a>5176        data        = store_mso_client_text_box()
</span><span class="uncovered0"><a name="line5177"></a>5177        header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line5178"></a>5178    
</span><span class="uncovered0"><a name="line5179"></a>5179        append(header, data)
</span><span class="uncovered1"><a name="line5180"></a>5180    end
</span><span class="inferred0"><a name="line5181"></a>5181    
</span><span class="inferred1"><a name="line5182"></a>5182    ###############################################################################
</span><span class="inferred0"><a name="line5183"></a>5183    #
</span><span class="inferred1"><a name="line5184"></a>5184    # _store_mso_client_text_box()
</span><span class="inferred0"><a name="line5185"></a>5185    #
</span><span class="inferred1"><a name="line5186"></a>5186    # Write the Escher ClientTextbox record that is part of MSODRAWING.
</span><span class="inferred0"><a name="line5187"></a>5187    #
</span><span class="marked1"><a name="line5188"></a>5188    def store_mso_client_text_box
</span><span class="uncovered0"><a name="line5189"></a>5189        type        = 0xF00D
</span><span class="uncovered1"><a name="line5190"></a>5190        version     = 0
</span><span class="uncovered0"><a name="line5191"></a>5191        instance    = 0
</span><span class="uncovered1"><a name="line5192"></a>5192        data        = ''
</span><span class="uncovered0"><a name="line5193"></a>5193        length      = 0
</span><span class="uncovered1"><a name="line5194"></a>5194    
</span><span class="uncovered0"><a name="line5195"></a>5195        return add_mso_generic(type, version, instance, data, length)
</span><span class="uncovered1"><a name="line5196"></a>5196    end
</span><span class="inferred0"><a name="line5197"></a>5197    
</span><span class="inferred1"><a name="line5198"></a>5198    ###############################################################################
</span><span class="inferred0"><a name="line5199"></a>5199    #
</span><span class="inferred1"><a name="line5200"></a>5200    # _store_txo()
</span><span class="inferred0"><a name="line5201"></a>5201    #    my $string_len  = $_[0];                # Length of the note text.
</span><span class="inferred1"><a name="line5202"></a>5202    #    my $format_len  = $_[1] || 16;          # Length of the format runs.
</span><span class="inferred0"><a name="line5203"></a>5203    #    my $rotation    = $_[2] || 0;           # Options
</span><span class="inferred1"><a name="line5204"></a>5204    #
</span><span class="inferred0"><a name="line5205"></a>5205    # Write the worksheet TXO record that is part of cell comments.
</span><span class="inferred1"><a name="line5206"></a>5206    #
</span><span class="marked0"><a name="line5207"></a>5207    def store_txo(string_len, format_len = 16, rotation = 0)
</span><span class="uncovered1"><a name="line5208"></a>5208        record      = 0x01B6               # Record identifier
</span><span class="uncovered0"><a name="line5209"></a>5209        length      = 0x0012               # Bytes to follow
</span><span class="uncovered1"><a name="line5210"></a>5210    
</span><span class="uncovered0"><a name="line5211"></a>5211        grbit       = 0x0212               # Options
</span><span class="uncovered1"><a name="line5212"></a>5212        reserved    = 0x0000               # Options
</span><span class="uncovered0"><a name="line5213"></a>5213    
</span><span class="uncovered1"><a name="line5214"></a>5214        # Pack the record.
</span><span class="uncovered0"><a name="line5215"></a>5215        header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line5216"></a>5216        data    = [grbit, rotation, reserved, reserved,
</span><span class="uncovered0"><a name="line5217"></a>5217                   string_len, format_len, reserved].pack(&quot;vvVvvvV&quot;)
</span><span class="uncovered1"><a name="line5218"></a>5218    
</span><span class="uncovered0"><a name="line5219"></a>5219        append(header, data)
</span><span class="uncovered1"><a name="line5220"></a>5220    end
</span><span class="inferred0"><a name="line5221"></a>5221    
</span><span class="inferred1"><a name="line5222"></a>5222    ###############################################################################
</span><span class="inferred0"><a name="line5223"></a>5223    #
</span><span class="inferred1"><a name="line5224"></a>5224    # _store_txo_continue_1()
</span><span class="inferred0"><a name="line5225"></a>5225    #    my $string      = $_[0];                # Comment string.
</span><span class="inferred1"><a name="line5226"></a>5226    #    my $encoding    = $_[1] || 0;           # Encoding of the string.
</span><span class="inferred0"><a name="line5227"></a>5227    #
</span><span class="inferred1"><a name="line5228"></a>5228    # Write the first CONTINUE record to follow the TXO record. It contains the
</span><span class="inferred0"><a name="line5229"></a>5229    # text data.
</span><span class="inferred1"><a name="line5230"></a>5230    #
</span><span class="marked0"><a name="line5231"></a>5231    def store_txo_continue_1(string, encoding = 0)
</span><span class="uncovered1"><a name="line5232"></a>5232        record      = 0x003C               # Record identifier
</span><span class="uncovered0"><a name="line5233"></a>5233    
</span><span class="uncovered1"><a name="line5234"></a>5234        # Split long comment strings into smaller continue blocks if necessary.
</span><span class="uncovered0"><a name="line5235"></a>5235        # We can't let BIFFwriter::_add_continue() handled this since an extra
</span><span class="uncovered1"><a name="line5236"></a>5236        # encoding byte has to be added similar to the SST block.
</span><span class="uncovered0"><a name="line5237"></a>5237        #
</span><span class="uncovered1"><a name="line5238"></a>5238        # We make the limit size smaller than the _add_continue() size and even
</span><span class="uncovered0"><a name="line5239"></a>5239        # so that UTF16 chars occur in the same block.
</span><span class="uncovered1"><a name="line5240"></a>5240        #
</span><span class="uncovered0"><a name="line5241"></a>5241        limit = 8218
</span><span class="uncovered1"><a name="line5242"></a>5242        while string.length &gt; limit
</span><span class="uncovered0"><a name="line5243"></a>5243            string[0 .. limit] = &quot;&quot;
</span><span class="uncovered1"><a name="line5244"></a>5244            tmp_str = string
</span><span class="uncovered0"><a name="line5245"></a>5245            data    = [encoding].pack(&quot;C&quot;) + tmp_str
</span><span class="uncovered1"><a name="line5246"></a>5246            length  = data.length
</span><span class="uncovered0"><a name="line5247"></a>5247            header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line5248"></a>5248    
</span><span class="uncovered0"><a name="line5249"></a>5249            append(header, data)
</span><span class="uncovered1"><a name="line5250"></a>5250        end
</span><span class="uncovered0"><a name="line5251"></a>5251    
</span><span class="uncovered1"><a name="line5252"></a>5252        # Pack the record.
</span><span class="uncovered0"><a name="line5253"></a>5253        data    = [encoding].pack(&quot;C&quot;) + string
</span><span class="uncovered1"><a name="line5254"></a>5254        length  = data.length
</span><span class="uncovered0"><a name="line5255"></a>5255        header  = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line5256"></a>5256    
</span><span class="uncovered0"><a name="line5257"></a>5257        append(header, data)
</span><span class="uncovered1"><a name="line5258"></a>5258    end
</span><span class="inferred0"><a name="line5259"></a>5259    
</span><span class="inferred1"><a name="line5260"></a>5260    ###############################################################################
</span><span class="inferred0"><a name="line5261"></a>5261    #
</span><span class="inferred1"><a name="line5262"></a>5262    # _store_txo_continue_2()
</span><span class="inferred0"><a name="line5263"></a>5263    #    my $formats     = $_[0];                # Formatting information
</span><span class="inferred1"><a name="line5264"></a>5264    #
</span><span class="inferred0"><a name="line5265"></a>5265    # Write the second CONTINUE record to follow the TXO record. It contains the
</span><span class="inferred1"><a name="line5266"></a>5266    # formatting information for the string.
</span><span class="inferred0"><a name="line5267"></a>5267    #
</span><span class="marked1"><a name="line5268"></a>5268    def store_txo_continue_2(formats)
</span><span class="uncovered0"><a name="line5269"></a>5269        record      = 0x003C               # Record identifier
</span><span class="uncovered1"><a name="line5270"></a>5270        length      = 0x0000               # Bytes to follow
</span><span class="uncovered0"><a name="line5271"></a>5271    
</span><span class="uncovered1"><a name="line5272"></a>5272        # Pack the record.
</span><span class="uncovered0"><a name="line5273"></a>5273        data = ''
</span><span class="uncovered1"><a name="line5274"></a>5274    
</span><span class="uncovered0"><a name="line5275"></a>5275        formats.each do |a_ref|
</span><span class="uncovered1"><a name="line5276"></a>5276            data = data + [a_ref[0], a_ref[1], 0x0].pack('vvV')
</span><span class="uncovered0"><a name="line5277"></a>5277        end
</span><span class="uncovered1"><a name="line5278"></a>5278    
</span><span class="uncovered0"><a name="line5279"></a>5279        length  = data.length
</span><span class="uncovered1"><a name="line5280"></a>5280        header  = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered0"><a name="line5281"></a>5281    
</span><span class="uncovered1"><a name="line5282"></a>5282        append(header, data)
</span><span class="uncovered0"><a name="line5283"></a>5283    end
</span><span class="inferred1"><a name="line5284"></a>5284    
</span><span class="inferred0"><a name="line5285"></a>5285    ###############################################################################
</span><span class="inferred1"><a name="line5286"></a>5286    #
</span><span class="inferred0"><a name="line5287"></a>5287    # _store_note()
</span><span class="inferred1"><a name="line5288"></a>5288    #    my $row         = $_[0];
</span><span class="inferred0"><a name="line5289"></a>5289    #    my $col         = $_[1];
</span><span class="inferred1"><a name="line5290"></a>5290    #    my $obj_id      = $_[2];
</span><span class="inferred0"><a name="line5291"></a>5291    #    my $author      = $_[3] || $self-&gt;{_comments_author};
</span><span class="inferred1"><a name="line5292"></a>5292    #    my $author_enc  = $_[4] || $self-&gt;{_comments_author_enc};
</span><span class="inferred0"><a name="line5293"></a>5293    #    my $visible     = $_[5];
</span><span class="inferred1"><a name="line5294"></a>5294    #
</span><span class="inferred0"><a name="line5295"></a>5295    # Write the worksheet NOTE record that is part of cell comments.
</span><span class="inferred1"><a name="line5296"></a>5296    #
</span><span class="marked0"><a name="line5297"></a>5297    def store_note(row, col, obj_id, author = nil, author_enc = nil, visible = nil)
</span><span class="uncovered1"><a name="line5298"></a>5298        record      = 0x001C               # Record identifier
</span><span class="uncovered0"><a name="line5299"></a>5299        length      = 0x000C               # Bytes to follow
</span><span class="uncovered1"><a name="line5300"></a>5300 
</span><span class="uncovered0"><a name="line5301"></a>5301        author     = @comments_author     if author.nil?
</span><span class="uncovered1"><a name="line5302"></a>5302        author_enc = @comments_author_enc if author_enc.nil?
</span><span class="uncovered0"><a name="line5303"></a>5303    
</span><span class="uncovered1"><a name="line5304"></a>5304        # Use the visible flag if set by the user or else use the worksheet value.
</span><span class="uncovered0"><a name="line5305"></a>5305        # The flag is also set in _store_mso_opt_comment() but with the opposite
</span><span class="uncovered1"><a name="line5306"></a>5306        # value.
</span><span class="uncovered0"><a name="line5307"></a>5307        unless visible.nil?
</span><span class="uncovered1"><a name="line5308"></a>5308            visible = visible != 0      ? 0x0002 : 0x0000
</span><span class="uncovered0"><a name="line5309"></a>5309        else
</span><span class="uncovered1"><a name="line5310"></a>5310            visible = @comments_visible ? 0x0002 : 0x0000
</span><span class="uncovered0"><a name="line5311"></a>5311        end
</span><span class="uncovered1"><a name="line5312"></a>5312    
</span><span class="uncovered0"><a name="line5313"></a>5313        # Get the number of chars in the author string (not bytes).
</span><span class="uncovered1"><a name="line5314"></a>5314        num_chars  = author.length
</span><span class="uncovered0"><a name="line5315"></a>5315        num_chars  = num_chars / 2 if author_enc != 0 &amp;&amp; !author_enc.nil?
</span><span class="uncovered1"><a name="line5316"></a>5316    
</span><span class="uncovered0"><a name="line5317"></a>5317        # Null terminate the author string.
</span><span class="uncovered1"><a name="line5318"></a>5318        author = author + &quot;\0&quot;
</span><span class="uncovered0"><a name="line5319"></a>5319    
</span><span class="uncovered1"><a name="line5320"></a>5320    
</span><span class="uncovered0"><a name="line5321"></a>5321        # Pack the record.
</span><span class="uncovered1"><a name="line5322"></a>5322        data    = [row, col, visible, obj_id, num_chars, author_enc].pack(&quot;vvvvvC&quot;)
</span><span class="uncovered0"><a name="line5323"></a>5323    
</span><span class="uncovered1"><a name="line5324"></a>5324        length  = data.length + author.length
</span><span class="uncovered0"><a name="line5325"></a>5325        header  = [record, length].pack(&quot;vv&quot;)
</span><span class="uncovered1"><a name="line5326"></a>5326    
</span><span class="uncovered0"><a name="line5327"></a>5327        append(header, data)
</span><span class="uncovered1"><a name="line5328"></a>5328    end
</span><span class="inferred0"><a name="line5329"></a>5329 
</span><span class="inferred1"><a name="line5330"></a>5330    ###############################################################################
</span><span class="inferred0"><a name="line5331"></a>5331    #
</span><span class="inferred1"><a name="line5332"></a>5332    # _comment_params()
</span><span class="inferred0"><a name="line5333"></a>5333    #
</span><span class="inferred1"><a name="line5334"></a>5334    # This method handles the additional optional parameters to write_comment() as
</span><span class="inferred0"><a name="line5335"></a>5335    # well as calculating the comment object position and vertices.
</span><span class="inferred1"><a name="line5336"></a>5336    #
</span><span class="marked0"><a name="line5337"></a>5337    def comment_params(*args)
</span><span class="marked1"><a name="line5338"></a>5338        row    = args.shift
</span><span class="marked0"><a name="line5339"></a>5339        col    = args.shift
</span><span class="marked1"><a name="line5340"></a>5340        string = args.shift
</span><span class="inferred0"><a name="line5341"></a>5341 
</span><span class="marked1"><a name="line5342"></a>5342        params  = {
</span><span class="inferred0"><a name="line5343"></a>5343                        :author          =&gt; '',
</span><span class="inferred1"><a name="line5344"></a>5344                        :author_encoding =&gt; 0,
</span><span class="inferred0"><a name="line5345"></a>5345                        :encoding        =&gt; 0,
</span><span class="inferred1"><a name="line5346"></a>5346                        :color           =&gt; nil,
</span><span class="inferred0"><a name="line5347"></a>5347                        :start_cell      =&gt; nil,
</span><span class="inferred1"><a name="line5348"></a>5348                        :start_col       =&gt; nil,
</span><span class="inferred0"><a name="line5349"></a>5349                        :start_row       =&gt; nil,
</span><span class="inferred1"><a name="line5350"></a>5350                        :visible         =&gt; nil,
</span><span class="inferred0"><a name="line5351"></a>5351                        :width           =&gt; 129,
</span><span class="inferred1"><a name="line5352"></a>5352                        :height          =&gt; 75,
</span><span class="inferred0"><a name="line5353"></a>5353                        :x_offset        =&gt; nil,
</span><span class="inferred1"><a name="line5354"></a>5354                        :x_scale         =&gt; 1,
</span><span class="inferred0"><a name="line5355"></a>5355                        :y_offset        =&gt; nil,
</span><span class="inferred1"><a name="line5356"></a>5356                        :y_scale         =&gt; 1
</span><span class="inferred0"><a name="line5357"></a>5357                 }
</span><span class="inferred1"><a name="line5358"></a>5358    
</span><span class="inferred0"><a name="line5359"></a>5359        # Overwrite the defaults with any user supplied values. Incorrect or
</span><span class="inferred1"><a name="line5360"></a>5360        # misspelled parameters are silently ignored.
</span><span class="inferred0"><a name="line5361"></a>5361 
</span><span class="inferred1"><a name="line5362"></a>5362        ###       params   = (%params, @_);  converted like this.  right?
</span><span class="marked0"><a name="line5363"></a>5363        ary  = Array.new(args)
</span><span class="marked1"><a name="line5364"></a>5364        alist = []
</span><span class="marked0"><a name="line5365"></a>5365        while !ary.empty?
</span><span class="uncovered1"><a name="line5366"></a>5366          alist &lt;&lt; [ary[0], ary[1]]
</span><span class="uncovered0"><a name="line5367"></a>5367          ary.shift
</span><span class="uncovered1"><a name="line5368"></a>5368          ary.shift
</span><span class="uncovered0"><a name="line5369"></a>5369        end
</span><span class="marked1"><a name="line5370"></a>5370        pary = params.to_a
</span><span class="marked0"><a name="line5371"></a>5371        alist.each { |a| pary &lt;&lt; a }
</span><span class="marked1"><a name="line5372"></a>5372        params = Hash[*pary.flatten]
</span><span class="inferred0"><a name="line5373"></a>5373 
</span><span class="inferred1"><a name="line5374"></a>5374        # Ensure that a width and height have been set.
</span><span class="marked0"><a name="line5375"></a>5375        params[:width]  = 129 if not params[:width]
</span><span class="marked1"><a name="line5376"></a>5376        params[:height] = 75  if not params[:height]
</span><span class="inferred0"><a name="line5377"></a>5377    
</span><span class="inferred1"><a name="line5378"></a>5378        # Check that utf16 strings have an even number of bytes.
</span><span class="marked0"><a name="line5379"></a>5379        if params[:encoding] != 0
</span><span class="uncovered1"><a name="line5380"></a>5380            raise &quot;Uneven number of bytes in comment string&quot; if string.length % 2
</span><span class="uncovered0"><a name="line5381"></a>5381    
</span><span class="uncovered1"><a name="line5382"></a>5382            # Change from UTF-16BE to UTF-16LE
</span><span class="uncovered0"><a name="line5383"></a>5383            string = [string].unpack('n*').pack('v*')
</span><span class="uncovered1"><a name="line5384"></a>5384        end
</span><span class="inferred0"><a name="line5385"></a>5385    
</span><span class="marked1"><a name="line5386"></a>5386        if params[:author_encoding] != 0
</span><span class="uncovered0"><a name="line5387"></a>5387            raise &quot;Uneven number of bytes in author string&quot;  if params[:author] % 2
</span><span class="uncovered1"><a name="line5388"></a>5388    
</span><span class="uncovered0"><a name="line5389"></a>5389            # Change from UTF-16BE to UTF-16LE
</span><span class="uncovered1"><a name="line5390"></a>5390            params[:author] = [params[:author]].unpack('n*').pack('v*')
</span><span class="uncovered0"><a name="line5391"></a>5391        end
</span><span class="inferred1"><a name="line5392"></a>5392    
</span><span class="inferred0"><a name="line5393"></a>5393        # Limit the string to the max number of chars (not bytes).
</span><span class="marked1"><a name="line5394"></a>5394        max_len = 32767
</span><span class="marked0"><a name="line5395"></a>5395        max_len = max_len * 2 if params[:encoding] != 0
</span><span class="inferred1"><a name="line5396"></a>5396    
</span><span class="marked0"><a name="line5397"></a>5397        if string.length &gt; max_len
</span><span class="uncovered1"><a name="line5398"></a>5398            string = string[0 .. max_len]
</span><span class="uncovered0"><a name="line5399"></a>5399        end
</span><span class="inferred1"><a name="line5400"></a>5400    
</span><span class="inferred0"><a name="line5401"></a>5401        # Set the comment background colour.
</span><span class="marked1"><a name="line5402"></a>5402        color = params[:color]
</span><span class="marked0"><a name="line5403"></a>5403        color = Format._get_color(color)
</span><span class="marked1"><a name="line5404"></a>5404        color = 0x50 if color == 0x7FFF  # Default color.
</span><span class="marked0"><a name="line5405"></a>5405        params[:color] = color
</span><span class="inferred1"><a name="line5406"></a>5406    
</span><span class="inferred0"><a name="line5407"></a>5407        # Convert a cell reference to a row and column.
</span><span class="marked1"><a name="line5408"></a>5408        unless params[:start_cell].nil?
</span><span class="uncovered0"><a name="line5409"></a>5409            row, col = substitute_cellref(params[:start_cell])
</span><span class="uncovered1"><a name="line5410"></a>5410            params[:start_row] = row
</span><span class="uncovered0"><a name="line5411"></a>5411            params[:start_col] = col
</span><span class="uncovered1"><a name="line5412"></a>5412        end
</span><span class="inferred0"><a name="line5413"></a>5413    
</span><span class="inferred1"><a name="line5414"></a>5414        # Set the default start cell and offsets for the comment. These are
</span><span class="inferred0"><a name="line5415"></a>5415        # generally fixed in relation to the parent cell. However there are
</span><span class="inferred1"><a name="line5416"></a>5416        # some edge cases for cells at the, er, edges.
</span><span class="inferred0"><a name="line5417"></a>5417        #
</span><span class="marked1"><a name="line5418"></a>5418        if params[:start_row].nil?
</span><span class="marked0"><a name="line5419"></a>5419            case row
</span><span class="marked1"><a name="line5420"></a>5420               when 0     then params[:start_row] = 0
</span><span class="marked0"><a name="line5421"></a>5421               when 65533 then params[:start_row] = 65529
</span><span class="marked1"><a name="line5422"></a>5422               when 65534 then params[:start_row] = 65530
</span><span class="marked0"><a name="line5423"></a>5423               when 65535 then params[:start_row] = 65531
</span><span class="marked1"><a name="line5424"></a>5424               else            params[:start_row] = row -1
</span><span class="inferred0"><a name="line5425"></a>5425            end
</span><span class="inferred1"><a name="line5426"></a>5426        end
</span><span class="inferred0"><a name="line5427"></a>5427    
</span><span class="marked1"><a name="line5428"></a>5428        if params[:y_offset].nil?
</span><span class="marked0"><a name="line5429"></a>5429            case row
</span><span class="marked1"><a name="line5430"></a>5430               when 0     then params[:y_offset]  = 2
</span><span class="marked0"><a name="line5431"></a>5431               when 65533 then params[:y_offset]  = 4
</span><span class="marked1"><a name="line5432"></a>5432               when 65534 then params[:y_offset]  = 4
</span><span class="marked0"><a name="line5433"></a>5433               when 65535 then params[:y_offset]  = 2
</span><span class="marked1"><a name="line5434"></a>5434               else            params[:y_offset]  = 7
</span><span class="inferred0"><a name="line5435"></a>5435            end
</span><span class="inferred1"><a name="line5436"></a>5436        end
</span><span class="inferred0"><a name="line5437"></a>5437    
</span><span class="marked1"><a name="line5438"></a>5438        if params[:start_col].nil?
</span><span class="marked0"><a name="line5439"></a>5439            case col
</span><span class="marked1"><a name="line5440"></a>5440               when 253   then params[:start_col] = 250
</span><span class="marked0"><a name="line5441"></a>5441               when 254   then params[:start_col] = 251
</span><span class="marked1"><a name="line5442"></a>5442               when 255   then params[:start_col] = 252
</span><span class="marked0"><a name="line5443"></a>5443               else            params[:start_col] = col + 1
</span><span class="inferred1"><a name="line5444"></a>5444            end
</span><span class="inferred0"><a name="line5445"></a>5445        end
</span><span class="inferred1"><a name="line5446"></a>5446    
</span><span class="marked0"><a name="line5447"></a>5447        if params[:x_offset].nil?
</span><span class="marked1"><a name="line5448"></a>5448            case col
</span><span class="marked0"><a name="line5449"></a>5449               when 253   then params[:x_offset] = 49
</span><span class="marked1"><a name="line5450"></a>5450               when 254   then params[:x_offset] = 49
</span><span class="marked0"><a name="line5451"></a>5451               when 255   then params[:x_offset] = 49
</span><span class="marked1"><a name="line5452"></a>5452               else            params[:x_offset] = 15
</span><span class="inferred0"><a name="line5453"></a>5453            end
</span><span class="inferred1"><a name="line5454"></a>5454        end
</span><span class="inferred0"><a name="line5455"></a>5455    
</span><span class="inferred1"><a name="line5456"></a>5456        # Scale the size of the comment box if required. We scale the width and
</span><span class="inferred0"><a name="line5457"></a>5457        # height using the relationship d2 =(d1 -1)*s +1, where d is dimension
</span><span class="inferred1"><a name="line5458"></a>5458        # and s is scale. This gives values that match Excel's behaviour.
</span><span class="inferred0"><a name="line5459"></a>5459        #
</span><span class="marked1"><a name="line5460"></a>5460        if params[:x_scale] != 0
</span><span class="marked0"><a name="line5461"></a>5461            params[:width]  = ((params[:width]  -1) * params[:x_scale]) +1
</span><span class="inferred1"><a name="line5462"></a>5462        end
</span><span class="inferred0"><a name="line5463"></a>5463    
</span><span class="marked1"><a name="line5464"></a>5464        if params[:y_scale] != 0
</span><span class="marked0"><a name="line5465"></a>5465            params[:height] = ((params[:height] -1) * params[:y_scale]) +1
</span><span class="inferred1"><a name="line5466"></a>5466        end
</span><span class="inferred0"><a name="line5467"></a>5467    
</span><span class="inferred1"><a name="line5468"></a>5468        # Calculate the positions of comment object.
</span><span class="marked0"><a name="line5469"></a>5469        vertices = position_object( params[:start_col],
</span><span class="inferred1"><a name="line5470"></a>5470                                    params[:start_row],
</span><span class="inferred0"><a name="line5471"></a>5471                                    params[:x_offset],
</span><span class="inferred1"><a name="line5472"></a>5472                                    params[:y_offset],
</span><span class="inferred0"><a name="line5473"></a>5473                                    params[:width],
</span><span class="inferred1"><a name="line5474"></a>5474                                    params[:height]
</span><span class="inferred0"><a name="line5475"></a>5475                                  )
</span><span class="inferred1"><a name="line5476"></a>5476    
</span><span class="inferred0"><a name="line5477"></a>5477        return [row, col, string,
</span><span class="inferred1"><a name="line5478"></a>5478                params[:encoding],
</span><span class="inferred0"><a name="line5479"></a>5479                params[:author],
</span><span class="inferred1"><a name="line5480"></a>5480                params[:author_encoding],
</span><span class="inferred0"><a name="line5481"></a>5481                params[:visible],
</span><span class="inferred1"><a name="line5482"></a>5482                params[:color],
</span><span class="inferred0"><a name="line5483"></a>5483                @vertices
</span><span class="marked1"><a name="line5484"></a>5484              ]
</span><span class="inferred0"><a name="line5485"></a>5485    end
</span><span class="inferred1"><a name="line5486"></a>5486 
</span><span class="inferred0"><a name="line5487"></a>5487    #
</span><span class="inferred1"><a name="line5488"></a>5488    # DATA VALIDATION
</span><span class="inferred0"><a name="line5489"></a>5489    #
</span><span class="inferred1"><a name="line5490"></a>5490    
</span><span class="inferred0"><a name="line5491"></a>5491    ###############################################################################
</span><span class="inferred1"><a name="line5492"></a>5492    #
</span><span class="inferred0"><a name="line5493"></a>5493    # data_validation($row, $col, {...})
</span><span class="inferred1"><a name="line5494"></a>5494    #
</span><span class="inferred0"><a name="line5495"></a>5495    # This method handles the interface to Excel data validation.
</span><span class="inferred1"><a name="line5496"></a>5496    # Somewhat ironically the this requires a lot of validation code since the
</span><span class="inferred0"><a name="line5497"></a>5497    # interface is flexible and covers a several types of data validation.
</span><span class="inferred1"><a name="line5498"></a>5498    #
</span><span class="inferred0"><a name="line5499"></a>5499    # We allow data validation to be called on one cell or a range of cells. The
</span><span class="inferred1"><a name="line5500"></a>5500    # hashref contains the validation parameters and must be the last param:
</span><span class="inferred0"><a name="line5501"></a>5501    #    data_validation($row, $col, {...})
</span><span class="inferred1"><a name="line5502"></a>5502    #    data_validation($first_row, $first_col, $last_row, $last_col, {...})
</span><span class="inferred0"><a name="line5503"></a>5503    #
</span><span class="inferred1"><a name="line5504"></a>5504    # Returns  0 : normal termination
</span><span class="inferred0"><a name="line5505"></a>5505    #         -1 : insufficient number of arguments
</span><span class="inferred1"><a name="line5506"></a>5506    #         -2 : row or column out of range
</span><span class="inferred0"><a name="line5507"></a>5507    #         -3 : incorrect parameter.
</span><span class="inferred1"><a name="line5508"></a>5508    #
</span><span class="marked0"><a name="line5509"></a>5509    def data_validation(*args)
</span><span class="uncovered1"><a name="line5510"></a>5510        # Check for a cell reference in A1 notation and substitute row and column
</span><span class="uncovered0"><a name="line5511"></a>5511        if args[0] =~ /^\D/
</span><span class="uncovered1"><a name="line5512"></a>5512            args = substitute_cellref(*args)
</span><span class="uncovered0"><a name="line5513"></a>5513        end
</span><span class="uncovered1"><a name="line5514"></a>5514    
</span><span class="uncovered0"><a name="line5515"></a>5515        # Check for a valid number of args.
</span><span class="uncovered1"><a name="line5516"></a>5516        return -1 if args.size != 5 &amp;&amp; args.size != 3
</span><span class="uncovered0"><a name="line5517"></a>5517    
</span><span class="uncovered1"><a name="line5518"></a>5518        # The final hashref contains the validation parameters.
</span><span class="uncovered0"><a name="line5519"></a>5519        param = args.pop
</span><span class="uncovered1"><a name="line5520"></a>5520    
</span><span class="uncovered0"><a name="line5521"></a>5521        # Make the last row/col the same as the first if not defined.
</span><span class="uncovered1"><a name="line5522"></a>5522        row1, col1, row2, col2 = args
</span><span class="uncovered0"><a name="line5523"></a>5523        if row2.nil?
</span><span class="uncovered1"><a name="line5524"></a>5524            row2 = row1
</span><span class="uncovered0"><a name="line5525"></a>5525            col2 = col1
</span><span class="uncovered1"><a name="line5526"></a>5526        end
</span><span class="uncovered0"><a name="line5527"></a>5527    
</span><span class="uncovered1"><a name="line5528"></a>5528        # Check that row and col are valid without storing the values.
</span><span class="uncovered0"><a name="line5529"></a>5529        return -2 if check_dimensions(row1, col1, 1, 1) != 0
</span><span class="uncovered1"><a name="line5530"></a>5530        return -2 if check_dimensions(row2, col2, 1, 1) != 0
</span><span class="uncovered0"><a name="line5531"></a>5531    
</span><span class="uncovered1"><a name="line5532"></a>5532        # Check that the last parameter is a hash list.
</span><span class="uncovered0"><a name="line5533"></a>5533        unless param.kind_of?(Hash)
</span><span class="uncovered1"><a name="line5534"></a>5534 #           carp &quot;Last parameter '$param' in data_validation() must be a hash ref&quot;;
</span><span class="uncovered0"><a name="line5535"></a>5535            return -3
</span><span class="uncovered1"><a name="line5536"></a>5536        end
</span><span class="uncovered0"><a name="line5537"></a>5537    
</span><span class="uncovered1"><a name="line5538"></a>5538        # List of valid input parameters.
</span><span class="uncovered0"><a name="line5539"></a>5539        valid_parameter = {
</span><span class="uncovered1"><a name="line5540"></a>5540                                  :validate          =&gt; 1,
</span><span class="uncovered0"><a name="line5541"></a>5541                                  :criteria          =&gt; 1,
</span><span class="uncovered1"><a name="line5542"></a>5542                                  :value             =&gt; 1,
</span><span class="uncovered0"><a name="line5543"></a>5543                                  :source            =&gt; 1,
</span><span class="uncovered1"><a name="line5544"></a>5544                                  :minimum           =&gt; 1,
</span><span class="uncovered0"><a name="line5545"></a>5545                                  :maximum           =&gt; 1,
</span><span class="uncovered1"><a name="line5546"></a>5546                                  :ignore_blank      =&gt; 1,
</span><span class="uncovered0"><a name="line5547"></a>5547                                  :dropdown          =&gt; 1,
</span><span class="uncovered1"><a name="line5548"></a>5548                                  :show_input        =&gt; 1,
</span><span class="uncovered0"><a name="line5549"></a>5549                                  :input_title       =&gt; 1,
</span><span class="uncovered1"><a name="line5550"></a>5550                                  :input_message     =&gt; 1,
</span><span class="uncovered0"><a name="line5551"></a>5551                                  :show_error        =&gt; 1,
</span><span class="uncovered1"><a name="line5552"></a>5552                                  :error_title       =&gt; 1,
</span><span class="uncovered0"><a name="line5553"></a>5553                                  :error_message     =&gt; 1,
</span><span class="uncovered1"><a name="line5554"></a>5554                                  :error_type        =&gt; 1,
</span><span class="uncovered0"><a name="line5555"></a>5555                                  :other_cells       =&gt; 1
</span><span class="uncovered1"><a name="line5556"></a>5556                           }
</span><span class="uncovered0"><a name="line5557"></a>5557    
</span><span class="uncovered1"><a name="line5558"></a>5558        # Check for valid input parameters.
</span><span class="uncovered0"><a name="line5559"></a>5559        param.each_key do |param_key|
</span><span class="uncovered1"><a name="line5560"></a>5560            if valid_parameter[param_key].nil?
</span><span class="uncovered0"><a name="line5561"></a>5561 #               carp &quot;Unknown parameter '$param_key' in data_validation()&quot;;
</span><span class="uncovered1"><a name="line5562"></a>5562                return -3
</span><span class="uncovered0"><a name="line5563"></a>5563            end
</span><span class="uncovered1"><a name="line5564"></a>5564        end
</span><span class="uncovered0"><a name="line5565"></a>5565    
</span><span class="uncovered1"><a name="line5566"></a>5566        # Map alternative parameter names 'source' or 'minimum' to 'value'.
</span><span class="uncovered0"><a name="line5567"></a>5567        param[:value] = param[:source]  unless param[:source].nil?
</span><span class="uncovered1"><a name="line5568"></a>5568        param[:value] = param[:minimum] unless param[:minimum].nil?
</span><span class="uncovered0"><a name="line5569"></a>5569    
</span><span class="uncovered1"><a name="line5570"></a>5570        # 'validate' is a required paramter.
</span><span class="uncovered0"><a name="line5571"></a>5571        if param[:validate].nil?
</span><span class="uncovered1"><a name="line5572"></a>5572 #           carp &quot;Parameter 'validate' is required in data_validation()&quot;;
</span><span class="uncovered0"><a name="line5573"></a>5573            return -3
</span><span class="uncovered1"><a name="line5574"></a>5574        end
</span><span class="uncovered0"><a name="line5575"></a>5575    
</span><span class="uncovered1"><a name="line5576"></a>5576        # List of  valid validation types.
</span><span class="uncovered0"><a name="line5577"></a>5577        valid_type = {
</span><span class="uncovered1"><a name="line5578"></a>5578                                  'any'             =&gt; 0,
</span><span class="uncovered0"><a name="line5579"></a>5579                                  'any value'       =&gt; 0,
</span><span class="uncovered1"><a name="line5580"></a>5580                                  'whole number'    =&gt; 1,
</span><span class="uncovered0"><a name="line5581"></a>5581                                  'whole'           =&gt; 1,
</span><span class="uncovered1"><a name="line5582"></a>5582                                  'integer'         =&gt; 1,
</span><span class="uncovered0"><a name="line5583"></a>5583                                  'decimal'         =&gt; 2,
</span><span class="uncovered1"><a name="line5584"></a>5584                                  'list'            =&gt; 3,
</span><span class="uncovered0"><a name="line5585"></a>5585                                  'date'            =&gt; 4,
</span><span class="uncovered1"><a name="line5586"></a>5586                                  'time'            =&gt; 5,
</span><span class="uncovered0"><a name="line5587"></a>5587                                  'text length'     =&gt; 6,
</span><span class="uncovered1"><a name="line5588"></a>5588                                  'length'          =&gt; 6,
</span><span class="uncovered0"><a name="line5589"></a>5589                                  'custom'          =&gt; 7
</span><span class="uncovered1"><a name="line5590"></a>5590                      }
</span><span class="uncovered0"><a name="line5591"></a>5591    
</span><span class="uncovered1"><a name="line5592"></a>5592        # Check for valid validation types.
</span><span class="uncovered0"><a name="line5593"></a>5593        if valid_type[param[:validate].downcase].nil?
</span><span class="uncovered1"><a name="line5594"></a>5594 #           carp &quot;Unknown validation type '$param-&gt;{validate}' for parameter &quot; .
</span><span class="uncovered0"><a name="line5595"></a>5595 #                &quot;'validate' in data_validation()&quot;;
</span><span class="uncovered1"><a name="line5596"></a>5596            return -3
</span><span class="uncovered0"><a name="line5597"></a>5597        else
</span><span class="uncovered1"><a name="line5598"></a>5598            param[:validate] = valid_type[param[:validate].downcase]
</span><span class="uncovered0"><a name="line5599"></a>5599        end
</span><span class="uncovered1"><a name="line5600"></a>5600    
</span><span class="uncovered0"><a name="line5601"></a>5601        # No action is requied for validation type 'any'.
</span><span class="uncovered1"><a name="line5602"></a>5602        # TODO: we should perhaps store 'any' for message only validations.
</span><span class="uncovered0"><a name="line5603"></a>5603        return 0 if param[:validate] == 0
</span><span class="uncovered1"><a name="line5604"></a>5604    
</span><span class="uncovered0"><a name="line5605"></a>5605        # The list and custom validations don't have a criteria so we use a default
</span><span class="uncovered1"><a name="line5606"></a>5606        # of 'between'.
</span><span class="uncovered0"><a name="line5607"></a>5607        if param[:validate] == 3 || param[:validate] == 7
</span><span class="uncovered1"><a name="line5608"></a>5608            param[:criteria]  = 'between'
</span><span class="uncovered0"><a name="line5609"></a>5609            param[:maximum]   = nil
</span><span class="uncovered1"><a name="line5610"></a>5610        end
</span><span class="uncovered0"><a name="line5611"></a>5611    
</span><span class="uncovered1"><a name="line5612"></a>5612        # 'criteria' is a required parameter.
</span><span class="uncovered0"><a name="line5613"></a>5613        if param[:criteria].nil?
</span><span class="uncovered1"><a name="line5614"></a>5614 #           carp &quot;Parameter 'criteria' is required in data_validation()&quot;;
</span><span class="uncovered0"><a name="line5615"></a>5615            return -3
</span><span class="uncovered1"><a name="line5616"></a>5616        end
</span><span class="uncovered0"><a name="line5617"></a>5617    
</span><span class="uncovered1"><a name="line5618"></a>5618        # List of valid criteria types.
</span><span class="uncovered0"><a name="line5619"></a>5619        criteria_type = {
</span><span class="uncovered1"><a name="line5620"></a>5620                                  'between'                     =&gt; 0,
</span><span class="uncovered0"><a name="line5621"></a>5621                                  'not between'                 =&gt; 1,
</span><span class="uncovered1"><a name="line5622"></a>5622                                  'equal to'                    =&gt; 2,
</span><span class="uncovered0"><a name="line5623"></a>5623                                  '='                           =&gt; 2,
</span><span class="uncovered1"><a name="line5624"></a>5624                                  '=='                          =&gt; 2,
</span><span class="uncovered0"><a name="line5625"></a>5625                                  'not equal to'                =&gt; 3,
</span><span class="uncovered1"><a name="line5626"></a>5626                                  '!='                          =&gt; 3,
</span><span class="uncovered0"><a name="line5627"></a>5627                                  '&lt;&gt;'                          =&gt; 3,
</span><span class="uncovered1"><a name="line5628"></a>5628                                  'greater than'                =&gt; 4,
</span><span class="uncovered0"><a name="line5629"></a>5629                                  '&gt;'                           =&gt; 4,
</span><span class="uncovered1"><a name="line5630"></a>5630                                  'less than'                   =&gt; 5,
</span><span class="uncovered0"><a name="line5631"></a>5631                                  '&lt;'                           =&gt; 5,
</span><span class="uncovered1"><a name="line5632"></a>5632                                  'greater than or equal to'    =&gt; 6,
</span><span class="uncovered0"><a name="line5633"></a>5633                                  '&gt;='                          =&gt; 6,
</span><span class="uncovered1"><a name="line5634"></a>5634                                  'less than or equal to'       =&gt; 7,
</span><span class="uncovered0"><a name="line5635"></a>5635                                  '&lt;='                          =&gt; 7
</span><span class="uncovered1"><a name="line5636"></a>5636                        }
</span><span class="uncovered0"><a name="line5637"></a>5637    
</span><span class="uncovered1"><a name="line5638"></a>5638        # Check for valid criteria types.
</span><span class="uncovered0"><a name="line5639"></a>5639        if criteria_type[param[:criteria].downcase].nil?
</span><span class="uncovered1"><a name="line5640"></a>5640 #           carp &quot;Unknown criteria type '$param-&gt;{criteria}' for parameter &quot; .
</span><span class="uncovered0"><a name="line5641"></a>5641 #                &quot;'criteria' in data_validation()&quot;;
</span><span class="uncovered1"><a name="line5642"></a>5642            return -3
</span><span class="uncovered0"><a name="line5643"></a>5643        else
</span><span class="uncovered1"><a name="line5644"></a>5644            param[:criteria] = criteria_type[param[:criteria].downcase]
</span><span class="uncovered0"><a name="line5645"></a>5645        end
</span><span class="uncovered1"><a name="line5646"></a>5646    
</span><span class="uncovered0"><a name="line5647"></a>5647        # 'Between' and 'Not between' criterias require 2 values.
</span><span class="uncovered1"><a name="line5648"></a>5648        if param[:criteria] == 0 || param[:criteria] == 1
</span><span class="uncovered0"><a name="line5649"></a>5649            if param[:maximum].nil?
</span><span class="uncovered1"><a name="line5650"></a>5650 #               carp &quot;Parameter 'maximum' is required in data_validation() &quot; .
</span><span class="uncovered0"><a name="line5651"></a>5651 #                    &quot;when using 'between' or 'not between' criteria&quot;;
</span><span class="uncovered1"><a name="line5652"></a>5652                return -3
</span><span class="uncovered0"><a name="line5653"></a>5653            end
</span><span class="uncovered1"><a name="line5654"></a>5654        else
</span><span class="uncovered0"><a name="line5655"></a>5655            param[:maximum] = nil
</span><span class="uncovered1"><a name="line5656"></a>5656        end
</span><span class="uncovered0"><a name="line5657"></a>5657    
</span><span class="uncovered1"><a name="line5658"></a>5658        # List of valid error dialog types.
</span><span class="uncovered0"><a name="line5659"></a>5659        error_type = {
</span><span class="uncovered1"><a name="line5660"></a>5660                                  'stop'        =&gt; 0,
</span><span class="uncovered0"><a name="line5661"></a>5661                                  'warning'     =&gt; 1,
</span><span class="uncovered1"><a name="line5662"></a>5662                                  'information' =&gt; 2
</span><span class="uncovered0"><a name="line5663"></a>5663                     }
</span><span class="uncovered1"><a name="line5664"></a>5664    
</span><span class="uncovered0"><a name="line5665"></a>5665        # Check for valid error dialog types.
</span><span class="uncovered1"><a name="line5666"></a>5666        if param[:error_type].nil?
</span><span class="uncovered0"><a name="line5667"></a>5667            param[:error_type] = 0
</span><span class="uncovered1"><a name="line5668"></a>5668        elsif error_type[param[:error_type].downcase].nil?
</span><span class="uncovered0"><a name="line5669"></a>5669 #           carp &quot;Unknown criteria type '$param-&gt;{error_type}' for parameter &quot; .
</span><span class="uncovered1"><a name="line5670"></a>5670 #                &quot;'error_type' in data_validation()&quot;;
</span><span class="uncovered0"><a name="line5671"></a>5671            return -3
</span><span class="uncovered1"><a name="line5672"></a>5672        else
</span><span class="uncovered0"><a name="line5673"></a>5673            param[:error_type] = error_type[param[error_type].downcase]
</span><span class="uncovered1"><a name="line5674"></a>5674        end
</span><span class="uncovered0"><a name="line5675"></a>5675    
</span><span class="uncovered1"><a name="line5676"></a>5676        # Convert date/times value sif required.
</span><span class="uncovered0"><a name="line5677"></a>5677        if param[:validate] == 4 || param[:validate] == 5
</span><span class="uncovered1"><a name="line5678"></a>5678            if param[:value] =~ /T/
</span><span class="uncovered0"><a name="line5679"></a>5679                date_time = convert_date_time(param[:value])
</span><span class="uncovered1"><a name="line5680"></a>5680                if date_time.nil?
</span><span class="uncovered0"><a name="line5681"></a>5681 #                   carp &quot;Invalid date/time value '$param-&gt;{value}' &quot; .
</span><span class="uncovered1"><a name="line5682"></a>5682 #                        &quot;in data_validation()&quot;;
</span><span class="uncovered0"><a name="line5683"></a>5683                    return -3
</span><span class="uncovered1"><a name="line5684"></a>5684                else
</span><span class="uncovered0"><a name="line5685"></a>5685                    param[:value] = date_time
</span><span class="uncovered1"><a name="line5686"></a>5686                end
</span><span class="uncovered0"><a name="line5687"></a>5687            end
</span><span class="uncovered1"><a name="line5688"></a>5688            if !param[:maximum].nil? &amp;&amp; param[:maximum] =~ /T/
</span><span class="uncovered0"><a name="line5689"></a>5689                date_time = convert_date_time(param[:maximum])
</span><span class="uncovered1"><a name="line5690"></a>5690    
</span><span class="uncovered0"><a name="line5691"></a>5691                if date_time.nil?
</span><span class="uncovered1"><a name="line5692"></a>5692 #                   carp &quot;Invalid date/time value '$param-&gt;{maximum}' &quot; .
</span><span class="uncovered0"><a name="line5693"></a>5693 #                        &quot;in data_validation()&quot;;
</span><span class="uncovered1"><a name="line5694"></a>5694                    return -3
</span><span class="uncovered0"><a name="line5695"></a>5695                else
</span><span class="uncovered1"><a name="line5696"></a>5696                    param[:maximum] = date_time
</span><span class="uncovered0"><a name="line5697"></a>5697                end
</span><span class="uncovered1"><a name="line5698"></a>5698            end
</span><span class="uncovered0"><a name="line5699"></a>5699        end
</span><span class="uncovered1"><a name="line5700"></a>5700    
</span><span class="uncovered0"><a name="line5701"></a>5701        # Set some defaults if they haven't been defined by the user.
</span><span class="uncovered1"><a name="line5702"></a>5702        param[:ignore_blank]  = 1 if param[:ignore_blank].nil?
</span><span class="uncovered0"><a name="line5703"></a>5703        param[:dropdown]      = 1 if param[:dropdown].nil?
</span><span class="uncovered1"><a name="line5704"></a>5704        param[:show_input]    = 1 if param[:show_input].nil?
</span><span class="uncovered0"><a name="line5705"></a>5705        param[:show_error]    = 1 if param[:show_error].nil?
</span><span class="uncovered1"><a name="line5706"></a>5706    
</span><span class="uncovered0"><a name="line5707"></a>5707        # These are the cells to which the validation is applied.
</span><span class="uncovered1"><a name="line5708"></a>5708        param[:cells] = [[row1, col1, row2, col2]]
</span><span class="uncovered0"><a name="line5709"></a>5709    
</span><span class="uncovered1"><a name="line5710"></a>5710        # A (for now) undocumented parameter to pass additional cell ranges.
</span><span class="uncovered0"><a name="line5711"></a>5711        if !param[:other_cells].nil?
</span><span class="uncovered1"><a name="line5712"></a>5712    
</span><span class="uncovered0"><a name="line5713"></a>5713            param[:cells].push(param[:other_cells])
</span><span class="uncovered1"><a name="line5714"></a>5714        end
</span><span class="uncovered0"><a name="line5715"></a>5715    
</span><span class="uncovered1"><a name="line5716"></a>5716        # Store the validation information until we close the worksheet.
</span><span class="uncovered0"><a name="line5717"></a>5717        @validations.push(param)
</span><span class="uncovered1"><a name="line5718"></a>5718    end
</span><span class="inferred0"><a name="line5719"></a>5719 
</span><span class="inferred1"><a name="line5720"></a>5720    ###############################################################################
</span><span class="inferred0"><a name="line5721"></a>5721    #
</span><span class="inferred1"><a name="line5722"></a>5722    # _store_validation_count()
</span><span class="inferred0"><a name="line5723"></a>5723    #
</span><span class="inferred1"><a name="line5724"></a>5724    # Store the count of the DV records to follow.
</span><span class="inferred0"><a name="line5725"></a>5725    #
</span><span class="inferred1"><a name="line5726"></a>5726    # Note, this could be wrapped into _store_dv() but we may require separate
</span><span class="inferred0"><a name="line5727"></a>5727    # handling of the object id at a later stage.
</span><span class="inferred1"><a name="line5728"></a>5728    #
</span><span class="marked0"><a name="line5729"></a>5729    def store_validation_count
</span><span class="uncovered1"><a name="line5730"></a>5730        dv_count = @validations
</span><span class="uncovered0"><a name="line5731"></a>5731        obj_id   = -1
</span><span class="uncovered1"><a name="line5732"></a>5732    
</span><span class="uncovered0"><a name="line5733"></a>5733        return unless dv_count
</span><span class="uncovered1"><a name="line5734"></a>5734    
</span><span class="uncovered0"><a name="line5735"></a>5735        store_dval(obj_id , dv_count)
</span><span class="uncovered1"><a name="line5736"></a>5736    end
</span><span class="inferred0"><a name="line5737"></a>5737    
</span><span class="inferred1"><a name="line5738"></a>5738    ###############################################################################
</span><span class="inferred0"><a name="line5739"></a>5739    #
</span><span class="inferred1"><a name="line5740"></a>5740    # _store_validations()
</span><span class="inferred0"><a name="line5741"></a>5741    #
</span><span class="inferred1"><a name="line5742"></a>5742    # Store the data_validation records.
</span><span class="inferred0"><a name="line5743"></a>5743    #
</span><span class="marked1"><a name="line5744"></a>5744    def store_validations
</span><span class="uncovered0"><a name="line5745"></a>5745        return if @validations.size == 0
</span><span class="uncovered1"><a name="line5746"></a>5746    
</span><span class="uncovered0"><a name="line5747"></a>5747        @validations.each do |param|
</span><span class="uncovered1"><a name="line5748"></a>5748            store_dv(           param[:cells],
</span><span class="uncovered0"><a name="line5749"></a>5749                                param[:validate],
</span><span class="uncovered1"><a name="line5750"></a>5750                                param[:criteria],
</span><span class="uncovered0"><a name="line5751"></a>5751                                param[:value],
</span><span class="uncovered1"><a name="line5752"></a>5752                                param[:maximum],
</span><span class="uncovered0"><a name="line5753"></a>5753                                param[:input_title],
</span><span class="uncovered1"><a name="line5754"></a>5754                                param[:input_message],
</span><span class="uncovered0"><a name="line5755"></a>5755                                param[:error_title],
</span><span class="uncovered1"><a name="line5756"></a>5756                                param[:error_message],
</span><span class="uncovered0"><a name="line5757"></a>5757                                param[:error_type],
</span><span class="uncovered1"><a name="line5758"></a>5758                                param[:ignore_blank],
</span><span class="uncovered0"><a name="line5759"></a>5759                                param[:dropdown],
</span><span class="uncovered1"><a name="line5760"></a>5760                                param[:show_input],
</span><span class="uncovered0"><a name="line5761"></a>5761                                param[:show_error]
</span><span class="uncovered1"><a name="line5762"></a>5762                     )
</span><span class="uncovered0"><a name="line5763"></a>5763        end
</span><span class="uncovered1"><a name="line5764"></a>5764    end
</span><span class="inferred0"><a name="line5765"></a>5765    
</span><span class="inferred1"><a name="line5766"></a>5766    ###############################################################################
</span><span class="inferred0"><a name="line5767"></a>5767    #
</span><span class="inferred1"><a name="line5768"></a>5768    # _store_dval()
</span><span class="inferred0"><a name="line5769"></a>5769    #    my $obj_id      = $_[0];        # Object ID number.
</span><span class="inferred1"><a name="line5770"></a>5770    #    my $dv_count    = $_[1];        # Count of DV structs to follow.
</span><span class="inferred0"><a name="line5771"></a>5771    #
</span><span class="inferred1"><a name="line5772"></a>5772    # Store the DV record which contains the number of and information common to
</span><span class="inferred0"><a name="line5773"></a>5773    # all DV structures.
</span><span class="inferred1"><a name="line5774"></a>5774    #
</span><span class="marked0"><a name="line5775"></a>5775    def store_dval(obj_id, dv_count)
</span><span class="uncovered1"><a name="line5776"></a>5776        record      = 0x01B2       # Record identifier
</span><span class="uncovered0"><a name="line5777"></a>5777        length      = 0x0012       # Bytes to follow
</span><span class="uncovered1"><a name="line5778"></a>5778    
</span><span class="uncovered0"><a name="line5779"></a>5779        flags       = 0x0004       # Option flags.
</span><span class="uncovered1"><a name="line5780"></a>5780        x_coord     = 0x00000000   # X coord of input box.
</span><span class="uncovered0"><a name="line5781"></a>5781        y_coord     = 0x00000000   # Y coord of input box.
</span><span class="uncovered1"><a name="line5782"></a>5782    
</span><span class="uncovered0"><a name="line5783"></a>5783        # Pack the record.
</span><span class="uncovered1"><a name="line5784"></a>5784        header = [record, length].pack('vv')
</span><span class="uncovered0"><a name="line5785"></a>5785        data   = [flags, x_coord, y_coord, obj_id, dv_count].pack('vVVVV')
</span><span class="uncovered1"><a name="line5786"></a>5786    
</span><span class="uncovered0"><a name="line5787"></a>5787        append(header, data)
</span><span class="uncovered1"><a name="line5788"></a>5788    end
</span><span class="inferred0"><a name="line5789"></a>5789    
</span><span class="inferred1"><a name="line5790"></a>5790    ###############################################################################
</span><span class="inferred0"><a name="line5791"></a>5791    #
</span><span class="inferred1"><a name="line5792"></a>5792    # _store_dv()
</span><span class="inferred0"><a name="line5793"></a>5793    #    my $cells           = $_[0];        # Aref of cells to which DV applies.
</span><span class="inferred1"><a name="line5794"></a>5794    #    my $validation_type = $_[1];        # Type of data validation.
</span><span class="inferred0"><a name="line5795"></a>5795    #    my $criteria_type   = $_[2];        # Validation criteria.
</span><span class="inferred1"><a name="line5796"></a>5796    #    my $formula_1       = $_[3];        # Value/Source/Minimum formula.
</span><span class="inferred0"><a name="line5797"></a>5797    #    my $formula_2       = $_[4];        # Maximum formula.
</span><span class="inferred1"><a name="line5798"></a>5798    #    my $input_title     = $_[5];        # Title of input message.
</span><span class="inferred0"><a name="line5799"></a>5799    #    my $input_message   = $_[6];        # Text of input message.
</span><span class="inferred1"><a name="line5800"></a>5800    #    my $error_title     = $_[7];        # Title of error message.
</span><span class="inferred0"><a name="line5801"></a>5801    #    my $error_message   = $_[8];        # Text of input message.
</span><span class="inferred1"><a name="line5802"></a>5802    #    my $error_type      = $_[9];        # Error dialog type.
</span><span class="inferred0"><a name="line5803"></a>5803    #    my $ignore_blank    = $_[10];       # Ignore blank cells.
</span><span class="inferred1"><a name="line5804"></a>5804    #    my $dropdown        = $_[11];       # Display dropdown with list.
</span><span class="inferred0"><a name="line5805"></a>5805    #    my $input_box       = $_[12];       # Display input box.
</span><span class="inferred1"><a name="line5806"></a>5806    #    my $error_box       = $_[13];       # Display error box.
</span><span class="inferred0"><a name="line5807"></a>5807    #
</span><span class="inferred1"><a name="line5808"></a>5808    # Store the DV record that specifies the data validation criteria and options
</span><span class="inferred0"><a name="line5809"></a>5809    # for a range of cells..
</span><span class="inferred1"><a name="line5810"></a>5810    #
</span><span class="inferred0"><a name="line5811"></a>5811    def store_dv(cells, validation_type, criteria_type,
</span><span class="inferred1"><a name="line5812"></a>5812                 formula_1, formula_2, input_title, input_message,
</span><span class="inferred0"><a name="line5813"></a>5813                 error_title, error_message, error_type,
</span><span class="marked1"><a name="line5814"></a>5814                 ignore_blank, dropdown, input_box, error_box)
</span><span class="uncovered0"><a name="line5815"></a>5815        record          = 0x01BE       # Record identifier
</span><span class="uncovered1"><a name="line5816"></a>5816        length          = 0x0000       # Bytes to follow
</span><span class="uncovered0"><a name="line5817"></a>5817    
</span><span class="uncovered1"><a name="line5818"></a>5818        flags           = 0x00000000   # DV option flags.
</span><span class="uncovered0"><a name="line5819"></a>5819    
</span><span class="uncovered1"><a name="line5820"></a>5820        ime_mode        = 0            # IME input mode for far east fonts.
</span><span class="uncovered0"><a name="line5821"></a>5821        str_lookup      = 0            # See below.
</span><span class="uncovered1"><a name="line5822"></a>5822    
</span><span class="uncovered0"><a name="line5823"></a>5823        # Set the string lookup flag for 'list' validations with a string array.
</span><span class="uncovered1"><a name="line5824"></a>5824        if validation_type == 3 &amp;&amp; formula_1.kind_of?(Array)
</span><span class="uncovered0"><a name="line5825"></a>5825            str_lookup = 1
</span><span class="uncovered1"><a name="line5826"></a>5826        end
</span><span class="uncovered0"><a name="line5827"></a>5827    
</span><span class="uncovered1"><a name="line5828"></a>5828        # The dropdown flag is stored as a negated value.
</span><span class="uncovered0"><a name="line5829"></a>5829        no_dropdown = !dropdown
</span><span class="uncovered1"><a name="line5830"></a>5830    
</span><span class="uncovered0"><a name="line5831"></a>5831        # Set the required flags.
</span><span class="uncovered1"><a name="line5832"></a>5832        flags |= validation_type
</span><span class="uncovered0"><a name="line5833"></a>5833        flags |= error_type       &lt;&lt; 4
</span><span class="uncovered1"><a name="line5834"></a>5834        flags |= str_lookup       &lt;&lt; 7
</span><span class="uncovered0"><a name="line5835"></a>5835        flags |= ignore_blank     &lt;&lt; 8
</span><span class="uncovered1"><a name="line5836"></a>5836        flags |= no_dropdown      &lt;&lt; 9
</span><span class="uncovered0"><a name="line5837"></a>5837        flags |= ime_mode         &lt;&lt; 10
</span><span class="uncovered1"><a name="line5838"></a>5838        flags |= input_box        &lt;&lt; 18
</span><span class="uncovered0"><a name="line5839"></a>5839        flags |= error_box        &lt;&lt; 19
</span><span class="uncovered1"><a name="line5840"></a>5840        flags |= criteria_type    &lt;&lt; 20
</span><span class="uncovered0"><a name="line5841"></a>5841    
</span><span class="uncovered1"><a name="line5842"></a>5842        # Pack the validation formulas.
</span><span class="uncovered0"><a name="line5843"></a>5843        formula_1 = pack_dv_formula(formula_1)
</span><span class="uncovered1"><a name="line5844"></a>5844        formula_2 = pack_dv_formula(formula_2)
</span><span class="uncovered0"><a name="line5845"></a>5845    
</span><span class="uncovered1"><a name="line5846"></a>5846        # Pack the input and error dialog strings.
</span><span class="uncovered0"><a name="line5847"></a>5847        input_title   = pack_dv_string(input_title,   32 )
</span><span class="uncovered1"><a name="line5848"></a>5848        error_title   = pack_dv_string(error_title,   32 )
</span><span class="uncovered0"><a name="line5849"></a>5849        input_message = pack_dv_string(input_message, 255)
</span><span class="uncovered1"><a name="line5850"></a>5850        error_message = pack_dv_string(error_message, 255)
</span><span class="uncovered0"><a name="line5851"></a>5851    
</span><span class="uncovered1"><a name="line5852"></a>5852        # Pack the DV cell data.
</span><span class="uncovered0"><a name="line5853"></a>5853        dv_count = cells.size
</span><span class="uncovered1"><a name="line5854"></a>5854        dv_data  = [dv_count].pack('v')
</span><span class="uncovered0"><a name="line5855"></a>5855        cells.each do |range|
</span><span class="uncovered1"><a name="line5856"></a>5856            dv_data = dv_data + [range[0]+range[1]+range[2]+range[3]].pack('vvvv')
</span><span class="uncovered0"><a name="line5857"></a>5857        end
</span><span class="uncovered1"><a name="line5858"></a>5858    
</span><span class="uncovered0"><a name="line5859"></a>5859        # Pack the record.
</span><span class="uncovered1"><a name="line5860"></a>5860        data   = [flags].pack('V')            +
</span><span class="uncovered0"><a name="line5861"></a>5861                 input_title                  +
</span><span class="uncovered1"><a name="line5862"></a>5862                 error_title                  +
</span><span class="uncovered0"><a name="line5863"></a>5863                 input_message                +
</span><span class="uncovered1"><a name="line5864"></a>5864                 error_message                +
</span><span class="uncovered0"><a name="line5865"></a>5865                 formula_1                    +
</span><span class="uncovered1"><a name="line5866"></a>5866                 formula_2                    +
</span><span class="uncovered0"><a name="line5867"></a>5867                 dv_data
</span><span class="uncovered1"><a name="line5868"></a>5868    
</span><span class="uncovered0"><a name="line5869"></a>5869        header = [record, length].pack('vv')
</span><span class="uncovered1"><a name="line5870"></a>5870 
</span><span class="uncovered0"><a name="line5871"></a>5871        append(header, data)
</span><span class="uncovered1"><a name="line5872"></a>5872    end
</span><span class="inferred0"><a name="line5873"></a>5873 
</span><span class="inferred1"><a name="line5874"></a>5874    ###############################################################################
</span><span class="inferred0"><a name="line5875"></a>5875    #
</span><span class="inferred1"><a name="line5876"></a>5876    # _pack_dv_string()
</span><span class="inferred0"><a name="line5877"></a>5877    #
</span><span class="inferred1"><a name="line5878"></a>5878    # Pack the strings used in the input and error dialog captions and messages.
</span><span class="inferred0"><a name="line5879"></a>5879    # Captions are limited to 32 characters. Messages are limited to 255 chars.
</span><span class="inferred1"><a name="line5880"></a>5880    #
</span><span class="marked0"><a name="line5881"></a>5881    def pack_dv_string(string = nil, max_length = 0)
</span><span class="uncovered1"><a name="line5882"></a>5882        str_length  = 0
</span><span class="uncovered0"><a name="line5883"></a>5883        encoding    = 0
</span><span class="uncovered1"><a name="line5884"></a>5884    
</span><span class="uncovered0"><a name="line5885"></a>5885        # The default empty string is &quot;\0&quot;.
</span><span class="uncovered1"><a name="line5886"></a>5886        if string.nil? || string == ''
</span><span class="uncovered0"><a name="line5887"></a>5887            string = &quot;\0&quot;
</span><span class="uncovered1"><a name="line5888"></a>5888        end
</span><span class="uncovered0"><a name="line5889"></a>5889    
</span><span class="uncovered1"><a name="line5890"></a>5890        # Excel limits DV captions to 32 chars and messages to 255.
</span><span class="uncovered0"><a name="line5891"></a>5891        if string.length &gt; max_length
</span><span class="uncovered1"><a name="line5892"></a>5892            string = string[0 .. max_length]
</span><span class="uncovered0"><a name="line5893"></a>5893        end
</span><span class="uncovered1"><a name="line5894"></a>5894    
</span><span class="uncovered0"><a name="line5895"></a>5895        str_length = string.length
</span><span class="uncovered1"><a name="line5896"></a>5896    
</span><span class="uncovered0"><a name="line5897"></a>5897        return [str_length, encoding].pack('vC') + string
</span><span class="uncovered1"><a name="line5898"></a>5898    end
</span><span class="inferred0"><a name="line5899"></a>5899    
</span><span class="inferred1"><a name="line5900"></a>5900    ###############################################################################
</span><span class="inferred0"><a name="line5901"></a>5901    #
</span><span class="inferred1"><a name="line5902"></a>5902    # _pack_dv_formula()
</span><span class="inferred0"><a name="line5903"></a>5903    #
</span><span class="inferred1"><a name="line5904"></a>5904    # Pack the formula used in the DV record. This is the same as an cell formula
</span><span class="inferred0"><a name="line5905"></a>5905    # with some additional header information. Note, DV formulas in Excel use
</span><span class="inferred1"><a name="line5906"></a>5906    # relative addressing (R1C1 and ptgXxxN) however we use the Formula.pm's
</span><span class="inferred0"><a name="line5907"></a>5907    # default absoulute addressing (A1 and ptgXxx).
</span><span class="inferred1"><a name="line5908"></a>5908    #
</span><span class="marked0"><a name="line5909"></a>5909    def pack_dv_formula(formula = nil)
</span><span class="uncovered1"><a name="line5910"></a>5910        encoding    = 0
</span><span class="uncovered0"><a name="line5911"></a>5911        length      = 0
</span><span class="uncovered1"><a name="line5912"></a>5912        unused      = 0x0000
</span><span class="uncovered0"><a name="line5913"></a>5913        tokens      = []
</span><span class="uncovered1"><a name="line5914"></a>5914    
</span><span class="uncovered0"><a name="line5915"></a>5915        # Return a default structure for unused formulas.
</span><span class="uncovered1"><a name="line5916"></a>5916        if formula.nil? || formula == ''
</span><span class="uncovered0"><a name="line5917"></a>5917            return [0, unused].pack('vv')
</span><span class="uncovered1"><a name="line5918"></a>5918        end
</span><span class="uncovered0"><a name="line5919"></a>5919    
</span><span class="uncovered1"><a name="line5920"></a>5920        # Pack a list array ref as a null separated string.
</span><span class="uncovered0"><a name="line5921"></a>5921        if formula.kind_of?(Array)
</span><span class="uncovered1"><a name="line5922"></a>5922            formula   = formula.join(&quot;\0&quot;)
</span><span class="uncovered0"><a name="line5923"></a>5923            formula   = '&quot;' + formula + '&quot;'
</span><span class="uncovered1"><a name="line5924"></a>5924        end
</span><span class="uncovered0"><a name="line5925"></a>5925    
</span><span class="uncovered1"><a name="line5926"></a>5926        # Strip the = sign at the beginning of the formula string
</span><span class="uncovered0"><a name="line5927"></a>5927        formula.sub!(/^=/, '')
</span><span class="uncovered1"><a name="line5928"></a>5928    
</span><span class="uncovered0"><a name="line5929"></a>5929        # Parse the formula using the parser in Formula.pm
</span><span class="uncovered1"><a name="line5930"></a>5930        parser  = @parser
</span><span class="uncovered0"><a name="line5931"></a>5931    
</span><span class="uncovered1"><a name="line5932"></a>5932        # In order to raise formula errors from the point of view of the calling
</span><span class="uncovered0"><a name="line5933"></a>5933        # program we use an eval block and re-raise the error from here.
</span><span class="uncovered1"><a name="line5934"></a>5934        #
</span><span class="uncovered0"><a name="line5935"></a>5935        tokens = parser.parse_formula(formula)   # ????
</span><span class="uncovered1"><a name="line5936"></a>5936    
</span><span class="uncovered0"><a name="line5937"></a>5937 #       if ($@) {
</span><span class="uncovered1"><a name="line5938"></a>5938 #           $@ =~ s/\n$//;  # Strip the \n used in the Formula.pm die()
</span><span class="uncovered0"><a name="line5939"></a>5939 #           croak $@;       # Re-raise the error
</span><span class="uncovered1"><a name="line5940"></a>5940 #       }
</span><span class="uncovered0"><a name="line5941"></a>5941 #       else {
</span><span class="uncovered1"><a name="line5942"></a>5942 #           # TODO test for non valid ptgs such as Sheet2!A1
</span><span class="uncovered0"><a name="line5943"></a>5943 #       }
</span><span class="uncovered1"><a name="line5944"></a>5944    
</span><span class="uncovered0"><a name="line5945"></a>5945        # Force 2d ranges to be a reference class.
</span><span class="uncovered1"><a name="line5946"></a>5946        tokens.each do |t|
</span><span class="uncovered0"><a name="line5947"></a>5947          t.sub!(/_range2d/, &quot;_range2dR&quot;)
</span><span class="uncovered1"><a name="line5948"></a>5948        end
</span><span class="uncovered0"><a name="line5949"></a>5949    
</span><span class="uncovered1"><a name="line5950"></a>5950        # Parse the tokens into a formula string.
</span><span class="uncovered0"><a name="line5951"></a>5951        formula = parser.parse_tokens(tokens)
</span><span class="uncovered1"><a name="line5952"></a>5952    
</span><span class="uncovered0"><a name="line5953"></a>5953        return [formula.length, unused].pack('vv')
</span><span class="uncovered1"><a name="line5954"></a>5954    end
</span><span class="uncovered0"><a name="line5955"></a>5955 
</span><span class="uncovered1"><a name="line5956"></a>5956 end
</span><span class="inferred0"><a name="line5957"></a>5957 
</span><span class="inferred1"><a name="line5958"></a>5958 =begin
</span><span class="inferred0"><a name="line5959"></a>5959 = Differences between Worksheet.pm and worksheet.rb
</span><span class="inferred1"><a name="line5960"></a>5960 ---write_url
</span><span class="inferred0"><a name="line5961"></a>5961    I made this a public method to be called directly by the user if they want
</span><span class="inferred1"><a name="line5962"></a>5962    to write a url string.  A variable number of arguments made it a pain to
</span><span class="inferred0"><a name="line5963"></a>5963    integrate into the 'write' method.
</span><span class="inferred1"><a name="line5964"></a>5964 =end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
